"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/groq-js";
exports.ids = ["vendor-chunks/groq-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/groq-js/dist/1.mjs":
/*!*****************************************!*\
  !*** ./node_modules/groq-js/dist/1.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTime: () => (/* binding */ DateTime),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   createReferenceTypeNode: () => (/* binding */ createReferenceTypeNode),\n/* harmony export */   evaluate: () => (/* binding */ evaluateQuery),\n/* harmony export */   evaluateSync: () => (/* binding */ evaluateQuerySync),\n/* harmony export */   isSelectorNested: () => (/* binding */ isSelectorNested),\n/* harmony export */   isSelectorNode: () => (/* binding */ isSelectorNode),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   toJS: () => (/* binding */ toJS),\n/* harmony export */   typeEvaluate: () => (/* binding */ typeEvaluate)\n/* harmony export */ });\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\n\nfunction escapeRegExp(string2) {\n  return string2.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction pathRegExp(pattern) {\n  const re = [];\n  for (const part of pattern.split(\".\"))\n    part === \"*\" ? re.push(\"[^.]+\") : part === \"**\" ? re.push(\".*\") : re.push(escapeRegExp(part));\n  return new RegExp(`^${re.join(\".\")}$`);\n}\nclass Path {\n  pattern;\n  patternRe;\n  constructor(pattern) {\n    this.pattern = pattern, this.patternRe = pathRegExp(pattern);\n  }\n  matches(str) {\n    return this.patternRe.test(str);\n  }\n  toJSON() {\n    return this.pattern;\n  }\n}\nconst RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\nfunction parseRFC3339(str) {\n  return RFC3339_REGEX.test(str) ? new Date(str) : null;\n}\nfunction formatRFC3339(d) {\n  const year = addLeadingZero(d.getUTCFullYear(), 4), month = addLeadingZero(d.getUTCMonth() + 1, 2), day = addLeadingZero(d.getUTCDate(), 2), hour = addLeadingZero(d.getUTCHours(), 2), minute = addLeadingZero(d.getUTCMinutes(), 2), second = addLeadingZero(d.getUTCSeconds(), 2);\n  let fractionalSecond = \"\";\n  const millis = d.getMilliseconds();\n  return millis != 0 && (fractionalSecond = `.${addLeadingZero(millis, 3)}`), `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`;\n}\nfunction addLeadingZero(num, targetLength) {\n  let str = num.toString();\n  for (; str.length < targetLength; )\n    str = `0${str}`;\n  return str;\n}\nclass StaticValue {\n  data;\n  type;\n  constructor(data, type) {\n    this.data = data, this.type = type;\n  }\n  isArray() {\n    return this.type === \"array\";\n  }\n  // eslint-disable-next-line require-await\n  async get() {\n    return this.data;\n  }\n  asStatic() {\n    return this;\n  }\n  [Symbol.asyncIterator]() {\n    if (Array.isArray(this.data))\n      return function* (data) {\n        for (const element of data)\n          yield fromJS(element);\n      }(this.data);\n    throw new Error(`Cannot iterate over: ${this.type}`);\n  }\n}\nconst NULL_VALUE = new StaticValue(null, \"null\"), TRUE_VALUE = new StaticValue(!0, \"boolean\"), FALSE_VALUE = new StaticValue(!1, \"boolean\");\nclass DateTime {\n  date;\n  constructor(date) {\n    this.date = date;\n  }\n  static parseToValue(str) {\n    const date = parseRFC3339(str);\n    return date ? new StaticValue(new DateTime(date), \"datetime\") : NULL_VALUE;\n  }\n  equals(other) {\n    return this.date.getTime() == other.date.getTime();\n  }\n  add(secs) {\n    const copy = new Date(this.date.getTime());\n    return copy.setTime(copy.getTime() + secs * 1e3), new DateTime(copy);\n  }\n  difference(other) {\n    return (this.date.getTime() - other.date.getTime()) / 1e3;\n  }\n  compareTo(other) {\n    return this.date.getTime() - other.date.getTime();\n  }\n  toString() {\n    return formatRFC3339(this.date);\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nfunction fromNumber(num) {\n  return Number.isFinite(num) ? new StaticValue(num, \"number\") : NULL_VALUE;\n}\nfunction fromString(str) {\n  return new StaticValue(str, \"string\");\n}\nfunction fromDateTime(dt) {\n  return new StaticValue(dt, \"datetime\");\n}\nfunction fromPath(path) {\n  return new StaticValue(path, \"path\");\n}\nfunction isIterator(obj) {\n  return obj && typeof obj.next == \"function\";\n}\nfunction fromArray(val) {\n  return new StaticValue(val, \"array\");\n}\nfunction fromJS(val) {\n  return isIterator(val) ? new StreamValue(async function* () {\n    for await (const value of val)\n      yield fromJS(value);\n  }) : val == null ? NULL_VALUE : new StaticValue(val, getType(val));\n}\nfunction toJS(val) {\n  const normalized = maybeNormalize(val.data);\n  return normalized === void 0 ? val.data : normalized;\n}\nfunction maybeNormalize(data) {\n  if (!(data === null || typeof data > \"u\")) {\n    if (Array.isArray(data)) {\n      let result;\n      for (let i = 0; i < data.length; i++) {\n        let normalized = maybeNormalize(data[i]);\n        normalized !== void 0 && result === void 0 && (result = data.slice(0, i)), result !== void 0 && (normalized === void 0 && (normalized = data[i]), result.push(normalized));\n      }\n      return result;\n    }\n    if (typeof data == \"object\") {\n      if (\"toJSON\" in data && typeof data.toJSON == \"function\")\n        return data.toJSON();\n      const entries = Object.entries(data);\n      let result;\n      for (let i = 0; i < entries.length; i++) {\n        const [key, value] = entries[i];\n        let normalized = maybeNormalize(value);\n        normalized !== void 0 && result === void 0 && (result = Object.fromEntries(entries.slice(0, i))), result !== void 0 && (normalized === void 0 && (normalized = value), result[key] = normalized);\n      }\n      return result;\n    }\n  }\n}\nfunction getType(data) {\n  return data === null || typeof data > \"u\" ? \"null\" : Array.isArray(data) ? \"array\" : data instanceof Path ? \"path\" : data instanceof DateTime ? \"datetime\" : typeof data;\n}\nclass StreamValue {\n  type = \"stream\";\n  generator;\n  ticker;\n  isDone;\n  data;\n  constructor(generator) {\n    this.generator = generator, this.ticker = null, this.isDone = !1, this.data = [];\n  }\n  // eslint-disable-next-line class-methods-use-this\n  isArray() {\n    return !0;\n  }\n  async get() {\n    const result = [];\n    for await (const value of this)\n      result.push(await value.get());\n    return result;\n  }\n  async asStatic() {\n    return new StaticValue(await this.get(), \"array\");\n  }\n  async *[Symbol.asyncIterator]() {\n    let i = 0;\n    for (; ; ) {\n      for (; i < this.data.length; i++)\n        yield this.data[i];\n      if (this.isDone)\n        return;\n      await this._nextTick();\n    }\n  }\n  _nextTick() {\n    if (this.ticker)\n      return this.ticker;\n    let currentResolver, currentRejector;\n    const setupTicker = () => {\n      this.ticker = new Promise((resolve, reject) => {\n        currentResolver = resolve, currentRejector = reject;\n      });\n    }, tick = () => {\n      currentResolver(), setupTicker();\n    }, fetch = async () => {\n      try {\n        for await (const value of this.generator())\n          this.data.push(value), tick();\n        this.isDone = !0, tick();\n      } catch (error) {\n        currentRejector(error);\n      }\n    };\n    return setupTicker(), fetch(), this.ticker;\n  }\n}\nfunction isEqual(a, b) {\n  return a.type === \"string\" && b.type === \"string\" || a.type === \"boolean\" && b.type === \"boolean\" || a.type === \"null\" && b.type === \"null\" || a.type === \"number\" && b.type === \"number\" ? a.data === b.data : a.type === \"datetime\" && b.type === \"datetime\" ? a.data.equals(b.data) : !1;\n}\nfunction deepEqual(a, b) {\n  if (a === null || b === null) return a === b;\n  const typeOfA = typeof a, typeOfB = typeof b;\n  if (typeOfA === \"undefined\" && typeOfB === \"undefined\") return !0;\n  if (typeOfA === \"function\" && typeOfB === \"function\") return a === b;\n  if (typeOfA === \"object\" && typeOfB === \"object\") {\n    const keysOfA = Object.keys(a), keysOfB = Object.keys(b);\n    if (keysOfA.length !== keysOfB.length) return !1;\n    for (const key of keysOfA)\n      if (!deepEqual(a[key], b[key])) return !1;\n    return !0;\n  }\n  return a === b;\n}\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g, CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g, EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g;\nfunction matchText(tokens, patterns) {\n  return tokens.length === 0 || patterns.length === 0 ? !1 : patterns.every((pattern) => pattern(tokens));\n}\nfunction matchTokenize(text2) {\n  return text2.replace(EDGE_CHARS, \"\").match(CHARS) || [];\n}\nfunction matchAnalyzePattern(text2) {\n  return matchPatternRegex(text2).map((re) => (tokens) => tokens.some((token) => re.test(token)));\n}\nfunction matchPatternRegex(text2) {\n  return (text2.replace(EDGE_CHARS, \"\").match(CHARS_WITH_WILDCARD) || []).map(\n    (term) => new RegExp(`^${term.slice(0, 1024).replace(/\\*/g, \".*\")}$`, \"i\")\n  );\n}\nfunction gatherText(value, flatMap2) {\n  if (value.type === \"string\")\n    return { parts: flatMap2(value.data), success: !0 };\n  if (value.type === \"array\") {\n    let success = !0;\n    const parts = [];\n    for (const part of value.data)\n      typeof part == \"string\" ? parts.push(...flatMap2(part)) : success = !1;\n    return { parts, success };\n  }\n  return value.type === \"stream\" ? (async () => {\n    let success = !0;\n    const parts = [];\n    for await (const part of value)\n      part.type === \"string\" ? parts.push(...flatMap2(part.data)) : success = !1;\n    return { parts, success };\n  })() : { parts: [], success: !1 };\n}\nconst TYPE_ORDER = {\n  datetime: 1,\n  number: 2,\n  string: 3,\n  boolean: 4\n};\nfunction partialCompare(a, b) {\n  const aType = getType(a), bType = getType(b);\n  if (aType !== bType)\n    return null;\n  switch (aType) {\n    case \"number\":\n    case \"boolean\":\n      return a - b;\n    case \"string\":\n      return a < b ? -1 : a > b ? 1 : 0;\n    case \"datetime\":\n      return a.compareTo(b);\n    default:\n      return null;\n  }\n}\nfunction totalCompare(a, b) {\n  const aType = getType(a), bType = getType(b), aTypeOrder = TYPE_ORDER[aType] || 100, bTypeOrder = TYPE_ORDER[bType] || 100;\n  if (aTypeOrder !== bTypeOrder)\n    return aTypeOrder - bTypeOrder;\n  let result = partialCompare(a, b);\n  return result === null && (result = 0), result;\n}\nconst operators = {\n  \"==\": function(left, right) {\n    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"!=\": function(left, right) {\n    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\n  },\n  \">\": function(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    return result === null ? NULL_VALUE : result > 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \">=\": function(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    return result === null ? NULL_VALUE : result >= 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"<\": function(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    return result === null ? NULL_VALUE : result < 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  \"<=\": function(left, right) {\n    if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n    const result = partialCompare(left.data, right.data);\n    return result === null ? NULL_VALUE : result <= 0 ? TRUE_VALUE : FALSE_VALUE;\n  },\n  // eslint-disable-next-line func-name-matching\n  in: function(left, right) {\n    if (right.type === \"path\")\n      return left.type !== \"string\" ? NULL_VALUE : right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE;\n    if (right.type === \"array\") {\n      for (const b of right.data)\n        if (isEqual(left, fromJS(b)))\n          return TRUE_VALUE;\n      return FALSE_VALUE;\n    }\n    return right.type === \"stream\" ? (async () => {\n      for await (const b of right)\n        if (isEqual(left, b))\n          return TRUE_VALUE;\n      return FALSE_VALUE;\n    })() : NULL_VALUE;\n  },\n  match: function(left, right) {\n    const tokens = gatherText(left, (part) => matchTokenize(part)), patterns = gatherText(right, (part) => matchAnalyzePattern(part)), process = (tokens2, patterns2) => patterns2.success && matchText(tokens2.parts, patterns2.parts) ? TRUE_VALUE : FALSE_VALUE;\n    return \"then\" in tokens || \"then\" in patterns ? (async () => process(await tokens, await patterns))() : process(tokens, patterns);\n  },\n  \"+\": function(left, right) {\n    return left.type === \"datetime\" && right.type === \"number\" ? fromDateTime(left.data.add(right.data)) : left.type === \"number\" && right.type === \"number\" ? fromNumber(left.data + right.data) : left.type === \"string\" && right.type === \"string\" ? fromString(left.data + right.data) : left.type === \"object\" && right.type === \"object\" ? fromJS({ ...left.data, ...right.data }) : left.type === \"array\" && right.type === \"array\" ? fromJS(left.data.concat(right.data)) : left.isArray() && right.isArray() ? new StreamValue(async function* () {\n      for await (const val of left)\n        yield val;\n      for await (const val of right)\n        yield val;\n    }) : NULL_VALUE;\n  },\n  \"-\": function(left, right) {\n    return left.type === \"datetime\" && right.type === \"number\" ? fromDateTime(left.data.add(-right.data)) : left.type === \"datetime\" && right.type === \"datetime\" ? fromNumber(left.data.difference(right.data)) : left.type === \"number\" && right.type === \"number\" ? fromNumber(left.data - right.data) : NULL_VALUE;\n  },\n  \"*\": numericOperator((a, b) => a * b),\n  \"/\": numericOperator((a, b) => a / b),\n  \"%\": numericOperator((a, b) => a % b),\n  \"**\": numericOperator((a, b) => Math.pow(a, b))\n};\nfunction numericOperator(impl) {\n  return function(left, right) {\n    if (left.type === \"number\" && right.type === \"number\") {\n      const result = impl(left.data, right.data);\n      return fromNumber(result);\n    }\n    return NULL_VALUE;\n  };\n}\nlet Scope$1 = class Scope {\n  params;\n  source;\n  value;\n  parent;\n  context;\n  isHidden = !1;\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(params, source, value, context, parent) {\n    this.params = params, this.source = source, this.value = value, this.context = context, this.parent = parent;\n  }\n  createNested(value) {\n    return this.isHidden ? new Scope(this.params, this.source, value, this.context, this.parent) : new Scope(this.params, this.source, value, this.context, this);\n  }\n  createHidden(value) {\n    const result = this.createNested(value);\n    return result.isHidden = !0, result;\n  }\n};\nfunction evaluate(node, scope) {\n  return executeAsync(node, scope);\n}\nfunction executeSync(node, scope) {\n  return EXECUTORS[node.type].executeSync(node, scope);\n}\nfunction executeAsync(node, scope) {\n  return EXECUTORS[node.type].executeAsync(node, scope);\n}\nfunction asyncOnlyExecutor(executeAsync2) {\n  return {\n    executeSync() {\n      throw new Error(\"executeSync not supported\");\n    },\n    executeAsync: executeAsync2\n  };\n}\nfunction constantExecutor(fn) {\n  return {\n    executeSync(node, scope) {\n      const value = fn(node, scope);\n      if (value.type === \"stream\") throw new Error(\"Stream encountered in evaluateSync\");\n      return value;\n    },\n    async executeAsync(node, scope) {\n      return fn(node, scope);\n    }\n  };\n}\nfunction mappedExecutor(map2, reduce) {\n  return {\n    executeSync(node, scope) {\n      const values = map2(node).map((node2) => executeSync(node2, scope)), value = reduce(node, ...values);\n      if (value.type === \"stream\")\n        throw new Error(\"Stream/iterator not supported in synchronous mode\");\n      return value;\n    },\n    async executeAsync(node, scope) {\n      const nodes = map2(node), values = await Promise.all(\n        nodes.map((node2) => executeAsync(node2, scope).then((value) => value.asStatic()))\n      );\n      return reduce(node, ...values);\n    }\n  };\n}\nconst STOP_ITERATOR = Symbol();\nfunction arrayReducerExecutor(map2, init, reduce, wrap) {\n  return {\n    executeSync(node, scope) {\n      const { array: arrayNode, args: argNodes = [] } = map2(node), arr = executeSync(arrayNode, scope);\n      if (arr.type !== \"array\") return NULL_VALUE;\n      const args = argNodes.map((node2) => executeSync(node2, scope));\n      let state = init(node, ...args);\n      for (const item of arr.data) {\n        const result = reduce(node, state, item, ...args);\n        if (result === STOP_ITERATOR) return NULL_VALUE;\n        state = result;\n      }\n      return wrap(state);\n    },\n    async executeAsync(node, scope) {\n      const { array: arrayNode, args: argNodes = [] } = map2(node), arr = await executeAsync(arrayNode, scope);\n      if (arr.type !== \"array\" && arr.type !== \"stream\") return NULL_VALUE;\n      const args = await Promise.all(\n        argNodes.map((node2) => executeAsync(node2, scope).then((v) => v.asStatic()))\n      );\n      let state = init(node, ...args);\n      if (arr.type === \"stream\")\n        for await (const item of arr) {\n          const result = reduce(node, state, await item.get(), ...args);\n          if (result === STOP_ITERATOR) return NULL_VALUE;\n          state = result;\n        }\n      else\n        for (const item of arr.data) {\n          const result = reduce(node, state, item, ...args);\n          if (result === STOP_ITERATOR) return NULL_VALUE;\n          state = result;\n        }\n      return wrap(state);\n    }\n  };\n}\nfunction arrayExecutor(map2, reduce, { hidden = !1 } = {}) {\n  return {\n    executeSync(node, scope) {\n      const mapping = map2(node), arr = executeSync(mapping.array, scope);\n      if (arr.type !== \"array\") return NULL_VALUE;\n      const result = [];\n      for (const item of arr.data) {\n        let inner;\n        if (mapping.inner) {\n          const newScope = hidden ? scope.createHidden(fromJS(item)) : scope.createNested(fromJS(item));\n          inner = executeSync(mapping.inner, newScope).data;\n        }\n        for (const entry of reduce(node, item, inner, mapping.state))\n          result.push(entry);\n      }\n      return fromArray(result);\n    },\n    async executeAsync(node, scope) {\n      const mapping = map2(node), arr = await executeAsync(mapping.array, scope);\n      return arr.isArray() ? new StreamValue(async function* () {\n        for await (const item of arr) {\n          let inner;\n          if (mapping.inner) {\n            const newScope = hidden ? scope.createHidden(item) : scope.createNested(item);\n            inner = await (await executeAsync(mapping.inner, newScope)).get();\n          }\n          for (const entry of reduce(node, await item.get(), inner, mapping.state))\n            yield fromJS(entry);\n        }\n      }) : NULL_VALUE;\n    }\n  };\n}\nconst EXECUTORS = {\n  This: constantExecutor((_, scope) => scope.value),\n  SelectorNested: constantExecutor(() => {\n    throw new Error(\"Unexpected node type: SelectorNested\");\n  }),\n  SelectorFuncCall: constantExecutor(() => {\n    throw new Error(\"Unexpected node type: SelectorFuncCall\");\n  }),\n  Everything: constantExecutor((_, scope) => scope.source),\n  Parameter: constantExecutor(({ name }, scope) => fromJS(scope.params[name])),\n  Context: constantExecutor(({ key }, scope) => {\n    if (key === \"before\" || key === \"after\")\n      return scope.context[key] || NULL_VALUE;\n    throw new Error(`unknown context key: ${key}`);\n  }),\n  Parent: constantExecutor(({ n }, scope) => {\n    let current = scope;\n    for (let i = 0; i < n; i++) {\n      if (!current.parent)\n        return NULL_VALUE;\n      current = current.parent;\n    }\n    return current.value;\n  }),\n  OpCall: {\n    async executeAsync({ op, left, right }, scope) {\n      const func = operators[op];\n      if (!func)\n        throw new Error(`Unknown operator: ${op}`);\n      const leftValue = await executeAsync(left, scope), rightValue = await executeAsync(right, scope);\n      return func(leftValue, rightValue);\n    },\n    executeSync({ op, left, right }, scope) {\n      const func = operators[op];\n      if (!func)\n        throw new Error(`Unknown operator: ${op}`);\n      const leftValue = executeSync(left, scope), rightValue = executeSync(right, scope), result = func(leftValue, rightValue);\n      if (\"then\" in result || result.type === \"stream\")\n        throw new Error(`Operator ${op} not possible in evaluteSync`);\n      return result;\n    }\n  },\n  Select: {\n    executeSync({ alternatives, fallback }, scope) {\n      for (const alt of alternatives) {\n        const altCond = executeSync(alt.condition, scope);\n        if (altCond.type === \"boolean\" && altCond.data === !0)\n          return executeSync(alt.value, scope);\n      }\n      return fallback ? executeSync(fallback, scope) : NULL_VALUE;\n    },\n    async executeAsync({ alternatives, fallback }, scope) {\n      for (const alt of alternatives) {\n        const altCond = await executeAsync(alt.condition, scope);\n        if (altCond.type === \"boolean\" && altCond.data === !0)\n          return executeAsync(alt.value, scope);\n      }\n      return fallback ? executeAsync(fallback, scope) : NULL_VALUE;\n    }\n  },\n  InRange: mappedExecutor(\n    ({ base, left, right }) => [base, left, right],\n    ({ isInclusive }, value, leftValue, rightValue) => {\n      const leftCmp = partialCompare(value.data, leftValue.data);\n      if (leftCmp === null)\n        return NULL_VALUE;\n      const rightCmp = partialCompare(value.data, rightValue.data);\n      return rightCmp === null ? NULL_VALUE : isInclusive ? leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE : leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE;\n    }\n  ),\n  Filter: arrayExecutor(\n    ({ base, expr }) => ({ array: base, inner: expr }),\n    function* (_, elem, inner) {\n      inner === !0 && (yield elem);\n    }\n  ),\n  Projection: {\n    executeSync({ base, expr }, scope) {\n      const baseValue = executeSync(base, scope);\n      if (baseValue.type !== \"object\")\n        return NULL_VALUE;\n      const newScope = scope.createNested(baseValue);\n      return executeSync(expr, newScope);\n    },\n    async executeAsync({ base, expr }, scope) {\n      const baseValue = await executeAsync(base, scope);\n      if (baseValue.type !== \"object\")\n        return NULL_VALUE;\n      const newScope = scope.createNested(baseValue);\n      return executeAsync(expr, newScope);\n    }\n  },\n  FuncCall: {\n    executeAsync({ func, args }, scope) {\n      return func.executeAsync(args, scope);\n    },\n    executeSync({ func, args }, scope) {\n      return func.executeSync(args, scope);\n    }\n  },\n  PipeFuncCall: {\n    async executeAsync({ func, base, args }, scope) {\n      const baseValue = await executeAsync(base, scope);\n      return baseValue.type !== \"stream\" && baseValue.type !== \"array\" ? NULL_VALUE : func.executeAsync({ base: baseValue, args }, scope);\n    },\n    executeSync({ func, base, args }, scope) {\n      const baseValue = executeSync(base, scope);\n      return baseValue.type !== \"array\" ? NULL_VALUE : func.executeSync({ base: baseValue, args }, scope);\n    }\n  },\n  AccessAttribute: mappedExecutor(\n    ({ base }) => [base || { type: \"This\" }],\n    ({ name }, value) => value.type === \"object\" && value.data.hasOwnProperty(name) ? fromJS(value.data[name]) : NULL_VALUE\n  ),\n  AccessElement: mappedExecutor(\n    ({ base }) => [base],\n    ({ index }, baseValue) => {\n      if (baseValue.type !== \"array\") return NULL_VALUE;\n      const data = baseValue.data, finalIndex = index < 0 ? index + data.length : index;\n      return fromJS(data[finalIndex]);\n    }\n  ),\n  Slice: mappedExecutor(\n    ({ base }) => [base],\n    ({ left, right, isInclusive }, baseValue) => {\n      if (baseValue.type !== \"array\")\n        return NULL_VALUE;\n      const array2 = baseValue.data;\n      let leftIdx = left, rightIdx = right;\n      return leftIdx < 0 && (leftIdx = array2.length + leftIdx), rightIdx < 0 && (rightIdx = array2.length + rightIdx), isInclusive && rightIdx++, leftIdx < 0 && (leftIdx = 0), rightIdx < 0 && (rightIdx = 0), fromArray(array2.slice(leftIdx, rightIdx));\n    }\n  ),\n  Deref: {\n    executeSync({ base }, scope) {\n      const value = executeSync(base, scope);\n      if (value.type !== \"object\")\n        return NULL_VALUE;\n      const id = value.data._ref;\n      if (typeof id != \"string\")\n        return NULL_VALUE;\n      if (scope.context.dereference) {\n        const value2 = scope.context.dereference({ _ref: id });\n        if (value2 && typeof value2 == \"object\" && \"then\" in value2)\n          throw new Error(\"Dereference returned promise in synchronous mode\");\n        return fromJS(value2);\n      }\n      if (scope.source.type !== \"array\")\n        return NULL_VALUE;\n      for (const doc of scope.source.data)\n        if (doc && typeof doc == \"object\" && \"_id\" in doc && id === doc._id)\n          return fromJS(doc);\n      return NULL_VALUE;\n    },\n    async executeAsync({ base }, scope) {\n      const value = await executeAsync(base, scope);\n      if (!scope.source.isArray() || value.type !== \"object\")\n        return NULL_VALUE;\n      const id = value.data._ref;\n      if (typeof id != \"string\")\n        return NULL_VALUE;\n      if (scope.context.dereference)\n        return fromJS(await scope.context.dereference({ _ref: id }));\n      for await (const doc of scope.source)\n        if (doc.type === \"object\" && id === doc.data._id)\n          return doc;\n      return NULL_VALUE;\n    }\n  },\n  Value: constantExecutor(({ value }) => fromJS(value)),\n  Group: {\n    executeSync({ base }, scope) {\n      return executeSync(base, scope);\n    },\n    executeAsync({ base }, scope) {\n      return executeAsync(base, scope);\n    }\n  },\n  Object: {\n    executeSync({ attributes }, scope) {\n      const result = {};\n      for (const attr of attributes) {\n        const attrType = attr.type;\n        switch (attr.type) {\n          case \"ObjectAttributeValue\": {\n            const value = executeSync(attr.value, scope);\n            result[attr.name] = value.data;\n            break;\n          }\n          case \"ObjectConditionalSplat\": {\n            const cond = executeSync(attr.condition, scope);\n            if (cond.type !== \"boolean\" || cond.data === !1)\n              continue;\n            const value = executeSync(attr.value, scope);\n            value.type === \"object\" && Object.assign(result, value.data);\n            break;\n          }\n          case \"ObjectSplat\": {\n            const value = executeSync(attr.value, scope);\n            value.type === \"object\" && Object.assign(result, value.data);\n            break;\n          }\n          default:\n            throw new Error(`Unknown node type: ${attrType}`);\n        }\n      }\n      return fromJS(result);\n    },\n    async executeAsync({ attributes }, scope) {\n      const result = {};\n      for (const attr of attributes) {\n        const attrType = attr.type;\n        switch (attr.type) {\n          case \"ObjectAttributeValue\": {\n            const value = await executeAsync(attr.value, scope);\n            result[attr.name] = await value.get();\n            break;\n          }\n          case \"ObjectConditionalSplat\": {\n            const cond = await executeAsync(attr.condition, scope);\n            if (cond.type !== \"boolean\" || cond.data === !1)\n              continue;\n            const value = await executeAsync(attr.value, scope);\n            value.type === \"object\" && Object.assign(result, value.data);\n            break;\n          }\n          case \"ObjectSplat\": {\n            const value = await executeAsync(attr.value, scope);\n            value.type === \"object\" && Object.assign(result, value.data);\n            break;\n          }\n          default:\n            throw new Error(`Unknown node type: ${attrType}`);\n        }\n      }\n      return fromJS(result);\n    }\n  },\n  Array: {\n    executeSync({ elements }, scope) {\n      const result = [];\n      for (const element of elements) {\n        const value = executeSync(element.value, scope);\n        if (element.isSplat) {\n          if (value.type === \"array\")\n            for (const v of value.data)\n              result.push(v);\n        } else\n          result.push(value.data);\n      }\n      return fromArray(result);\n    },\n    async executeAsync({ elements }, scope) {\n      return new StreamValue(async function* () {\n        for (const element of elements) {\n          const value = await executeAsync(element.value, scope);\n          if (element.isSplat) {\n            if (value.isArray())\n              for await (const v of value)\n                yield v;\n          } else\n            yield value;\n        }\n      });\n    }\n  },\n  Tuple: constantExecutor(() => {\n    throw new Error(\"tuples can not be evaluated\");\n  }),\n  Or: mappedExecutor(\n    ({ left, right }) => [left, right],\n    (_, leftValue, rightValue) => leftValue.type === \"boolean\" && leftValue.data === !0 || rightValue.type === \"boolean\" && rightValue.data === !0 ? TRUE_VALUE : leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\" ? NULL_VALUE : FALSE_VALUE\n  ),\n  And: mappedExecutor(\n    ({ left, right }) => [left, right],\n    (_, leftValue, rightValue) => leftValue.type === \"boolean\" && leftValue.data === !1 || rightValue.type === \"boolean\" && rightValue.data === !1 ? FALSE_VALUE : leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\" ? NULL_VALUE : TRUE_VALUE\n  ),\n  Not: mappedExecutor(\n    ({ base }) => [base],\n    (_, value) => value.type !== \"boolean\" ? NULL_VALUE : value.data ? FALSE_VALUE : TRUE_VALUE\n  ),\n  Neg: mappedExecutor(\n    ({ base }) => [base],\n    (_, value) => value.type !== \"number\" ? NULL_VALUE : fromNumber(-value.data)\n  ),\n  Pos: mappedExecutor(\n    ({ base }) => [base],\n    (_, value) => value.type !== \"number\" ? NULL_VALUE : fromNumber(value.data)\n  ),\n  Asc: constantExecutor(() => NULL_VALUE),\n  Desc: constantExecutor(() => NULL_VALUE),\n  ArrayCoerce: {\n    executeSync({ base }, scope) {\n      const value = executeSync(base, scope);\n      return value.isArray() ? value : NULL_VALUE;\n    },\n    async executeAsync({ base }, scope) {\n      const value = await executeAsync(base, scope);\n      return value.isArray() ? value : NULL_VALUE;\n    }\n  },\n  Map: arrayExecutor(\n    ({ base, expr }) => ({ array: base, inner: expr }),\n    function* (_, _item, inner) {\n      yield inner;\n    },\n    { hidden: !0 }\n  ),\n  FlatMap: arrayExecutor(\n    ({ base, expr }) => ({ array: base, inner: expr }),\n    function* (_, _item, inner) {\n      if (Array.isArray(inner))\n        for (const innerInner of inner)\n          yield innerInner;\n      else\n        yield inner;\n    },\n    { hidden: !0 }\n  )\n};\nfunction evaluateQuery(tree, options = {}) {\n  return executeAsync(tree, scopeFromOptions(options));\n}\nfunction evaluateQuerySync(tree, options = {}) {\n  return executeSync(tree, scopeFromOptions(options));\n}\nfunction scopeFromOptions(options) {\n  const root = fromJS(options.root), dataset = fromJS(options.dataset), params = { ...options.params };\n  return new Scope$1(\n    params,\n    dataset,\n    root,\n    {\n      timestamp: options.timestamp || /* @__PURE__ */ new Date(),\n      identity: options.identity === void 0 ? \"me\" : options.identity,\n      sanity: options.sanity,\n      after: options.after ? fromJS(options.after) : null,\n      before: options.before ? fromJS(options.before) : null,\n      dereference: options.dereference\n    },\n    null\n  );\n}\nfunction canConstantEvaluate(node) {\n  switch (node.type) {\n    case \"Group\":\n      return canConstantEvaluate(node.base);\n    case \"Value\":\n    case \"Parameter\":\n      return !0;\n    case \"Pos\":\n    case \"Neg\":\n      return canConstantEvaluate(node.base);\n    case \"OpCall\":\n      switch (node.op) {\n        case \"+\":\n        case \"-\":\n        case \"*\":\n        case \"/\":\n        case \"%\":\n        case \"**\":\n          return canConstantEvaluate(node.left) && canConstantEvaluate(node.right);\n        default:\n          return !1;\n      }\n    default:\n      return !1;\n  }\n}\nconst DUMMY_SCOPE = new Scope$1(\n  {},\n  NULL_VALUE,\n  NULL_VALUE,\n  { timestamp: /* @__PURE__ */ new Date(0), identity: \"me\", before: null, after: null },\n  null\n);\nfunction tryConstantEvaluate(node) {\n  return canConstantEvaluate(node) ? constantEvaluate(node) : null;\n}\nfunction constantEvaluate(node) {\n  return executeSync(node, DUMMY_SCOPE);\n}\nfunction isSelectorNode(node) {\n  return [\n    \"AccessAttribute\",\n    \"SelectorFuncCall\",\n    \"Group\",\n    \"Tuple\",\n    \"ArrayCoerce\",\n    \"Filter\",\n    \"SelectorNested\"\n  ].includes(node.type);\n}\nfunction isSelectorNested(node) {\n  return [\"AccessAttribute\", \"ArrayCoerce\", \"Filter\", \"Group\", \"Tuple\", \"SelectorNested\"].includes(\n    node.type\n  );\n}\nconst array = {};\narray.join = mappedExecutor(\n  (args) => args,\n  (_, arr, sep) => {\n    if (arr.type !== \"array\" || sep.type !== \"string\")\n      return NULL_VALUE;\n    let buf = \"\", needSep = !1;\n    for (const elem of arr.data) {\n      switch (needSep && (buf += sep.data), getType(elem)) {\n        case \"number\":\n        case \"string\":\n        case \"boolean\":\n        case \"datetime\":\n          buf += `${elem}`;\n          break;\n        default:\n          return NULL_VALUE;\n      }\n      needSep = !0;\n    }\n    return fromString(buf);\n  }\n);\narray.join.arity = 2;\narray.compact = arrayExecutor(\n  ([array2]) => ({ array: array2 }),\n  function* (_, item) {\n    item !== null && (yield item);\n  }\n);\narray.compact.arity = 1;\narray.unique = arrayExecutor(\n  (args) => ({ array: args[0], state: /* @__PURE__ */ new Set() }),\n  function* (_node, iter, _inner, added) {\n    switch (getType(iter)) {\n      case \"number\":\n      case \"string\":\n      case \"boolean\":\n      case \"datetime\":\n        added.has(iter) || (added.add(iter), yield iter);\n        break;\n      default:\n        yield iter;\n    }\n  }\n);\narray.unique.arity = 1;\narray.intersects = mappedExecutor(\n  (args) => args,\n  (_, arr1, arr2) => {\n    if (arr1.type !== \"array\" || arr2.type !== \"array\")\n      return NULL_VALUE;\n    for (const v1 of arr1.data)\n      for (const v2 of arr2.data)\n        if (isEqual(fromJS(v1), fromJS(v2)))\n          return TRUE_VALUE;\n    return FALSE_VALUE;\n  }\n);\narray.intersects.arity = 2;\nconst dateTime = {};\ndateTime.now = constantExecutor(\n  (_, scope) => fromDateTime(new DateTime(scope.context.timestamp))\n);\ndateTime.now.arity = 0;\nasync function valueAtPath(arg, keyPath) {\n  function tryAccessor(arg2, accessor) {\n    try {\n      return arg2[accessor];\n    } catch {\n      return;\n    }\n  }\n  let current = await arg.get();\n  for (const part of keyPath)\n    if (current = tryAccessor(current, part), !current) break;\n  return current;\n}\nfunction startsWith(keyPath, prefix) {\n  return prefix.every((item, index) => keyPath[index] === item);\n}\nasync function* diffKeyPaths(before, after) {\n  const currPaths = [[]];\n  for (; currPaths.length > 0; ) {\n    const currPath = currPaths.shift() || [], b = fromJS(await valueAtPath(before, currPath)), a = fromJS(await valueAtPath(after, currPath));\n    if (a.type !== b.type)\n      yield currPath;\n    else if (a.type === \"string\" && b.type === \"string\" || a.type === \"boolean\" && b.type === \"boolean\" || a.type === \"null\" && b.type === \"null\" || a.type === \"number\" && b.type === \"number\")\n      a.data !== b.data && (yield currPath);\n    else if (a.type === \"datetime\" && b.type === \"datetime\")\n      a.data.equals(b.data) || (yield currPath);\n    else if (a.type === \"object\" && b.type === \"object\") {\n      if (!deepEqual(a.data, b.data)) {\n        const aKeys = Object.keys(a.data), bKeys = Object.keys(b.data);\n        new Set(aKeys.concat(bKeys)).forEach((key) => {\n          currPaths.push([...currPath, key]);\n        });\n      }\n    } else if (a.type === \"array\" && b.type === \"array\") {\n      if (a.data.length !== b.data.length)\n        yield currPath;\n      else if (!deepEqual(a.data, b.data))\n        for (let i = 0; i < b.data.length; i++)\n          currPaths.push([...currPath, i]);\n    } else if (a.type === \"stream\" && b.type === \"stream\") {\n      const arrayA = await a.get(), arrayB = await b.get();\n      if (arrayA.length !== arrayB.length)\n        yield currPath;\n      else if (!deepEqual(arrayA, arrayB))\n        for (let i = 0; i < arrayB.length; i++)\n          currPaths.push([...currPath, i]);\n    }\n  }\n}\nasync function evaluateSelector(node, value, scope) {\n  switch (node.type) {\n    case \"Group\":\n      return await evaluateSelector(node.base, value, scope);\n    case \"Tuple\":\n      const tuplePaths = [];\n      for (const member of node.members) {\n        const memberPaths = await evaluateSelector(member, value, scope);\n        tuplePaths.push(...memberPaths);\n      }\n      return tuplePaths;\n    case \"AccessAttribute\":\n      return node.base ? (await evaluateSelector(node.base, value, scope)).map((path) => [...path, node.name]) : [[node.name]];\n    case \"ArrayCoerce\": {\n      const paths = await evaluateSelector(node.base, value, scope), arrayPaths = [];\n      for (const keyPath of paths) {\n        const innerValue = await valueAtPath(value, keyPath);\n        if (Array.isArray(innerValue))\n          for (let i = 0; i < innerValue.length; i++)\n            arrayPaths.push([...keyPath, i]);\n      }\n      return arrayPaths;\n    }\n    case \"Filter\": {\n      const paths = await evaluateSelector(node.base, value, scope), filter = {\n        ...node,\n        base: { type: \"This\" }\n      }, arrayPaths = [];\n      for (const keyPath of paths) {\n        const innerValue = await valueAtPath(value, keyPath);\n        if (Array.isArray(innerValue))\n          for (let i = 0; i < innerValue.length; i++) {\n            const item = innerValue[i], nestedScope = scope.createNested(fromJS([item]));\n            (await (await evaluate(filter, nestedScope)).get()).length > 0 && arrayPaths.push([...keyPath, i]);\n          }\n      }\n      return arrayPaths;\n    }\n    case \"SelectorFuncCall\":\n      return anywhere(node.arg, scope.createHidden(value));\n    case \"SelectorNested\": {\n      const { base, nested: expr } = node, paths = await evaluateSelector(base, value, scope), nestedPaths = [];\n      for (const keyPath of paths) {\n        const innerValue = await valueAtPath(value, keyPath);\n        switch (expr.type) {\n          case \"AccessAttribute\":\n          case \"ArrayCoerce\":\n          case \"Filter\":\n            const accessPaths = await evaluateSelector(expr, fromJS(innerValue), scope);\n            for (let i = 0; i < accessPaths.length; i++)\n              nestedPaths.push([...keyPath, ...accessPaths[i]]);\n            break;\n          case \"Group\":\n            const innerResult = await evaluateSelector(expr.base, fromJS(innerValue), scope);\n            for (const innerKeyPath of innerResult)\n              nestedPaths.push([...keyPath, ...innerKeyPath]);\n            break;\n          case \"Tuple\":\n            for (const inner of expr.members) {\n              const innerResult2 = await evaluateSelector(inner, fromJS(innerValue), scope);\n              for (const innerKeyPath of innerResult2)\n                nestedPaths.push([...keyPath, ...innerKeyPath]);\n            }\n        }\n      }\n      return nestedPaths;\n    }\n  }\n}\nasync function anywhere(expr, scope, base = []) {\n  const value = scope.value, pathList = [];\n  if (value.isArray()) {\n    const arr = await value.get();\n    for (let i = 0; i < arr.length; i++) {\n      const subPaths = await anywhere(expr, scope.createHidden(fromJS(arr[i])), [...base, i]);\n      pathList.push(...subPaths);\n    }\n  } else if (value.type === \"object\") {\n    const result = await evaluate(expr, scope);\n    result.type === \"boolean\" && result.data === !0 && pathList.push(base);\n    for (const key of Object.keys(value.data)) {\n      const subPaths = await anywhere(expr, scope.createHidden(fromJS(value.data[key])), [\n        ...base,\n        key\n      ]);\n      pathList.push(...subPaths);\n    }\n  }\n  return pathList;\n}\nasync function changedAny(before, after, selector, scope) {\n  const beforeSelectorScope = scope.createHidden(before), beforePaths = await evaluateSelector(\n    selector,\n    beforeSelectorScope.value,\n    beforeSelectorScope\n  ), afterSelectorScope = scope.createHidden(after), afterPaths = await evaluateSelector(selector, afterSelectorScope.value, afterSelectorScope);\n  if (beforePaths.length !== afterPaths.length)\n    return TRUE_VALUE;\n  for (const path of beforePaths) {\n    for (let i = 0; i < path.length; i++)\n      if (typeof path[i] == \"number\") {\n        const slice = path.slice(0, i), beforeArr = await valueAtPath(before, slice), afterArr = await valueAtPath(after, slice);\n        if (!Array.isArray(beforeArr) || !Array.isArray(afterArr) || beforeArr.length !== afterArr.length)\n          return TRUE_VALUE;\n      }\n    const beforeValue = await valueAtPath(before, path), afterValue = await valueAtPath(after, path);\n    if (!deepEqual(beforeValue, afterValue))\n      return TRUE_VALUE;\n  }\n  return FALSE_VALUE;\n}\nasync function changedOnly(before, after, selector, scope) {\n  const beforeSelectorScope = scope.createHidden(before), selectedPaths = await evaluateSelector(\n    selector,\n    beforeSelectorScope.value,\n    beforeSelectorScope\n  );\n  for await (const diffPath of diffKeyPaths(before, after)) {\n    let found = !1;\n    for (const selectedPath of selectedPaths)\n      if (startsWith(diffPath, selectedPath)) {\n        found = !0;\n        break;\n      }\n    if (!found)\n      return FALSE_VALUE;\n  }\n  return TRUE_VALUE;\n}\nconst diff = {};\ndiff.changedAny = asyncOnlyExecutor(async (args, scope) => {\n  const lhs = args[0], rhs = args[1], selector = args[2];\n  if (!isSelectorNode(selector)) throw new Error(\"changedAny third argument must be a selector\");\n  const before = await executeAsync(lhs, scope), after = await executeAsync(rhs, scope);\n  return changedAny(before, after, selector, scope);\n});\ndiff.changedAny.arity = 3;\ndiff.changedOnly = asyncOnlyExecutor(async (args, scope) => {\n  const lhs = args[0], rhs = args[1], selector = args[2];\n  if (!isSelectorNode(selector)) throw new Error(\"changedOnly third argument must be a selector\");\n  const before = await executeAsync(lhs, scope), after = await executeAsync(rhs, scope);\n  return changedOnly(before, after, selector, scope);\n});\ndiff.changedOnly.arity = 3;\nconst delta = {};\ndelta.operation = constantExecutor((_, scope) => {\n  const hasBefore = scope.context.before !== null, hasAfter = scope.context.after !== null;\n  return hasBefore && hasAfter ? fromString(\"update\") : hasAfter ? fromString(\"create\") : hasBefore ? fromString(\"delete\") : NULL_VALUE;\n});\ndelta.changedAny = asyncOnlyExecutor(async (args, scope) => {\n  const before = scope.context.before || NULL_VALUE, after = scope.context.after || NULL_VALUE, selector = args[0];\n  if (!isSelectorNode(selector)) throw new Error(\"changedAny first argument must be a selector\");\n  return changedAny(before, after, selector, scope);\n});\ndelta.changedAny.arity = 1;\ndelta.changedAny.mode = \"delta\";\ndelta.changedOnly = asyncOnlyExecutor(async (args, scope) => {\n  const before = scope.context.before || NULL_VALUE, after = scope.context.after || NULL_VALUE, selector = args[0];\n  if (!isSelectorNode(selector)) throw new Error(\"changedOnly first argument must be a selector\");\n  return changedOnly(before, after, selector, scope);\n});\ndelta.changedOnly.arity = 1;\ndelta.changedOnly.mode = \"delta\";\nconst documents = {};\ndocuments.get = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\ndocuments.incomingRefCount = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\ndocuments.incomingGlobalDocumentReferenceCount = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\nconst geo = {};\ngeo.latLng = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\ngeo.contains = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\ngeo.intersects = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\ngeo.distance = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\nconst string = {};\nstring.lower = mappedExecutor(\n  (args) => args,\n  (_, value) => value.type !== \"string\" ? NULL_VALUE : fromString(value.data.toLowerCase())\n);\nstring.lower.arity = 1;\nstring.upper = mappedExecutor(\n  (args) => args,\n  (_, value) => value.type !== \"string\" ? NULL_VALUE : fromString(value.data.toUpperCase())\n);\nstring.upper.arity = 1;\nstring.split = mappedExecutor(\n  (args) => args,\n  (_, str, sep) => str.type !== \"string\" || sep.type !== \"string\" ? NULL_VALUE : str.data.length === 0 ? fromArray([]) : sep.data.length === 0 ? fromArray(Array.from(str.data)) : fromArray(str.data.split(sep.data))\n);\nstring.split.arity = 2;\nstring.startsWith = mappedExecutor(\n  (args) => args,\n  (_, str, prefix) => str.type !== \"string\" || prefix.type !== \"string\" ? NULL_VALUE : str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE\n);\nstring.startsWith.arity = 2;\nconst _global = {};\n_global.anywhere = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\n_global.anywhere.arity = 1;\n_global.coalesce = {\n  async executeAsync(args, scope) {\n    for (const arg of args) {\n      const value = await executeAsync(arg, scope);\n      if (value.type !== \"null\")\n        return value;\n    }\n    return NULL_VALUE;\n  },\n  executeSync(args, scope) {\n    for (const arg of args) {\n      const value = executeSync(arg, scope);\n      if (value.type !== \"null\")\n        return value;\n    }\n    return NULL_VALUE;\n  }\n};\n_global.count = arrayReducerExecutor(\n  (args) => ({ array: args[0] }),\n  () => 0,\n  (_, count) => count + 1,\n  fromNumber\n);\n_global.count.arity = 1;\n_global.dateTime = mappedExecutor(\n  (args) => args,\n  (_, val) => val.type === \"datetime\" ? val : val.type !== \"string\" ? NULL_VALUE : DateTime.parseToValue(val.data)\n);\n_global.dateTime.arity = 1;\n_global.defined = mappedExecutor(\n  (args) => args,\n  (_, inner) => inner.type === \"null\" ? FALSE_VALUE : TRUE_VALUE\n);\n_global.defined.arity = 1;\n_global.identity = constantExecutor((_args, scope) => fromString(scope.context.identity));\n_global.identity.arity = 0;\n_global.length = mappedExecutor(\n  (args) => args,\n  (_, inner) => inner.type === \"string\" ? fromNumber(countUTF8(inner.data)) : inner.type === \"array\" ? fromNumber(inner.data.length) : NULL_VALUE\n);\n_global.length.arity = 1;\n_global.path = mappedExecutor(\n  (args) => args,\n  (_, inner) => inner.type !== \"string\" ? NULL_VALUE : fromPath(new Path(inner.data))\n);\n_global.path.arity = 1;\n_global.string = mappedExecutor(\n  (args) => args,\n  (_, value) => {\n    switch (value.type) {\n      case \"number\":\n      case \"string\":\n      case \"boolean\":\n      case \"datetime\":\n        return fromString(`${value.data}`);\n      default:\n        return NULL_VALUE;\n    }\n  }\n);\n_global.string.arity = 1;\n_global.references = mappedExecutor(\n  (args) => [{ type: \"This\" }, ...args],\n  (_, scopeValue, ...args) => {\n    const pathSet = /* @__PURE__ */ new Set();\n    for (const path of args)\n      if (path.type === \"string\")\n        pathSet.add(path.data);\n      else if (path.type === \"array\")\n        for (const elem of path.data)\n          typeof elem == \"string\" && pathSet.add(elem);\n    return pathSet.size === 0 ? FALSE_VALUE : hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE;\n  }\n);\n_global.references.arity = (c) => c >= 1;\n_global.round = mappedExecutor(\n  (args) => args,\n  (_, value, precValue) => {\n    if (value.type !== \"number\")\n      return NULL_VALUE;\n    const num = value.data;\n    let prec = 0;\n    if (precValue) {\n      if (precValue.type !== \"number\" || precValue.data < 0 || !Number.isInteger(precValue.data))\n        return NULL_VALUE;\n      prec = precValue.data;\n    }\n    return prec === 0 ? num < 0 ? fromNumber(-Math.round(-num)) : fromNumber(Math.round(num)) : fromNumber(Number(num.toFixed(prec)));\n  }\n);\n_global.round.arity = (count) => count >= 1 && count <= 2;\n_global.now = constantExecutor((_args, scope) => fromString(scope.context.timestamp.toISOString()));\n_global.now.arity = 0;\n_global.boost = constantExecutor(() => {\n  throw new Error(\"unexpected boost call\");\n});\n_global.boost.arity = 2;\n_global.lower = string.lower;\n_global.upper = string.upper;\nfunction countUTF8(str) {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    code >= 55296 && code <= 56319 || count++;\n  }\n  return count;\n}\nfunction hasReference(value, pathSet) {\n  switch (getType(value)) {\n    case \"array\":\n      for (const v of value)\n        if (hasReference(v, pathSet))\n          return !0;\n      break;\n    case \"object\":\n      if (value._ref)\n        return pathSet.has(value._ref);\n      for (const v of Object.values(value))\n        if (hasReference(v, pathSet))\n          return !0;\n      break;\n  }\n  return !1;\n}\nconst math = {};\nmath.min = arrayReducerExecutor(\n  (args) => ({ array: args[0] }),\n  () => {\n  },\n  (_, n, item) => item === null ? n : typeof item != \"number\" ? STOP_ITERATOR : n === void 0 || item < n ? item : n,\n  (n) => n === void 0 ? NULL_VALUE : fromNumber(n)\n);\nmath.min.arity = 1;\nmath.max = arrayReducerExecutor(\n  (args) => ({ array: args[0] }),\n  () => {\n  },\n  (_, n, item) => item === null ? n : typeof item != \"number\" ? STOP_ITERATOR : n === void 0 || item > n ? item : n,\n  (n) => n === void 0 ? NULL_VALUE : fromNumber(n)\n);\nmath.max.arity = 1;\nmath.sum = arrayReducerExecutor(\n  (args) => ({ array: args[0] }),\n  () => 0,\n  (_, n, item) => item === null ? n : typeof item != \"number\" ? STOP_ITERATOR : n + item,\n  fromNumber\n);\nmath.sum.arity = 1;\nmath.avg = arrayReducerExecutor(\n  (args) => ({ array: args[0] }),\n  () => ({ count: 0, sum: 0 }),\n  (_, { count, sum }, item) => item === null ? { count, sum } : typeof item != \"number\" ? STOP_ITERATOR : { count: count + 1, sum: sum + item },\n  ({ count, sum }) => count === 0 ? NULL_VALUE : fromNumber(sum / count)\n);\nmath.avg.arity = 1;\nconst media = {};\nmedia.aspect = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\nmedia.aspect.arity = 2;\nfunction portableTextContent(value) {\n  if (value.type === \"object\")\n    return blockText(value.data);\n  if (value.type === \"array\") {\n    const texts = arrayText(value.data);\n    if (texts.length > 0)\n      return texts.join(`\n\n`);\n  }\n  return null;\n}\nfunction arrayText(value, result = []) {\n  for (const block of value)\n    if (Array.isArray(block))\n      arrayText(block, result);\n    else if (typeof block == \"object\" && block) {\n      const text2 = blockText(block);\n      text2 !== null && result.push(text2);\n    }\n  return result;\n}\nfunction blockText(obj) {\n  if (typeof obj._type != \"string\") return null;\n  const children = obj.children;\n  if (!Array.isArray(children)) return null;\n  let result = \"\";\n  for (const child of children)\n    child && typeof child == \"object\" && typeof child._type == \"string\" && child._type === \"span\" && typeof child.text == \"string\" && (result += child.text);\n  return result;\n}\nconst pt = {};\npt.text = mappedExecutor(\n  (args) => args,\n  function(_, value) {\n    const text2 = portableTextContent(value);\n    return text2 === null ? NULL_VALUE : fromString(text2);\n  }\n);\npt.text.arity = 1;\nconst releases = {};\nreleases.all = arrayExecutor(\n  () => ({ array: { type: \"Everything\" } }),\n  function* (_, value) {\n    typeof value == \"object\" && value && \"_type\" in value && value._type === \"system.release\" && (yield value);\n  }\n);\nreleases.all.arity = 0;\nconst sanity = {};\nsanity.projectId = constantExecutor((_, scope) => scope.context.sanity ? fromString(scope.context.sanity.projectId) : NULL_VALUE);\nsanity.dataset = constantExecutor((_, scope) => scope.context.sanity ? fromString(scope.context.sanity.dataset) : NULL_VALUE);\nsanity.versionOf = mappedExecutor(\n  ([value]) => [value, { type: \"This\" }],\n  (_, value, val) => {\n    if (value.type !== \"string\") return NULL_VALUE;\n    const baseId = value.data;\n    if (val.type !== \"object\" || typeof val.data._id != \"string\") return NULL_VALUE;\n    if (val.data._id === baseId) return TRUE_VALUE;\n    const components = val.data._id.split(\".\");\n    return components.length >= 2 && components[0] === \"drafts\" && components.slice(1).join(\".\") === baseId || components.length >= 3 && components[0] === \"versions\" && components.slice(2).join(\".\") === baseId ? TRUE_VALUE : FALSE_VALUE;\n  }\n);\nsanity.versionOf.arity = 1;\nsanity.partOfRelease = mappedExecutor(\n  (args) => [args[0], { type: \"This\" }],\n  (_, value, val) => {\n    if (value.type !== \"string\") return NULL_VALUE;\n    const baseId = value.data;\n    if (val.type !== \"object\" || typeof val.data._id != \"string\") return NULL_VALUE;\n    const components = val.data._id.split(\".\");\n    return components.length >= 3 && components[0] === \"versions\" && components[1] === baseId ? TRUE_VALUE : FALSE_VALUE;\n  }\n);\nsanity.partOfRelease.arity = 1;\nconst text = {};\ntext.query = constantExecutor(() => {\n  throw new Error(\"not implemented\");\n});\ntext.query.arity = 1;\nconst BM25k = 1.2;\nasync function evaluateScoreAsync(node, scope) {\n  if (node.type === \"OpCall\" && node.op === \"match\")\n    return evaluateMatchScoreAsync(node.left, node.right, scope);\n  if (node.type === \"FuncCall\" && node.name === \"boost\") {\n    const innerScore = await evaluateScoreAsync(node.args[0], scope), boost = await executeAsync(node.args[1], scope);\n    return boost.type === \"number\" && innerScore > 0 ? innerScore + boost.data : 0;\n  }\n  switch (node.type) {\n    case \"Or\": {\n      const leftScore = await evaluateScoreAsync(node.left, scope), rightScore = await evaluateScoreAsync(node.right, scope);\n      return leftScore + rightScore;\n    }\n    case \"And\": {\n      const leftScore = await evaluateScoreAsync(node.left, scope), rightScore = await evaluateScoreAsync(node.right, scope);\n      return leftScore === 0 || rightScore === 0 ? 0 : leftScore + rightScore;\n    }\n    default: {\n      const res = await executeAsync(node, scope);\n      return res.type === \"boolean\" && res.data === !0 ? 1 : 0;\n    }\n  }\n}\nfunction evaluateScoreSync(node, scope) {\n  if (node.type === \"OpCall\" && node.op === \"match\")\n    return evaluateMatchScoreSync(node.left, node.right, scope);\n  if (node.type === \"FuncCall\" && node.name === \"boost\") {\n    const innerScore = evaluateScoreSync(node.args[0], scope), boost = executeSync(node.args[1], scope);\n    return boost.type === \"number\" && innerScore > 0 ? innerScore + boost.data : 0;\n  }\n  switch (node.type) {\n    case \"Or\": {\n      const leftScore = evaluateScoreSync(node.left, scope), rightScore = evaluateScoreSync(node.right, scope);\n      return leftScore + rightScore;\n    }\n    case \"And\": {\n      const leftScore = evaluateScoreSync(node.left, scope), rightScore = evaluateScoreSync(node.right, scope);\n      return leftScore === 0 || rightScore === 0 ? 0 : leftScore + rightScore;\n    }\n    default: {\n      const res = executeSync(node, scope);\n      return res.type === \"boolean\" && res.data === !0 ? 1 : 0;\n    }\n  }\n}\nfunction evaluateMatchScoreSync(left, right, scope) {\n  const text2 = executeSync(left, scope), pattern = executeSync(right, scope), result = processMatchScore(text2, pattern);\n  if (typeof result == \"number\") return result;\n  throw new Error(\"Found synchronous value in match()\");\n}\nasync function evaluateMatchScoreAsync(left, right, scope) {\n  const text2 = await executeAsync(left, scope), pattern = await executeAsync(right, scope);\n  return processMatchScore(text2, pattern);\n}\nfunction processMatchScore(text2, pattern) {\n  const tokens = gatherText(text2, (part) => matchTokenize(part)), terms = gatherText(pattern, (part) => matchPatternRegex(part)), process = (tokens2, terms2) => {\n    if (!terms2.success || tokens2.parts.length === 0 || terms2.parts.length === 0)\n      return 0;\n    let score = 0;\n    for (const re of terms2.parts) {\n      const freq = tokens2.parts.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0);\n      score += freq * (BM25k + 1) / (freq + BM25k);\n    }\n    return score;\n  };\n  return \"then\" in tokens || \"then\" in terms ? (async () => process(await tokens, await terms))() : process(tokens, terms);\n}\nfunction extractOrderArgs(args) {\n  const mappers = [], directions = [];\n  for (let mapper of args) {\n    let direction = \"asc\";\n    mapper.type === \"Desc\" ? (direction = \"desc\", mapper = mapper.base) : mapper.type === \"Asc\" && (mapper = mapper.base), mappers.push(mapper), directions.push(direction);\n  }\n  return { mappers, directions };\n}\nfunction sortArray(aux, directions) {\n  return aux.sort((aTuple, bTuple) => {\n    for (let i = 0; i < directions.length; i++) {\n      let c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\n      if (directions[i] === \"desc\" && (c = -c), c !== 0)\n        return c;\n    }\n    return aTuple[1] - bTuple[1];\n  }), aux.map((v) => v[0]);\n}\nconst pipeFunctions = {};\npipeFunctions.order = {\n  executeSync({ base, args }, scope) {\n    const { mappers, directions } = extractOrderArgs(args), aux = [];\n    let idx = 0;\n    const n = directions.length;\n    for (const value of base.data) {\n      const newScope = scope.createNested(fromJS(value)), tuple = [value, idx];\n      for (let i = 0; i < n; i++) {\n        const result = executeSync(mappers[i], newScope);\n        tuple.push(result.data);\n      }\n      aux.push(tuple), idx++;\n    }\n    return fromArray(sortArray(aux, directions));\n  },\n  async executeAsync({ base, args }, scope) {\n    const { mappers, directions } = extractOrderArgs(args), aux = [];\n    let idx = 0;\n    const n = directions.length;\n    for await (const value of base) {\n      const newScope = scope.createNested(value), tuple = [await value.get(), idx];\n      for (let i = 0; i < n; i++) {\n        const result = await executeAsync(mappers[i], newScope);\n        tuple.push(await result.get());\n      }\n      aux.push(tuple), idx++;\n    }\n    return fromArray(sortArray(aux, directions));\n  }\n};\npipeFunctions.order.arity = (count) => count >= 1;\npipeFunctions.score = {\n  async executeAsync({ base, args }, scope) {\n    const unknown = [], scored = [];\n    for await (const value of base) {\n      if (value.type !== \"object\") {\n        unknown.push(await value.get());\n        continue;\n      }\n      const newScope = scope.createNested(value);\n      let valueScore = typeof value.data._score == \"number\" ? value.data._score : 0;\n      for (const arg of args)\n        valueScore += await evaluateScoreAsync(arg, newScope);\n      const newObject = Object.assign({}, value.data, { _score: valueScore });\n      scored.push(newObject);\n    }\n    return scored.sort((a, b) => b._score - a._score), fromJS(scored);\n  },\n  executeSync({ base, args }, scope) {\n    const scored = [];\n    for (const value of base.data) {\n      if (getType(value) !== \"object\")\n        continue;\n      const valueObj = value, newScope = scope.createNested(fromJS(value));\n      let valueScore = typeof valueObj._score == \"number\" ? valueObj._score : 0;\n      for (const arg of args)\n        valueScore += evaluateScoreSync(arg, newScope);\n      const newObject = Object.assign({}, valueObj, { _score: valueScore });\n      scored.push(newObject);\n    }\n    return scored.sort((a, b) => b._score - a._score), fromArray(scored);\n  }\n};\npipeFunctions.score.arity = (count) => count >= 1;\nconst namespaces = {\n  global: _global,\n  string,\n  array,\n  pt,\n  delta,\n  diff,\n  media,\n  sanity,\n  math,\n  dateTime,\n  releases,\n  text,\n  geo,\n  documents\n};\nclass MarkProcessor {\n  _string;\n  marks;\n  index;\n  customFunctions;\n  parseOptions;\n  allowBoost = !1;\n  constructor(string2, marks, customFunctions, parseOptions) {\n    this._string = string2, this.marks = marks, this.customFunctions = customFunctions, this.index = 0, this.parseOptions = parseOptions;\n  }\n  hasMark(pos = 0) {\n    return this.index + pos < this.marks.length;\n  }\n  getMark(pos = 0) {\n    return this.marks[this.index + pos];\n  }\n  shift() {\n    this.index += 1;\n  }\n  process(visitor) {\n    const mark = this.marks[this.index];\n    this.shift();\n    const func = visitor[mark.name];\n    if (!func)\n      throw new Error(`Unknown handler: ${mark.name}`);\n    return func.call(visitor, this, mark);\n  }\n  processString() {\n    return this.shift(), this.processStringEnd();\n  }\n  processStringEnd() {\n    const prev = this.marks[this.index - 1], curr = this.marks[this.index];\n    return this.shift(), this.string.slice(prev.position, curr.position);\n  }\n  slice(len) {\n    const pos = this.marks[this.index].position;\n    return this.string.slice(pos, pos + len);\n  }\n  get string() {\n    return this._string;\n  }\n}\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/, NUM = /^\\d+/, IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\nfunction parse$1(str) {\n  let pos = 0;\n  pos = skipWS(str, pos);\n  let customFunctions = {};\n  for (; pos < str.length && str.substring(pos, pos + 2) === \"fn\"; ) {\n    let funcResult = parseFunctionDeclaration(str, pos);\n    if (funcResult.type === \"error\") return funcResult;\n    customFunctions[`${funcResult.namespace}::${funcResult.name}`] = funcResult, pos = skipWS(str, funcResult.position);\n  }\n  let result = parseExpr(str, pos, 0);\n  return result.type === \"error\" ? result : (pos = skipWS(str, result.position), pos !== str.length ? (result.failPosition && (pos = result.failPosition - 1), { type: \"error\", message: \"Unexpected end of query\", position: pos }) : (delete result.position, delete result.failPosition, result.customFunctions = customFunctions, result));\n}\nfunction parseExpr(str, pos, level) {\n  let startPos = pos, token = str[pos], marks;\n  switch (token) {\n    case \"+\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 10);\n      if (rhs.type === \"error\") return rhs;\n      marks = [{ name: \"pos\", position: startPos }].concat(rhs.marks), pos = rhs.position;\n      break;\n    }\n    case \"-\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 8);\n      if (rhs.type === \"error\") return rhs;\n      marks = [{ name: \"neg\", position: startPos }].concat(rhs.marks), pos = rhs.position;\n      break;\n    }\n    case \"(\": {\n      let result = parseGroupOrTuple(str, pos);\n      if (result.type === \"error\") return result;\n      pos = result.position, marks = result.marks;\n      break;\n    }\n    case \"!\": {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 10);\n      if (rhs.type === \"error\") return rhs;\n      marks = [{ name: \"not\", position: startPos }].concat(rhs.marks), pos = rhs.position;\n      break;\n    }\n    case \"{\": {\n      let result = parseObject(str, pos);\n      if (result.type === \"error\") return result;\n      marks = result.marks, pos = result.position;\n      break;\n    }\n    case \"[\":\n      if (marks = [{ name: \"array\", position: pos }], pos = skipWS(str, pos + 1), str[pos] !== \"]\")\n        for (; ; ) {\n          str.slice(pos, pos + 3) === \"...\" && (marks.push({ name: \"array_splat\", position: pos }), pos = skipWS(str, pos + 3));\n          let res = parseExpr(str, pos, 0);\n          if (res.type === \"error\") return res;\n          if (marks = marks.concat(res.marks), pos = res.position, pos = skipWS(str, pos), str[pos] !== \",\" || (pos = skipWS(str, pos + 1), str[pos] === \"]\")) break;\n        }\n      if (str[pos] === \"]\")\n        pos++, marks.push({ name: \"array_end\", position: pos });\n      else\n        return { type: \"error\", message: 'Expected \"]\" after array expression', position: pos };\n      break;\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos);\n      if (result.type === \"error\") return result;\n      marks = result.marks, pos = result.position;\n      break;\n    }\n    case \"^\": {\n      for (pos++, marks = []; str[pos] === \".\" && str[pos + 1] === \"^\"; )\n        marks.push({ name: \"dblparent\", position: startPos }), pos += 2;\n      marks.push({ name: \"parent\", position: startPos });\n      break;\n    }\n    case \"@\":\n      marks = [{ name: \"this\", position: startPos }], pos++;\n      break;\n    case \"*\":\n      marks = [{ name: \"everything\", position: startPos }], pos++;\n      break;\n    case \"$\": {\n      let identLen = parseRegex(str, pos + 1, IDENT);\n      identLen && (pos += 1 + identLen, marks = [\n        { name: \"param\", position: startPos },\n        { name: \"ident\", position: startPos + 1 },\n        { name: \"ident_end\", position: pos }\n      ]);\n      break;\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM);\n      if (numLen) {\n        pos += numLen;\n        let name = \"integer\";\n        if (str[pos] === \".\") {\n          let fracLen = parseRegex(str, pos + 1, NUM);\n          fracLen && (name = \"float\", pos += 1 + fracLen);\n        }\n        if (str[pos] === \"e\" || str[pos] === \"E\") {\n          name = \"sci\", pos++, (str[pos] === \"+\" || str[pos] === \"-\") && pos++;\n          let expLen = parseRegex(str, pos, NUM);\n          if (!expLen) return { type: \"error\", message: \"Exponent must be a number\", position: pos };\n          pos += expLen;\n        }\n        marks = [\n          { name, position: startPos },\n          { name: name + \"_end\", position: pos }\n        ];\n        break;\n      }\n      let identLen = parseRegex(str, pos, IDENT);\n      if (identLen) {\n        switch (pos += identLen, str[pos]) {\n          case \":\":\n          case \"(\": {\n            let result = parseFuncCall(str, startPos, pos);\n            if (result.type === \"error\") return result;\n            marks = result.marks, pos = result.position;\n            break;\n          }\n          default:\n            marks = [\n              { name: \"this_attr\", position: startPos },\n              { name: \"ident\", position: startPos },\n              { name: \"ident_end\", position: pos }\n            ];\n        }\n        break;\n      }\n    }\n  }\n  if (!marks)\n    return { type: \"error\", message: \"Expected expression\", position: pos };\n  let lhsLevel = 12, trav;\n  loop: for (; ; ) {\n    let innerPos = skipWS(str, pos);\n    if (innerPos === str.length) {\n      pos = innerPos;\n      break;\n    }\n    if (trav = parseTraversal(str, innerPos), trav.type === \"success\") {\n      for (marks.unshift({ name: \"traverse\", position: startPos }); trav.type === \"success\"; )\n        marks = marks.concat(trav.marks), pos = trav.position, trav = parseTraversal(str, skipWS(str, pos));\n      marks.push({ name: \"traversal_end\", position: pos });\n      continue;\n    }\n    switch (str[innerPos]) {\n      case \"=\": {\n        switch (str[innerPos + 1]) {\n          case \">\": {\n            if (level > 1 || lhsLevel <= 1) break loop;\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), 1);\n            if (rhs.type === \"error\") return rhs;\n            marks = marks.concat(rhs.marks), marks.unshift({ name: \"pair\", position: startPos }), pos = rhs.position, lhsLevel = 1;\n            break;\n          }\n          case \"=\": {\n            if (level > 4 || lhsLevel <= 4) break loop;\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n            if (rhs.type === \"error\") return rhs;\n            marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n            break;\n          }\n          default:\n            break loop;\n        }\n        break;\n      }\n      case \"+\": {\n        if (level > 6 || lhsLevel < 6) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), 7);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"add\", position: startPos }), pos = rhs.position, lhsLevel = 6;\n        break;\n      }\n      case \"-\": {\n        if (level > 6 || lhsLevel < 6) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), 7);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"sub\", position: startPos }), pos = rhs.position, lhsLevel = 6;\n        break;\n      }\n      case \"*\": {\n        if (str[innerPos + 1] === \"*\") {\n          if (level > 8 || lhsLevel <= 8) break loop;\n          let rhs2 = parseExpr(str, skipWS(str, innerPos + 2), 8);\n          if (rhs2.type === \"error\") return rhs2;\n          marks = marks.concat(rhs2.marks), marks.unshift({ name: \"pow\", position: startPos }), pos = rhs2.position, lhsLevel = 8;\n          break;\n        }\n        if (level > 7 || lhsLevel < 7) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"mul\", position: startPos }), pos = rhs.position, lhsLevel = 7;\n        break;\n      }\n      case \"/\": {\n        if (level > 7 || lhsLevel < 7) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"div\", position: startPos }), pos = rhs.position, lhsLevel = 7;\n        break;\n      }\n      case \"%\": {\n        if (level > 7 || lhsLevel < 7) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"mod\", position: startPos }), pos = rhs.position, lhsLevel = 7;\n        break;\n      }\n      case \"<\":\n      case \">\": {\n        if (level > 4 || lhsLevel <= 4) break loop;\n        let nextPos = innerPos + 1;\n        str[nextPos] === \"=\" && nextPos++;\n        let rhs = parseExpr(str, skipWS(str, nextPos), 5);\n        if (rhs.type === \"error\") return rhs;\n        marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: nextPos }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n        break;\n      }\n      case \"|\": {\n        if (str[innerPos + 1] === \"|\") {\n          if (level > 2 || lhsLevel < 2) break loop;\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), 3);\n          if (rhs.type === \"error\") return rhs;\n          marks = marks.concat(rhs.marks), marks.unshift({ name: \"or\", position: startPos }), pos = rhs.position, lhsLevel = 2;\n        } else {\n          if (level > 11 || lhsLevel < 11) break loop;\n          let identPos = skipWS(str, innerPos + 1), identLen = parseRegex(str, identPos, IDENT);\n          if (!identLen) return { type: \"error\", message: \"Expected identifier\", position: identPos };\n          if (pos = identPos + identLen, str[pos] === \"(\" || str[pos] === \":\") {\n            let result = parseFuncCall(str, identPos, pos);\n            if (result.type === \"error\") return result;\n            marks = marks.concat(result.marks), marks.unshift({ name: \"pipecall\", position: startPos }), pos = result.position, lhsLevel = 11;\n          }\n        }\n        break;\n      }\n      case \"&\": {\n        if (str[innerPos + 1] != \"&\" || level > 3 || lhsLevel < 3) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), 4);\n        if (rhs.type === \"error\") return rhs;\n        marks = marks.concat(rhs.marks), marks.unshift({ name: \"and\", position: startPos }), pos = rhs.position, lhsLevel = 3;\n        break;\n      }\n      case \"!\": {\n        if (str[innerPos + 1] !== \"=\" || level > 4 || lhsLevel <= 4) break loop;\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n        if (rhs.type === \"error\") return rhs;\n        marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n        break;\n      }\n      case \"d\": {\n        if (str.slice(innerPos, innerPos + 4) !== \"desc\" || level > 4 || lhsLevel < 4) break loop;\n        marks.unshift({ name: \"desc\", position: startPos }), pos = innerPos + 4, lhsLevel = 4;\n        break;\n      }\n      case \"a\": {\n        if (str.slice(innerPos, innerPos + 3) !== \"asc\" || level > 4 || lhsLevel < 4) break loop;\n        marks.unshift({ name: \"asc\", position: startPos }), pos = innerPos + 3, lhsLevel = 4;\n        break;\n      }\n      default:\n        switch (parseRegexStr(str, innerPos, IDENT)) {\n          case \"in\": {\n            if (level > 4 || lhsLevel <= 4) break loop;\n            pos = skipWS(str, innerPos + 2);\n            let isGroup = !1;\n            str[pos] === \"(\" && (isGroup = !0, pos = skipWS(str, pos + 1));\n            let rangePos = pos, result = parseExpr(str, pos, 5);\n            if (result.type === \"error\") return result;\n            if (pos = skipWS(str, result.position), str[pos] === \".\" && str[pos + 1] === \".\") {\n              let type = \"inc_range\";\n              str[pos + 2] === \".\" ? (type = \"exc_range\", pos = skipWS(str, pos + 3)) : pos = skipWS(str, pos + 2);\n              let rhs = parseExpr(str, pos, 5);\n              if (rhs.type === \"error\") return rhs;\n              marks.unshift({ name: \"in_range\", position: startPos }), marks = marks.concat({ name: type, position: rangePos }, result.marks, rhs.marks), pos = rhs.position;\n            } else\n              marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 }), marks = marks.concat(result.marks);\n            if (isGroup) {\n              if (pos = skipWS(str, pos), str[pos] !== \")\")\n                return { type: \"error\", message: 'Expected \")\" in group', position: pos };\n              pos++;\n            }\n            lhsLevel = 4;\n            break;\n          }\n          case \"match\": {\n            if (level > 4 || lhsLevel <= 4) break loop;\n            let rhs = parseExpr(str, skipWS(str, innerPos + 5), 5);\n            if (rhs.type === \"error\") return rhs;\n            marks.unshift({ name: \"comp\", position: startPos }), marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 5 }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n            break;\n          }\n          default:\n            break loop;\n        }\n    }\n  }\n  let failPosition = trav?.type === \"error\" && trav.position;\n  return { type: \"success\", marks, position: pos, failPosition };\n}\nfunction parseGroupOrTuple(str, pos) {\n  const startPos = pos;\n  let marks, rhs = parseExpr(str, skipWS(str, pos + 1), 0);\n  if (rhs.type === \"error\") return rhs;\n  switch (pos = skipWS(str, rhs.position), str[pos]) {\n    case \",\": {\n      for (marks = [{ name: \"tuple\", position: startPos }].concat(rhs.marks), pos = skipWS(str, pos + 1); ; ) {\n        if (rhs = parseExpr(str, pos, 0), rhs.type === \"error\") return rhs;\n        if (marks.push(...rhs.marks), pos = skipWS(str, rhs.position), str[pos] !== \",\") break;\n        pos = skipWS(str, pos + 1);\n      }\n      if (str[pos] !== \")\")\n        return { type: \"error\", message: 'Expected \")\" after tuple expression', position: pos };\n      pos++, marks.push({ name: \"tuple_end\", position: pos });\n      break;\n    }\n    case \")\": {\n      pos++, marks = [{ name: \"group\", position: startPos }].concat(rhs.marks);\n      break;\n    }\n    default:\n      return { type: \"error\", message: `Unexpected character \"${str[pos]}\"`, position: pos };\n  }\n  return { type: \"success\", marks, position: pos };\n}\nfunction parseTraversal(str, pos) {\n  let startPos = pos;\n  switch (str[pos]) {\n    case \".\": {\n      if (pos = skipWS(str, pos + 1), str[pos] === \"(\")\n        return parseGroupOrTuple(str, pos);\n      let identStart = pos, identLen2 = parseRegex(str, pos, IDENT);\n      return identLen2 ? (pos += identLen2, {\n        type: \"success\",\n        marks: [\n          { name: \"attr_access\", position: startPos },\n          { name: \"ident\", position: identStart },\n          { name: \"ident_end\", position: pos }\n        ],\n        position: pos\n      }) : { type: \"error\", message: 'Expected identifier after \".\"', position: pos };\n    }\n    case \"-\":\n      if (str[pos + 1] !== \">\")\n        return { type: \"error\", message: 'Expected \">\" in reference', position: pos };\n      let marks = [{ name: \"deref\", position: startPos }];\n      pos += 2;\n      let identPos = skipWS(str, pos), identLen = parseRegex(str, identPos, IDENT);\n      return identLen && (pos = identPos + identLen, marks.push(\n        { name: \"deref_attr\", position: identPos },\n        { name: \"ident\", position: identPos },\n        { name: \"ident_end\", position: pos }\n      )), {\n        type: \"success\",\n        marks,\n        position: pos\n      };\n    case \"[\": {\n      if (pos = skipWS(str, pos + 1), str[pos] === \"]\")\n        return {\n          type: \"success\",\n          marks: [{ name: \"array_postfix\", position: startPos }],\n          position: pos + 1\n        };\n      let rangePos = pos, result = parseExpr(str, pos, 0);\n      if (result.type === \"error\") return result;\n      if (pos = skipWS(str, result.position), str[pos] === \".\" && str[pos + 1] === \".\") {\n        let type = \"inc_range\";\n        str[pos + 2] === \".\" ? (type = \"exc_range\", pos += 3) : pos += 2, pos = skipWS(str, pos);\n        let rhs = parseExpr(str, pos, 0);\n        return rhs.type === \"error\" ? rhs : (pos = skipWS(str, rhs.position), str[pos] !== \"]\" ? { type: \"error\", message: 'Expected \"]\" after array expression', position: pos } : {\n          type: \"success\",\n          marks: [\n            { name: \"slice\", position: startPos },\n            { name: type, position: rangePos }\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1\n        });\n      }\n      return str[pos] !== \"]\" ? { type: \"error\", message: 'Expected \"]\" after array expression', position: pos } : {\n        type: \"success\",\n        marks: [{ name: \"square_bracket\", position: startPos }].concat(result.marks),\n        position: pos + 1\n      };\n    }\n    case \"|\": {\n      if (pos = skipWS(str, pos + 1), str[pos] === \"{\") {\n        let result = parseObject(str, pos);\n        return result.type === \"error\" || result.marks.unshift({ name: \"projection\", position: startPos }), result;\n      }\n      break;\n    }\n    case \"{\": {\n      let result = parseObject(str, pos);\n      return result.type === \"error\" || result.marks.unshift({ name: \"projection\", position: startPos }), result;\n    }\n  }\n  return { type: \"error\", message: \"Unexpected character in traversal\", position: pos };\n}\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = [];\n  if (marks.push({ name: \"func_call\", position: startPos }), str[pos] === \":\" && str[pos + 1] === \":\") {\n    marks.push({ name: \"namespace\", position: startPos }), marks.push({ name: \"ident\", position: startPos }, { name: \"ident_end\", position: pos }), pos = skipWS(str, pos + 2);\n    let nameLen = parseRegex(str, pos, IDENT);\n    if (!nameLen) return { type: \"error\", message: \"Expected function name\", position: pos };\n    if (marks.push({ name: \"ident\", position: pos }, { name: \"ident_end\", position: pos + nameLen }), pos = skipWS(str, pos + nameLen), str[pos] !== \"(\")\n      return { type: \"error\", message: 'Expected \"(\" after function name', position: pos };\n    pos++, pos = skipWS(str, pos);\n  } else\n    marks.push({ name: \"ident\", position: startPos }, { name: \"ident_end\", position: pos }), pos = skipWS(str, pos + 1);\n  let lastPos = pos;\n  if (str[pos] !== \")\")\n    for (; ; ) {\n      let result = parseExpr(str, pos, 0);\n      if (result.type === \"error\") return result;\n      if (marks = marks.concat(result.marks), lastPos = result.position, pos = skipWS(str, result.position), str[pos] !== \",\" || (pos = skipWS(str, pos + 1), str[pos] === \")\")) break;\n    }\n  return str[pos] !== \")\" ? { type: \"error\", message: 'Expected \")\" after function arguments', position: pos } : (marks.push({ name: \"func_args_end\", position: lastPos }), {\n    type: \"success\",\n    marks,\n    position: pos + 1\n  });\n}\nfunction parseObject(str, pos) {\n  let marks = [{ name: \"object\", position: pos }];\n  for (pos = skipWS(str, pos + 1); str[pos] !== \"}\"; ) {\n    let pairPos = pos;\n    if (str.slice(pos, pos + 3) === \"...\")\n      if (pos = skipWS(str, pos + 3), str[pos] !== \"}\" && str[pos] !== \",\") {\n        let expr = parseExpr(str, pos, 0);\n        if (expr.type === \"error\") return expr;\n        marks.push({ name: \"object_splat\", position: pairPos }), marks = marks.concat(expr.marks), pos = expr.position;\n      } else\n        marks.push({ name: \"object_splat_this\", position: pairPos });\n    else {\n      let expr = parseExpr(str, pos, 0);\n      if (expr.type === \"error\") return expr;\n      let nextPos = skipWS(str, expr.position);\n      if (expr.marks[0].name === \"str\" && str[nextPos] === \":\") {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0);\n        if (value.type === \"error\") return value;\n        marks.push({ name: \"object_pair\", position: pairPos }), marks = marks.concat(expr.marks, value.marks), pos = value.position;\n      } else\n        marks = marks.concat({ name: \"object_expr\", position: pos }, expr.marks), pos = expr.position;\n    }\n    if (pos = skipWS(str, pos), str[pos] !== \",\") break;\n    pos = skipWS(str, pos + 1);\n  }\n  return str[pos] !== \"}\" ? { type: \"error\", message: 'Expected \"}\" after object', position: pos } : (pos++, marks.push({ name: \"object_end\", position: pos }), { type: \"success\", marks, position: pos });\n}\nfunction parseString(str, pos) {\n  let token = str[pos];\n  pos = pos + 1;\n  const marks = [{ name: \"str\", position: pos }];\n  str: for (; ; pos++) {\n    if (pos > str.length) return { type: \"error\", message: \"Unexpected end of query\", position: pos };\n    switch (str[pos]) {\n      case token: {\n        marks.push({ name: \"str_end\", position: pos }), pos++;\n        break str;\n      }\n      case \"\\\\\":\n        marks.push({ name: \"str_pause\", position: pos }), str[pos + 1] === \"u\" ? str[pos + 2] === \"{\" ? (marks.push({ name: \"unicode_hex\", position: pos + 3 }), pos = str.indexOf(\"}\", pos + 3), marks.push({ name: \"unicode_hex_end\", position: pos })) : (marks.push({ name: \"unicode_hex\", position: pos + 2 }), marks.push({ name: \"unicode_hex_end\", position: pos + 6 }), pos += 5) : (marks.push({ name: \"single_escape\", position: pos + 1 }), pos += 1), marks.push({ name: \"str_start\", position: pos + 1 });\n    }\n  }\n  return { type: \"success\", marks, position: pos };\n}\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS);\n}\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0].length : 0;\n}\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0] : null;\n}\nfunction parseFunctionDeclaration(str, startPos) {\n  let pos = startPos, marks = [], namespace = \"\", name = \"\";\n  if (str.substring(pos, pos + 2) !== \"fn\")\n    return {\n      type: \"success\",\n      position: pos,\n      marks\n    };\n  marks.push({ name: \"func_decl\", position: startPos }), pos = skipWS(str, pos + 2);\n  let identStart = pos;\n  if (namespace = parseRegexStr(str, pos, IDENT), !namespace)\n    return { type: \"error\", message: \"Expected function name\", position: pos };\n  if (marks.push(\n    { name: \"ident\", position: identStart },\n    { name: \"ident_end\", position: pos + namespace.length }\n  ), pos = skipWS(str, pos + namespace.length), str.substring(pos, pos + 2) !== \"::\")\n    return { type: \"error\", message: 'Expected \"::\" after namespace', position: pos };\n  if (pos = skipWS(str, pos + 2), name = parseRegexStr(str, pos, IDENT), !name)\n    return { type: \"error\", message: \"Expected function name\", position: pos };\n  if (marks.push({ name: \"ident\", position: pos }, { name: \"ident_end\", position: pos + name.length }), pos = skipWS(str, pos + name.length), str[pos] !== \"(\")\n    return { type: \"error\", message: 'Expected \"(\"', position: pos };\n  for (pos = skipWS(str, pos + 1); pos < str.length && str[pos] !== \")\"; ) {\n    if (str[pos] !== \"$\")\n      return { type: \"error\", message: 'Parameter should start with \"$\"', position: pos };\n    const startPos2 = pos;\n    pos++;\n    const paramName = parseRegexStr(str, pos, IDENT);\n    if (!paramName)\n      return { type: \"error\", message: \"Expected function name\", position: pos };\n    if (pos += paramName.length, marks.push(\n      { name: \"param\", position: startPos2 },\n      { name: \"ident\", position: startPos2 + 1 },\n      { name: \"ident_end\", position: pos }\n    ), pos = skipWS(str, pos), str[pos] === \",\")\n      pos = skipWS(str, pos + 1);\n    else if (str[pos] !== \")\")\n      return { type: \"error\", message: 'Expected \",\" or \")\"', position: pos };\n  }\n  if (str[pos] !== \")\")\n    return { type: \"error\", message: 'Expected \")\"', position: pos };\n  if (marks.push({ name: \"func_params_end\", position: pos }), pos = skipWS(str, pos + 1), str[pos] !== \"=\")\n    return { type: \"error\", message: 'Expected \"=\"', position: pos };\n  pos = skipWS(str, pos + 1);\n  let bodyResult = parseExpr(str, pos, 0);\n  return bodyResult.type === \"error\" ? bodyResult : (marks = marks.concat(bodyResult.marks), pos = skipWS(str, bodyResult.position), str[pos] !== \";\" ? { type: \"error\", message: 'Expected \";\" after function declaration', position: pos } : (pos++, {\n    type: \"success\",\n    position: pos,\n    marks,\n    namespace,\n    name\n  }));\n}\nfunction join(a, b) {\n  return (base) => b(a(base));\n}\nfunction map(inner) {\n  return (base) => ({ type: \"Map\", base, expr: inner({ type: \"This\" }) });\n}\nfunction flatMap(inner) {\n  return (base) => ({ type: \"FlatMap\", base, expr: inner({ type: \"This\" }) });\n}\nfunction traverseArray(build, right) {\n  if (!right)\n    return {\n      type: \"a-a\",\n      build\n    };\n  switch (right.type) {\n    case \"a-a\":\n      return {\n        type: \"a-a\",\n        build: join(build, right.build)\n      };\n    case \"a-b\":\n      return {\n        type: \"a-b\",\n        build: join(build, right.build)\n      };\n    case \"b-b\":\n      return {\n        type: \"a-a\",\n        build: join(build, map(right.build))\n      };\n    case \"b-a\":\n      return {\n        type: \"a-a\",\n        build: join(build, flatMap(right.build))\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traversePlain(mapper, right) {\n  if (!right)\n    return {\n      type: \"b-b\",\n      build: mapper\n    };\n  switch (right.type) {\n    case \"a-a\":\n    case \"b-a\":\n      return {\n        type: \"b-a\",\n        build: join(mapper, right.build)\n      };\n    case \"a-b\":\n    case \"b-b\":\n      return {\n        type: \"b-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traverseElement(mapper, right) {\n  if (!right)\n    return {\n      type: \"a-b\",\n      build: mapper\n    };\n  switch (right.type) {\n    case \"a-a\":\n    case \"b-a\":\n      return {\n        type: \"a-a\",\n        build: join(mapper, right.build)\n      };\n    case \"a-b\":\n    case \"b-b\":\n      return {\n        type: \"a-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction traverseProjection(mapper, right) {\n  if (!right)\n    return {\n      type: \"b-b\",\n      build: mapper\n    };\n  switch (right.type) {\n    case \"a-a\":\n      return {\n        type: \"a-a\",\n        build: join(map(mapper), right.build)\n      };\n    case \"a-b\":\n      return {\n        type: \"a-b\",\n        build: join(map(mapper), right.build)\n      };\n    case \"b-a\":\n      return {\n        type: \"b-a\",\n        build: join(mapper, right.build)\n      };\n    case \"b-b\":\n      return {\n        type: \"b-b\",\n        build: join(mapper, right.build)\n      };\n    default:\n      throw new Error(`unknown type: ${right.type}`);\n  }\n}\nfunction walkValidateCustomFunction(node, level = 0) {\n  switch (node.type) {\n    case \"Projection\":\n      return {\n        ...node,\n        base: walkValidateCustomFunction(node.base, level),\n        expr: walkValidateCustomFunction(node.expr, level + 1)\n      };\n    case \"Filter\":\n      return {\n        ...node,\n        base: walkValidateCustomFunction(node.base, level),\n        expr: walkValidateCustomFunction(node.expr, level + 1)\n      };\n    case \"Parent\": {\n      if (level - node.n < 0)\n        throw new Error(\n          `Invalid use of parent operator (^). No parent n ${node.n} at level ${level}.`\n        );\n      return node;\n    }\n    case \"Parameter\":\n      throw new Error(\n        `Function parameters are not allowed outside function declarations: ${node.name}`\n      );\n    case \"Array\":\n      return {\n        ...node,\n        elements: node.elements.map((el) => ({\n          ...el,\n          value: walkValidateCustomFunction(el.value, level)\n        }))\n      };\n    case \"PipeFuncCall\":\n      return {\n        ...node,\n        base: walkValidateCustomFunction(node.base, level),\n        args: node.args.map((arg) => walkValidateCustomFunction(arg, level))\n      };\n    case \"Object\":\n      return {\n        ...node,\n        attributes: node.attributes.map((attr) => {\n          switch (attr.type) {\n            case \"ObjectAttributeValue\":\n              return {\n                ...attr,\n                value: walkValidateCustomFunction(attr.value, level)\n              };\n            case \"ObjectConditionalSplat\":\n              return {\n                ...attr,\n                condition: walkValidateCustomFunction(attr.condition, level),\n                value: walkValidateCustomFunction(attr.value, level)\n              };\n            case \"ObjectSplat\":\n              return {\n                ...attr,\n                value: walkValidateCustomFunction(attr.value, level)\n              };\n            default:\n              return attr;\n          }\n        })\n      };\n    case \"FlatMap\":\n    case \"Map\":\n      return {\n        ...node,\n        expr: walkValidateCustomFunction(node.expr, level),\n        base: walkValidateCustomFunction(node.base, level)\n      };\n    case \"FuncCall\":\n      return {\n        ...node,\n        args: node.args.map((arg) => walkValidateCustomFunction(arg, level))\n      };\n    case \"Tuple\":\n      return {\n        ...node,\n        members: node.members.map((member) => walkValidateCustomFunction(member, level))\n      };\n    case \"Select\": {\n      const alternatives = node.alternatives.map((alt) => ({\n        ...alt,\n        condition: walkValidateCustomFunction(alt.condition, level),\n        value: walkValidateCustomFunction(alt.value, level)\n      }));\n      return node.fallback ? {\n        ...node,\n        alternatives,\n        fallback: walkValidateCustomFunction(node.fallback, level)\n      } : {\n        ...node,\n        alternatives\n      };\n    }\n    case \"SelectorNested\":\n      return {\n        ...node,\n        base: walkValidateCustomFunction(node.base, level),\n        nested: walkValidateCustomFunction(node.nested, level)\n      };\n    case \"SelectorFuncCall\":\n      return {\n        ...node,\n        arg: walkValidateCustomFunction(node.arg, level)\n      };\n    case \"AccessAttribute\":\n    case \"AccessElement\":\n    case \"ArrayCoerce\":\n    case \"Asc\":\n    case \"Desc\":\n    case \"Deref\":\n    case \"Group\":\n    case \"Neg\":\n    case \"Not\":\n    case \"Slice\":\n    case \"Pos\":\n      return node.base ? {\n        ...node,\n        base: walkValidateCustomFunction(node.base, level)\n      } : node;\n    case \"InRange\":\n      return {\n        ...node,\n        base: walkValidateCustomFunction(node.base, level),\n        left: walkValidateCustomFunction(node.left, level),\n        right: walkValidateCustomFunction(node.right, level)\n      };\n    case \"OpCall\":\n    case \"And\":\n    case \"Or\":\n      return {\n        ...node,\n        left: walkValidateCustomFunction(node.left, level),\n        right: walkValidateCustomFunction(node.right, level)\n      };\n    case \"Everything\":\n    case \"This\":\n    case \"Value\":\n    case \"Context\":\n      return node;\n    default:\n      throw new Error(`Handle all cases: ${node.type}`);\n  }\n}\nconst ESCAPE_SEQUENCE = {\n  \"'\": \"'\",\n  '\"': '\"',\n  \"\\\\\": \"\\\\\",\n  \"/\": \"/\",\n  b: \"\\b\",\n  f: \"\\f\",\n  n: `\n`,\n  r: \"\\r\",\n  t: \"\t\"\n};\nfunction expandHex(str) {\n  const charCode = parseInt(str, 16);\n  return String.fromCharCode(charCode);\n}\nclass GroqQueryError extends Error {\n  name = \"GroqQueryError\";\n}\nfunction createExpressionBuilder(recursion = /* @__PURE__ */ new Set()) {\n  const exprBuilder = {\n    group(p) {\n      return {\n        type: \"Group\",\n        base: p.process(exprBuilder)\n      };\n    },\n    everything() {\n      return { type: \"Everything\" };\n    },\n    this() {\n      return { type: \"This\" };\n    },\n    parent() {\n      return {\n        type: \"Parent\",\n        n: 1\n      };\n    },\n    dblparent(p) {\n      return {\n        type: \"Parent\",\n        n: p.process(exprBuilder).n + 1\n      };\n    },\n    traverse(p) {\n      const base = p.process(exprBuilder), traversalList = [];\n      for (; p.getMark().name !== \"traversal_end\"; )\n        traversalList.push(p.process(TRAVERSE_BUILDER));\n      p.shift();\n      let traversal = null;\n      for (let i = traversalList.length - 1; i >= 0; i--)\n        traversal = traversalList[i](traversal);\n      if ((base.type === \"Everything\" || base.type === \"Array\" || base.type === \"PipeFuncCall\") && (traversal = traverseArray((val) => val, traversal)), traversal === null) throw new Error(\"BUG: unexpected empty traversal\");\n      return traversal.build(base);\n    },\n    this_attr(p) {\n      const name = p.processString();\n      return name === \"null\" ? { type: \"Value\", value: null } : name === \"true\" ? { type: \"Value\", value: !0 } : name === \"false\" ? { type: \"Value\", value: !1 } : {\n        type: \"AccessAttribute\",\n        name\n      };\n    },\n    neg(p) {\n      return {\n        type: \"Neg\",\n        base: p.process(exprBuilder)\n      };\n    },\n    pos(p) {\n      return {\n        type: \"Pos\",\n        base: p.process(exprBuilder)\n      };\n    },\n    add(p) {\n      const left = p.process(exprBuilder), right = p.process(exprBuilder);\n      return {\n        type: \"OpCall\",\n        op: \"+\",\n        left,\n        right\n      };\n    },\n    sub(p) {\n      const left = p.process(exprBuilder), right = p.process(exprBuilder);\n      return {\n        type: \"OpCall\",\n        op: \"-\",\n        left,\n        right\n      };\n    },\n    mul(p) {\n      const left = p.process(exprBuilder), right = p.process(exprBuilder);\n      return {\n        type: \"OpCall\",\n        op: \"*\",\n        left,\n        right\n      };\n    },\n    div(p) {\n      const left = p.process(exprBuilder), right = p.process(exprBuilder);\n      return {\n        type: \"OpCall\",\n        op: \"/\",\n        left,\n        right\n      };\n    },\n    mod(p) {\n      const left = p.process(exprBuilder), right = p.process(exprBuilder);\n      return {\n        type: \"OpCall\",\n        op: \"%\",\n        left,\n        right\n      };\n    },\n    pow(p) {\n      const left = p.process(exprBuilder), right = p.process(exprBuilder);\n      return {\n        type: \"OpCall\",\n        op: \"**\",\n        left,\n        right\n      };\n    },\n    comp(p) {\n      const left = p.process(exprBuilder), op = p.processString(), right = p.process(exprBuilder);\n      return {\n        type: \"OpCall\",\n        op,\n        left,\n        right\n      };\n    },\n    in_range(p) {\n      const base = p.process(exprBuilder), isInclusive = p.getMark().name === \"inc_range\";\n      p.shift();\n      const left = p.process(exprBuilder), right = p.process(exprBuilder);\n      return {\n        type: \"InRange\",\n        base,\n        left,\n        right,\n        isInclusive\n      };\n    },\n    str(p) {\n      let value = \"\";\n      loop: for (; p.hasMark(); ) {\n        const mark = p.getMark();\n        switch (mark.name) {\n          case \"str_end\":\n            value += p.processStringEnd();\n            break loop;\n          case \"str_pause\":\n            value += p.processStringEnd();\n            break;\n          case \"str_start\":\n            p.shift();\n            break;\n          case \"single_escape\": {\n            const char = p.slice(1);\n            p.shift(), value += ESCAPE_SEQUENCE[char];\n            break;\n          }\n          case \"unicode_hex\":\n            p.shift(), value += expandHex(p.processStringEnd());\n            break;\n          default:\n            throw new Error(`unexpected mark: ${mark.name}`);\n        }\n      }\n      return { type: \"Value\", value };\n    },\n    integer(p) {\n      const strValue = p.processStringEnd();\n      return {\n        type: \"Value\",\n        value: Number(strValue)\n      };\n    },\n    float(p) {\n      const strValue = p.processStringEnd();\n      return {\n        type: \"Value\",\n        value: Number(strValue)\n      };\n    },\n    sci(p) {\n      const strValue = p.processStringEnd();\n      return {\n        type: \"Value\",\n        value: Number(strValue)\n      };\n    },\n    object(p) {\n      const attributes = [];\n      for (; p.getMark().name !== \"object_end\"; )\n        attributes.push(p.process(OBJECT_BUILDER));\n      return p.shift(), {\n        type: \"Object\",\n        attributes\n      };\n    },\n    array(p) {\n      const elements = [];\n      for (; p.getMark().name !== \"array_end\"; ) {\n        let isSplat = !1;\n        p.getMark().name === \"array_splat\" && (isSplat = !0, p.shift());\n        const value = p.process(exprBuilder);\n        elements.push({\n          type: \"ArrayElement\",\n          value,\n          isSplat\n        });\n      }\n      return p.shift(), {\n        type: \"Array\",\n        elements\n      };\n    },\n    tuple(p) {\n      const members = [];\n      for (; p.getMark().name !== \"tuple_end\"; )\n        members.push(p.process(exprBuilder));\n      return p.shift(), {\n        type: \"Tuple\",\n        members\n      };\n    },\n    func_call(p) {\n      let namespace = \"global\";\n      p.getMark().name === \"namespace\" && (p.shift(), namespace = p.processString());\n      const name = p.processString();\n      if (namespace === \"global\" && name === \"select\") {\n        const result = {\n          type: \"Select\",\n          alternatives: []\n        };\n        for (; p.getMark().name !== \"func_args_end\"; )\n          if (p.getMark().name === \"pair\") {\n            if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n            p.shift();\n            const condition = p.process(exprBuilder), value = p.process(exprBuilder);\n            result.alternatives.push({\n              type: \"SelectAlternative\",\n              condition,\n              value\n            });\n          } else {\n            if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n            const value = p.process(exprBuilder);\n            result.fallback = value;\n          }\n        return p.shift(), result;\n      }\n      const args = [];\n      for (; p.getMark().name !== \"func_args_end\"; )\n        argumentShouldBeSelector(namespace, name, args.length) ? args.push(p.process(SELECTOR_BUILDER)) : args.push(p.process(exprBuilder));\n      if (p.shift(), namespace === \"global\" && (name === \"before\" || name === \"after\") && p.parseOptions.mode === \"delta\")\n        return {\n          type: \"Context\",\n          key: name\n        };\n      if (namespace === \"global\" && name === \"boost\" && !p.allowBoost)\n        throw new GroqQueryError(\"unexpected boost\");\n      const customFunction = p.customFunctions[`${namespace}::${name}`];\n      if (customFunction !== void 0) {\n        const FUNCTION_DECL_BUILDER = createFunctionDeclarationBuilder(recursion), funcDecl = new MarkProcessor(p.string, customFunction.marks, p.customFunctions, {}).process(FUNCTION_DECL_BUILDER);\n        return validateArity(name, funcDecl.params.length, args.length), mapCustomFunction(\n          funcDecl.body,\n          (body) => walkValidateCustomFunction(body),\n          (parameterNode) => resolveFunctionParameter(parameterNode, funcDecl.params, args)\n        );\n      }\n      const funcs = namespaces[namespace];\n      if (!funcs)\n        throw new GroqQueryError(`Undefined namespace: ${namespace}`);\n      const func = funcs[name];\n      if (!func)\n        throw new GroqQueryError(`Undefined function: ${name}`);\n      if (func.arity !== void 0 && validateArity(name, func.arity, args.length), func.mode !== void 0 && func.mode !== p.parseOptions.mode)\n        throw new GroqQueryError(`Undefined function: ${name}`);\n      return {\n        type: \"FuncCall\",\n        namespace,\n        name,\n        args,\n        func\n      };\n    },\n    pipecall(p) {\n      const base = p.process(exprBuilder);\n      p.shift();\n      let namespace = \"global\";\n      if (p.getMark().name === \"namespace\" && (p.shift(), namespace = p.processString()), namespace !== \"global\")\n        throw new GroqQueryError(`Undefined namespace: ${namespace}`);\n      const name = p.processString(), args = [], oldAllowBoost = p.allowBoost;\n      for (name === \"score\" && (p.allowBoost = !0); ; ) {\n        const markName = p.getMark().name;\n        if (markName === \"func_args_end\")\n          break;\n        if (name === \"order\") {\n          if (markName === \"asc\") {\n            p.shift(), args.push({ type: \"Asc\", base: p.process(exprBuilder) });\n            continue;\n          } else if (markName === \"desc\") {\n            p.shift(), args.push({ type: \"Desc\", base: p.process(exprBuilder) });\n            continue;\n          }\n        }\n        args.push(p.process(exprBuilder));\n      }\n      p.shift(), p.allowBoost = oldAllowBoost;\n      const func = pipeFunctions[name];\n      if (!func)\n        throw new GroqQueryError(`Undefined pipe function: ${name}`);\n      return func.arity && validateArity(name, func.arity, args.length), {\n        type: \"PipeFuncCall\",\n        func,\n        base,\n        name,\n        args\n      };\n    },\n    pair() {\n      throw new GroqQueryError(\"unexpected =>\");\n    },\n    and(p) {\n      const left = p.process(exprBuilder), right = p.process(exprBuilder);\n      return {\n        type: \"And\",\n        left,\n        right\n      };\n    },\n    or(p) {\n      const left = p.process(exprBuilder), right = p.process(exprBuilder);\n      return {\n        type: \"Or\",\n        left,\n        right\n      };\n    },\n    not(p) {\n      return {\n        type: \"Not\",\n        base: p.process(exprBuilder)\n      };\n    },\n    asc() {\n      throw new GroqQueryError(\"unexpected asc\");\n    },\n    desc() {\n      throw new GroqQueryError(\"unexpected desc\");\n    },\n    param(p) {\n      const name = p.processString();\n      return p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name) ? {\n        type: \"Value\",\n        value: p.parseOptions.params[name]\n      } : {\n        type: \"Parameter\",\n        name\n      };\n    }\n  }, OBJECT_BUILDER = {\n    object_expr(p) {\n      if (p.getMark().name === \"pair\") {\n        p.shift();\n        const condition = p.process(exprBuilder), value2 = p.process(exprBuilder);\n        return {\n          type: \"ObjectConditionalSplat\",\n          condition,\n          value: value2\n        };\n      }\n      const value = p.process(exprBuilder);\n      return {\n        type: \"ObjectAttributeValue\",\n        name: extractPropertyKey(value),\n        value\n      };\n    },\n    object_pair(p) {\n      const name = p.process(exprBuilder);\n      if (name.type !== \"Value\") throw new Error(\"name must be string\");\n      const value = p.process(exprBuilder);\n      return {\n        type: \"ObjectAttributeValue\",\n        name: name.value,\n        value\n      };\n    },\n    object_splat(p) {\n      return {\n        type: \"ObjectSplat\",\n        value: p.process(exprBuilder)\n      };\n    },\n    object_splat_this() {\n      return {\n        type: \"ObjectSplat\",\n        value: { type: \"This\" }\n      };\n    }\n  }, TRAVERSE_BUILDER = {\n    square_bracket(p) {\n      const expr = p.process(exprBuilder), value = tryConstantEvaluate(expr);\n      return value && value.type === \"number\" ? (right) => traverseElement((base) => ({ type: \"AccessElement\", base, index: value.data }), right) : value && value.type === \"string\" ? (right) => traversePlain((base) => ({ type: \"AccessAttribute\", base, name: value.data }), right) : (right) => traverseArray(\n        (base) => ({\n          type: \"Filter\",\n          base,\n          expr\n        }),\n        right\n      );\n    },\n    slice(p) {\n      const isInclusive = p.getMark().name === \"inc_range\";\n      p.shift();\n      const left = p.process(exprBuilder), right = p.process(exprBuilder), leftValue = tryConstantEvaluate(left), rightValue = tryConstantEvaluate(right);\n      if (!leftValue || !rightValue || leftValue.type !== \"number\" || rightValue.type !== \"number\")\n        throw new GroqQueryError(\"slicing must use constant numbers\");\n      return (rhs) => traverseArray(\n        (base) => ({\n          type: \"Slice\",\n          base,\n          left: leftValue.data,\n          right: rightValue.data,\n          isInclusive\n        }),\n        rhs\n      );\n    },\n    projection(p) {\n      const obj = p.process(exprBuilder);\n      return (right) => traverseProjection((base) => ({ type: \"Projection\", base, expr: obj }), right);\n    },\n    attr_access(p) {\n      const name = p.processString();\n      return (right) => traversePlain((base) => ({ type: \"AccessAttribute\", base, name }), right);\n    },\n    deref(p) {\n      let attr = null;\n      p.getMark().name === \"deref_attr\" && (p.shift(), attr = p.processString());\n      const wrap = (base) => attr ? { type: \"AccessAttribute\", base, name: attr } : base;\n      return (right) => traversePlain(\n        (base) => wrap({\n          type: \"Deref\",\n          base\n        }),\n        right\n      );\n    },\n    array_postfix() {\n      return (right) => traverseArray((base) => ({ type: \"ArrayCoerce\", base }), right);\n    }\n  }, SELECTOR_BUILDER = {\n    group(p) {\n      return p.process(SELECTOR_BUILDER);\n    },\n    everything() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    this() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    parent() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    dblparent() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    traverse(p) {\n      let node = p.process(SELECTOR_BUILDER);\n      for (; p.getMark().name !== \"traversal_end\"; )\n        if (p.getMark().name === \"array_postfix\")\n          p.shift(), node = { type: \"ArrayCoerce\", base: node };\n        else if (p.getMark().name === \"square_bracket\") {\n          p.shift();\n          const expr = p.process(exprBuilder), value = tryConstantEvaluate(expr);\n          if (value && value.type === \"number\")\n            throw new Error(\"Invalid array access expression\");\n          value && value.type === \"string\" ? node = { type: \"AccessAttribute\", base: node, name: value.data } : node = { type: \"Filter\", base: node, expr };\n        } else if (p.getMark().name === \"attr_access\") {\n          p.shift();\n          const name = p.processString();\n          node = { type: \"AccessAttribute\", base: node, name };\n        } else if (p.getMark().name === \"tuple\" || p.getMark().name === \"group\") {\n          const selector = p.process(SELECTOR_BUILDER);\n          if (!isSelectorNested(selector))\n            throw new Error(`Unexpected result parsing nested selector: ${selector.type}`);\n          node = { type: \"SelectorNested\", base: node, nested: selector };\n        } else\n          throw new Error(\"Invalid selector syntax\");\n      return p.shift(), node;\n    },\n    this_attr(p) {\n      return { type: \"AccessAttribute\", name: p.processString() };\n    },\n    attr_access() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    neg() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    pos() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    add() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    sub() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    mul() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    div() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    mod() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    pow() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    comp() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    in_range() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    str() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    integer() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    float() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    sci() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    object() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    array() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    tuple(p) {\n      const selectors = [];\n      for (; p.getMark().name !== \"tuple_end\"; )\n        selectors.push(p.process(SELECTOR_BUILDER));\n      return p.shift(), { type: \"Tuple\", members: selectors };\n    },\n    func_call(p, mark) {\n      const func = exprBuilder.func_call(p, mark);\n      if (func.name === \"anywhere\" && func.args.length === 1)\n        return {\n          type: \"SelectorFuncCall\",\n          name: \"anywhere\",\n          arg: func.args[0]\n        };\n      throw new Error(\"Invalid selector syntax\");\n    },\n    pipecall() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    pair() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    and() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    or() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    not() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    asc() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    desc() {\n      throw new Error(\"Invalid selector syntax\");\n    },\n    param() {\n      throw new Error(\"Invalid selector syntax\");\n    }\n  };\n  return exprBuilder;\n}\nfunction extractPropertyKey(node) {\n  if (node.type === \"AccessAttribute\" && !node.base)\n    return node.name;\n  if (node.type === \"PipeFuncCall\" || node.type === \"Deref\" || node.type === \"Map\" || node.type === \"Projection\" || node.type === \"Slice\" || node.type === \"Filter\" || node.type === \"AccessElement\" || node.type === \"ArrayCoerce\" || node.type === \"Group\")\n    return extractPropertyKey(node.base);\n  throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`);\n}\nfunction validateArity(name, arity, count) {\n  if (typeof arity == \"number\") {\n    if (count !== arity)\n      throw new GroqQueryError(\n        `Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count}.`\n      );\n  } else if (arity && !arity(count))\n    throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`);\n}\nfunction resolveFunctionParameter(parameter, params, args) {\n  if (parameter.type !== \"Parameter\")\n    throw new GroqQueryError(`Expected parameter node, got ${parameter.type}`);\n  const index = params.findIndex((p) => p.name === parameter.name);\n  if (index === -1)\n    throw new GroqQueryError(`Missing argument for parameter ${parameter.name} in function call`);\n  return args[index];\n}\nfunction mapCustomFunction(body, bodyMapper, parameterMapper = (n) => n) {\n  if (body.type === \"Projection\") {\n    if (body.base.type === \"Parameter\")\n      return {\n        type: \"Projection\",\n        base: parameterMapper(body.base),\n        expr: bodyMapper(body.expr)\n      };\n    if (body.base.type === \"Deref\" && body.base.base.type === \"Parameter\")\n      return {\n        type: \"Projection\",\n        base: {\n          type: \"Deref\",\n          base: parameterMapper(body.base.base)\n        },\n        expr: bodyMapper(body.expr)\n      };\n  }\n  if (body.type === \"Map\" && body.base.type === \"ArrayCoerce\" && body.base.base.type === \"Parameter\")\n    return {\n      type: \"Map\",\n      base: {\n        type: \"ArrayCoerce\",\n        base: parameterMapper(body.base.base)\n      },\n      expr: bodyMapper(body.expr)\n    };\n  throw new GroqQueryError(`Unexpected function body, must be a projection. Got \"${body.type}\"`);\n}\nfunction argumentShouldBeSelector(namespace, functionName, argCount) {\n  const functionsRequiringSelectors = [\"changedAny\", \"changedOnly\"];\n  return namespace == \"diff\" && argCount == 2 && functionsRequiringSelectors.includes(functionName);\n}\nclass GroqSyntaxError extends Error {\n  position;\n  name = \"GroqSyntaxError\";\n  constructor(position, detail) {\n    super(`Syntax error in GROQ query at position ${position}${detail ? `: ${detail}` : \"\"}`), this.position = position;\n  }\n}\nfunction parse(input, options = {}) {\n  const result = parse$1(input);\n  if (result.type === \"error\")\n    throw new GroqSyntaxError(result.position, result.message);\n  validateCustomFunctions(input, result.customFunctions);\n  const processor = new MarkProcessor(input, result.marks, result.customFunctions, options), exprBuilder = createExpressionBuilder();\n  return processor.process(exprBuilder);\n}\nfunction createFunctionDeclarationBuilder(recursion = /* @__PURE__ */ new Set()) {\n  return {\n    func_decl(p) {\n      const namespace = p.processString(), name = p.processString(), functionId = `${namespace}::${name}`;\n      if (recursion.has(functionId))\n        throw new GroqQueryError(`Recursive function definition detected for ${functionId}`);\n      const exprBuilder = createExpressionBuilder(/* @__PURE__ */ new Set([...recursion, functionId])), params = [];\n      for (; p.getMark().name !== \"func_params_end\"; ) {\n        const param = p.process(exprBuilder);\n        if (param.type !== \"Parameter\") throw new Error(\"expected parameter\");\n        params.push(param);\n      }\n      if (params.length !== 1)\n        throw new GroqQueryError(\"Custom functions can only have one parameter\");\n      p.shift();\n      const body = p.process(exprBuilder);\n      return {\n        type: \"FuncDeclaration\",\n        namespace,\n        name,\n        params,\n        body\n      };\n    }\n  };\n}\nfunction validateCustomFunctions(query, customFunctions) {\n  for (const functionId in customFunctions) {\n    if (!customFunctions.hasOwnProperty(functionId)) continue;\n    const customFunction = customFunctions[functionId], processor = new MarkProcessor(query, customFunction.marks, customFunctions, {}), FUNCTION_DECL_BUILDER = createFunctionDeclarationBuilder(), funcDecl = processor.process(FUNCTION_DECL_BUILDER);\n    mapCustomFunction(funcDecl.body, (body) => walkValidateCustomFunction(body));\n  }\n}\nconst { compare } = new Intl.Collator(\"en\");\nfunction typeNodesSorter(a, b) {\n  return a.type === \"null\" ? 1 : compare(hashField(a), hashField(b));\n}\nconst hashCache = /* @__PURE__ */ new WeakMap();\nfunction hashField(field) {\n  if (hashCache.has(field))\n    return hashCache.get(field);\n  const hash = calculateFieldHash(field);\n  return hashCache.set(field, hash), hash;\n}\nfunction calculateFieldHash(field) {\n  switch (field.type) {\n    case \"string\":\n    case \"number\":\n    case \"boolean\":\n      return field.value !== void 0 ? `${field.type}(${field.value})` : `${field.type}`;\n    case \"null\":\n    case \"unknown\":\n      return field.type;\n    case \"array\":\n      return `${field.type}(${hashField(field.of)})`;\n    case \"object\": {\n      const attributes = Object.entries(field.attributes);\n      return attributes.sort(([a], [b]) => compare(a, b)), `${field.type}:(${attributes.map(\n        ([key, value]) => `${key}:${hashField(value.value)}(${value.optional ? \"optional\" : \"non-optional\"})`\n      ).join(\",\")}):ref-${field.dereferencesTo}:${field.rest ? hashField(field.rest) : \"no-rest\"}`;\n    }\n    case \"union\": {\n      const sorted = [...field.of];\n      return sorted.sort(typeNodesSorter), `${field.type}(${sorted.map(hashField).join(\",\")})`;\n    }\n    case \"inline\":\n      return `${field.type}(${field.name})`;\n    default:\n      return field.type;\n  }\n}\nfunction removeDuplicateTypeNodes(typeNodes) {\n  const seenTypes = /* @__PURE__ */ new Set(), newTypeNodes = [], sortedTypeNodes = [...typeNodes];\n  sortedTypeNodes.sort(typeNodesSorter);\n  for (const typeNode of sortedTypeNodes) {\n    const hash = hashField(typeNode);\n    if (hash === null) {\n      newTypeNodes.push(typeNode);\n      continue;\n    }\n    seenTypes.has(hash) || (seenTypes.add(hash), newTypeNodes.push(typeNode));\n  }\n  return newTypeNodes;\n}\nfunction optimizeUnions(field) {\n  if (field.type === \"union\") {\n    if (field.of.length === 0)\n      return field;\n    if (field.of = removeDuplicateTypeNodes(field.of), field.of.length === 1)\n      return optimizeUnions(field.of[0]);\n    for (let idx = 0; field.of.length > idx; idx++) {\n      const subField = field.of[idx];\n      if (subField.type === \"union\") {\n        field.of.splice(idx, 1, ...subField.of), idx--;\n        continue;\n      }\n      field.of[idx] = optimizeUnions(subField);\n    }\n    return field.of.sort((a, b) => a.type === \"null\" ? 1 : compare(hashField(a), hashField(b))), field;\n  }\n  if (field.type === \"array\")\n    return field.of = optimizeUnions(field.of), field;\n  if (field.type === \"object\") {\n    for (const idx in field.attributes)\n      Object.hasOwn(field.attributes, idx) && (field.attributes[idx].value = optimizeUnions(field.attributes[idx].value));\n    return field;\n  }\n  return field;\n}\nfunction createReferenceTypeNode(name, inArray = !1) {\n  const attributes = {\n    _ref: {\n      type: \"objectAttribute\",\n      value: {\n        type: \"string\"\n      }\n    },\n    _type: {\n      type: \"objectAttribute\",\n      value: {\n        type: \"string\",\n        value: \"reference\"\n      }\n    },\n    _weak: {\n      type: \"objectAttribute\",\n      value: {\n        type: \"boolean\"\n      },\n      optional: !0\n    }\n  };\n  return inArray && (attributes._key = {\n    type: \"objectAttribute\",\n    value: {\n      type: \"string\"\n    }\n  }), {\n    type: \"object\",\n    attributes,\n    dereferencesTo: name\n  };\n}\nfunction nullUnion(node) {\n  return node.type === \"union\" ? unionOf(...node.of, { type: \"null\" }) : unionOf(node, { type: \"null\" });\n}\nfunction unionOf(...nodes) {\n  return {\n    type: \"union\",\n    of: nodes\n  };\n}\nfunction resolveInline(node, scope) {\n  if (node.type === \"inline\") {\n    const resolvedInline = scope.context.lookupTypeDeclaration(node);\n    return resolveInline(resolvedInline, scope);\n  }\n  return node;\n}\nfunction mapNode(node, scope, mapper, mergeUnions = (nodes) => optimizeUnions({ type: \"union\", of: nodes })) {\n  switch (node.type) {\n    case \"boolean\":\n    case \"array\":\n    case \"null\":\n    case \"object\":\n    case \"string\":\n    case \"number\":\n    case \"unknown\":\n      return mapper(node);\n    case \"union\":\n      return mergeUnions(node.of.map((inner) => mapNode(inner, scope, mapper), mergeUnions));\n    case \"inline\": {\n      const resolvedInline = resolveInline(node, scope);\n      return mapNode(resolvedInline, scope, mapper, mergeUnions);\n    }\n    default:\n      throw new Error(`Unknown type: ${node.type}`);\n  }\n}\nfunction isFuncCall(node, name) {\n  return node.type === \"Group\" ? isFuncCall(node.base, name) : node.type === \"FuncCall\" && `${node.namespace}::${node.name}` === name;\n}\nfunction createGeoJson(type = \"Point\") {\n  let coordinateAttribute = {\n    type: \"array\",\n    of: {\n      type: \"number\"\n    }\n  };\n  return type === \"LineString\" && (coordinateAttribute = {\n    type: \"array\",\n    of: {\n      type: \"array\",\n      of: {\n        type: \"number\"\n      }\n    }\n  }), type === \"Polygon\" && (coordinateAttribute = {\n    type: \"array\",\n    of: {\n      type: \"array\",\n      of: {\n        type: \"array\",\n        of: {\n          type: \"number\"\n        }\n      }\n    }\n  }), {\n    type: \"object\",\n    attributes: {\n      type: {\n        type: \"objectAttribute\",\n        value: {\n          type: \"string\",\n          value: type\n        }\n      },\n      coordinates: {\n        type: \"objectAttribute\",\n        value: coordinateAttribute\n      }\n    }\n  };\n}\nfunction booleanValue(node, scope) {\n  switch (node.type) {\n    case \"unknown\":\n      return { canBeTrue: !0, canBeFalse: !0, canBeNull: !0 };\n    case \"boolean\":\n      return node.value === !0 ? { canBeTrue: !0, canBeFalse: !1, canBeNull: !1 } : node.value === !1 ? { canBeTrue: !1, canBeFalse: !0, canBeNull: !1 } : { canBeTrue: !0, canBeFalse: !0, canBeNull: !1 };\n    case \"union\": {\n      const value = { canBeTrue: !1, canBeFalse: !1, canBeNull: !1 };\n      for (const sub of node.of) {\n        const match2 = booleanValue(sub, scope);\n        match2.canBeNull && (value.canBeNull = !0), match2.canBeTrue && (value.canBeTrue = !0), match2.canBeFalse && (value.canBeFalse = !0);\n      }\n      return value;\n    }\n    case \"inline\": {\n      const resolved = resolveInline(node, scope);\n      return booleanValue(resolved, scope);\n    }\n    case \"null\":\n    case \"string\":\n    case \"number\":\n    case \"object\":\n    case \"array\":\n      return { canBeTrue: !1, canBeFalse: !1, canBeNull: !0 };\n    default:\n      throw new Error(`unknown node type ${node.type}`);\n  }\n}\nfunction booleanOr(left, right) {\n  return left.canBeTrue && !left.canBeFalse && !left.canBeNull ? left : right.canBeTrue && !right.canBeFalse && !right.canBeNull ? right : {\n    // Either side can be true for the expression to be true\n    canBeTrue: left.canBeTrue || right.canBeTrue,\n    // Both sides must be false for the expression to be false\n    canBeFalse: left.canBeFalse && right.canBeFalse,\n    // if either side can be null, the expression can be null if the other side can't only be true\n    canBeNull: left.canBeNull || right.canBeNull\n  };\n}\nfunction booleanAnd(left, right) {\n  return left.canBeFalse && !left.canBeTrue && !left.canBeNull ? left : right.canBeFalse && !right.canBeTrue && !right.canBeNull ? right : {\n    // Both sides must be true for the expression to be true\n    canBeTrue: left.canBeTrue && right.canBeTrue,\n    // if either side can be false, the expression can be false\n    canBeFalse: left.canBeFalse || right.canBeFalse,\n    // if either side can be null, the expression can be null\n    canBeNull: left.canBeNull || right.canBeNull\n  };\n}\nfunction booleanInterpretationToTypeNode(bool) {\n  return bool.canBeTrue ? bool.canBeFalse ? bool.canBeNull ? nullUnion({ type: \"boolean\" }) : { type: \"boolean\" } : bool.canBeNull ? nullUnion({ type: \"boolean\", value: !0 }) : { type: \"boolean\", value: !0 } : bool.canBeFalse ? bool.canBeNull ? nullUnion({ type: \"boolean\", value: !1 }) : { type: \"boolean\", value: !1 } : { type: \"null\" };\n}\nconst STRING_TYPE_DATETIME = Symbol(\"groq-js.type.string_datetime\");\nfunction unionWithoutNull(unionTypeNode) {\n  return unionTypeNode.type === \"union\" ? {\n    type: \"union\",\n    of: unionTypeNode.of.filter((type) => type.type !== \"null\")\n  } : unionTypeNode;\n}\nfunction handleFuncCallNode(node, scope) {\n  switch (`${node.namespace}.${node.name}`) {\n    case \"array.compact\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => {\n        if (arg2.type === \"unknown\")\n          return nullUnion({ type: \"array\", of: { type: \"unknown\" } });\n        if (arg2.type !== \"array\")\n          return { type: \"null\" };\n        const of = mapNode(arg2.of, scope, (of2) => of2);\n        return {\n          type: \"array\",\n          of: unionWithoutNull(of)\n        };\n      });\n    }\n    case \"array.join\": {\n      const arrayArg = walk({ node: node.args[0], scope }), sepArg = walk({ node: node.args[1], scope });\n      return mapNode(\n        arrayArg,\n        scope,\n        (arrayArg2) => mapNode(sepArg, scope, (sepArg2) => arrayArg2.type === \"unknown\" || sepArg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arrayArg2.type !== \"array\" || sepArg2.type !== \"string\" ? { type: \"null\" } : mapNode(arrayArg2.of, scope, (of) => of.type === \"unknown\" ? nullUnion({ type: \"string\" }) : of.type !== \"string\" && of.type !== \"number\" && of.type !== \"boolean\" ? { type: \"null\" } : { type: \"string\" }))\n      );\n    }\n    case \"array.unique\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"array\", of: { type: \"unknown\" } }) : arg2.type !== \"array\" ? { type: \"null\" } : arg2);\n    }\n    case \"array.intersects\": {\n      const arg1 = walk({ node: node.args[0], scope }), arg2 = walk({ node: node.args[1], scope });\n      return mapNode(\n        arg1,\n        scope,\n        (arg12) => mapNode(arg2, scope, (arg22) => arg12.type !== \"array\" ? { type: \"null\" } : arg22.type !== \"array\" ? { type: \"null\" } : { type: \"boolean\" })\n      );\n    }\n    case \"global.lower\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arg2.type !== \"string\" ? { type: \"null\" } : arg2.value !== void 0 ? {\n        type: \"string\",\n        value: arg2.value.toLowerCase()\n      } : { type: \"string\" });\n    }\n    case \"global.upper\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arg2.type !== \"string\" ? { type: \"null\" } : arg2.value !== void 0 ? {\n        type: \"string\",\n        value: arg2.value.toUpperCase()\n      } : { type: \"string\" });\n    }\n    case \"dateTime.now\":\n      return { type: \"string\", [STRING_TYPE_DATETIME]: !0 };\n    case \"global.now\":\n      return { type: \"string\", [STRING_TYPE_DATETIME]: !0 };\n    case \"global.defined\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (node2) => node2.type === \"unknown\" ? { type: \"boolean\" } : { type: \"boolean\", value: node2.type !== \"null\" });\n    }\n    case \"global.path\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arg2.type === \"string\" ? { type: \"string\" } : { type: \"null\" });\n    }\n    case \"global.coalesce\": {\n      if (node.args.length === 0)\n        return { type: \"null\" };\n      const typeNodes = [];\n      let canBeNull = !0;\n      for (const arg of node.args) {\n        const argNode = optimizeUnions(walk({ node: arg, scope })), allNull = argNode.type === \"null\" || argNode.type === \"union\" && argNode.of.every((t) => t.type === \"null\");\n        if (canBeNull = allNull || argNode.type === \"unknown\" || argNode.type === \"union\" && argNode.of.some((t) => t.type === \"null\" || t.type === \"unknown\"), allNull || typeNodes.push(unionWithoutNull(argNode)), !canBeNull)\n          break;\n      }\n      return canBeNull && typeNodes.push({ type: \"null\" }), {\n        type: \"union\",\n        of: typeNodes\n      };\n    }\n    case \"global.count\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : arg2.type === \"array\" ? { type: \"number\" } : { type: \"null\" });\n    }\n    case \"global.dateTime\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"string\", [STRING_TYPE_DATETIME]: !0 }) : arg2.type === \"string\" ? nullUnion({ type: \"string\", [STRING_TYPE_DATETIME]: !0 }) : { type: \"null\" });\n    }\n    case \"global.length\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (arg2) => arg2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : arg2.type === \"array\" || arg2.type === \"string\" ? { type: \"number\" } : { type: \"null\" });\n    }\n    case \"global.references\":\n      return { type: \"boolean\" };\n    case \"global.round\": {\n      const numNode = walk({ node: node.args[0], scope });\n      return mapNode(numNode, scope, (num) => {\n        if (num.type === \"unknown\")\n          return nullUnion({ type: \"number\" });\n        if (num.type !== \"number\")\n          return { type: \"null\" };\n        if (node.args.length === 2) {\n          const precisionNode = walk({ node: node.args[1], scope });\n          return mapNode(precisionNode, scope, (precision) => precision.type === \"unknown\" ? nullUnion({ type: \"number\" }) : precision.type !== \"number\" ? { type: \"null\" } : { type: \"number\" });\n        }\n        return { type: \"number\" };\n      });\n    }\n    case \"global.string\": {\n      const arg = walk({ node: node.args[0], scope });\n      return mapNode(arg, scope, (node2) => node2.type === \"unknown\" ? nullUnion({ type: \"string\" }) : node2.type === \"string\" || node2.type === \"number\" || node2.type === \"boolean\" ? node2.value ? {\n        type: \"string\",\n        value: node2.value.toString()\n      } : {\n        type: \"string\"\n      } : { type: \"null\" });\n    }\n    case \"math.sum\": {\n      const values = walk({ node: node.args[0], scope });\n      return mapNode(values, scope, (node2) => node2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node2.type !== \"array\" ? { type: \"null\" } : mapNode(node2.of, scope, (node3) => node3.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node3.type === \"number\" || node3.type === \"null\" ? { type: \"number\" } : { type: \"null\" }));\n    }\n    case \"math.avg\": {\n      const values = walk({ node: node.args[0], scope });\n      return mapNode(values, scope, (node2) => node2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node2.type !== \"array\" ? { type: \"null\" } : mapNode(node2.of, scope, (node3) => node3.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node3.type === \"number\" ? { type: \"number\" } : { type: \"null\" }));\n    }\n    case \"math.max\":\n    case \"math.min\": {\n      const values = walk({ node: node.args[0], scope });\n      return mapNode(values, scope, (node2) => node2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node2.type !== \"array\" ? { type: \"null\" } : mapNode(node2.of, scope, (node3) => node3.type === \"unknown\" ? nullUnion({ type: \"number\" }) : node3.type === \"number\" ? node3 : { type: \"null\" }));\n    }\n    case \"pt.text\":\n      return node.args.length === 0 ? { type: \"null\" } : {\n        type: \"string\"\n      };\n    case \"string.startsWith\": {\n      const strTypeNode = walk({ node: node.args[0], scope }), prefixTypeNode = walk({ node: node.args[1], scope });\n      return mapNode(strTypeNode, scope, (strNode) => mapNode(prefixTypeNode, scope, (prefixNode) => strNode.type === \"unknown\" || prefixNode.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : strNode.type !== \"string\" || prefixNode.type !== \"string\" ? { type: \"null\" } : { type: \"boolean\" }));\n    }\n    case \"string.split\": {\n      const strTypeNode = walk({ node: node.args[0], scope }), sepTypeNode = walk({ node: node.args[1], scope });\n      return mapNode(strTypeNode, scope, (strNode) => mapNode(sepTypeNode, scope, (sepNode) => strNode.type === \"unknown\" || sepNode.type === \"unknown\" ? nullUnion({ type: \"array\", of: { type: \"string\" } }) : strNode.type !== \"string\" || sepNode.type !== \"string\" ? { type: \"null\" } : { type: \"array\", of: { type: \"string\" } }));\n    }\n    case \"geo.latLng\": {\n      const latTypeNode = walk({ node: node.args[0], scope }), lngTypeNode = walk({ node: node.args[1], scope });\n      return mapNode(latTypeNode, scope, (latNode) => mapNode(lngTypeNode, scope, (lngNode) => latNode.type == \"unknown\" || lngNode.type == \"unknown\" ? nullUnion(createGeoJson()) : latNode.type !== \"number\" || lngNode.type !== \"number\" ? { type: \"null\" } : nullUnion(createGeoJson())));\n    }\n    case \"geo.contains\":\n      return nullUnion({ type: \"boolean\" });\n    case \"geo.intersects\":\n      return nullUnion({ type: \"boolean\" });\n    case \"geo.distance\":\n      return nullUnion({ type: \"number\" });\n    case \"sanity.versionOf\": {\n      const typeNode = walk({ node: node.args[0], scope });\n      return mapNode(typeNode, scope, (typeNode2) => typeNode2.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : typeNode2.type !== \"string\" ? { type: \"null\" } : { type: \"boolean\" });\n    }\n    case \"sanity.partOfRelease\": {\n      const typeNode = walk({ node: node.args[0], scope });\n      return mapNode(typeNode, scope, (typeNode2) => typeNode2.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : typeNode2.type !== \"string\" ? { type: \"null\" } : { type: \"boolean\" });\n    }\n    case \"documents.get\": {\n      const typeNode = walk({ node: node.args[0], scope });\n      return mapNode(typeNode, scope, (typeNode2) => typeNode2.type === \"unknown\" ? typeNode2 : typeNode2.type !== \"object\" ? { type: \"null\" } : { type: \"unknown\" });\n    }\n    case \"documents.incomingRefCount\":\n      return { type: \"number\" };\n    case \"documents.incomingGlobalDocumentReferenceCount\":\n      return { type: \"number\" };\n    case \"media.aspect\":\n      return mapNode(walk({ node: node.args[0], scope }), scope, (fieldNode) => fieldNode.type === \"null\" ? { type: \"null\" } : mapNode(walk({ node: node.args[1], scope }), scope, (aspectNode) => aspectNode.type !== \"string\" ? { type: \"null\" } : { type: \"unknown\" }));\n    default:\n      return { type: \"unknown\" };\n  }\n}\nfunction match(left, right) {\n  let tokens = [], patterns = [];\n  if (left.type === \"string\") {\n    if (left.value === void 0)\n      return;\n    tokens = tokens.concat(matchTokenize(left.value));\n  }\n  if (left.type === \"array\") {\n    if (left.of.type === \"unknown\")\n      return;\n    if (left.of.type === \"string\") {\n      if (left.of.value === void 0)\n        return;\n      tokens = tokens.concat(matchTokenize(left.of.value));\n    }\n    if (left.of.type === \"union\")\n      for (const node of left.of.of)\n        node.type === \"string\" && node.value !== void 0 && (tokens = tokens.concat(matchTokenize(node.value)));\n  }\n  if (right.type === \"string\") {\n    if (right.value === void 0)\n      return;\n    patterns = patterns.concat(matchAnalyzePattern(right.value));\n  }\n  if (right.type === \"array\") {\n    if (right.of.type === \"unknown\")\n      return;\n    if (right.of.type === \"string\") {\n      if (right.of.value === void 0)\n        return;\n      patterns = patterns.concat(matchAnalyzePattern(right.of.value));\n    }\n    if (right.of.type === \"union\")\n      for (const node of right.of.of) {\n        if (node.type === \"string\") {\n          if (node.value === void 0)\n            return;\n          patterns = patterns.concat(matchAnalyzePattern(node.value));\n        }\n        if (node.type !== \"string\")\n          return !1;\n      }\n  }\n  return matchText(tokens, patterns);\n}\nconst $trace$1 = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:scope:trace\");\n$trace$1.log = console.log.bind(console);\nclass Context {\n  schema;\n  constructor(schema) {\n    this.schema = schema;\n  }\n  lookupRef(refTo) {\n    for (const val of this.schema)\n      if (val.type === \"document\" && val.name === refTo)\n        return {\n          type: \"object\",\n          attributes: val.attributes\n        };\n    return { type: \"null\" };\n  }\n  lookupTypeDeclaration(alias) {\n    for (const val of this.schema)\n      if (val.type === \"type\" && val.name === alias.name)\n        return val.value;\n    return { type: \"null\" };\n  }\n}\nclass Scope2 {\n  value;\n  parent;\n  context;\n  isHidden;\n  constructor(value, parent, context) {\n    this.value = { type: \"union\", of: value }, this.parent = parent, this.context = context || parent?.context || new Context([]), this.isHidden = !1;\n  }\n  createNested(value) {\n    return this.isHidden ? new Scope2(value, this.parent, this.context) : new Scope2(value, this, this.context);\n  }\n  createHidden(value) {\n    const result = this.createNested(value);\n    return result.isHidden = !0, result;\n  }\n}\nconst $trace = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:evaluate:trace\");\n$trace.log = console.log.bind(console);\nconst $debug = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:evaluate:debug\");\n$debug.log = console.log.bind(console);\nconst $warn = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:evaluate:warn\");\nfunction typeEvaluate(ast, schema) {\n  $debug(\"evaluateQueryType.ast %O\", ast), $debug(\"evaluateQueryType.schema %O\", schema);\n  const parsed = walk({\n    node: ast,\n    scope: new Scope2([], void 0, new Context(schema))\n  });\n  $trace(\"evaluateQueryType.parsed %O\", parsed);\n  const optimized = optimizeUnions(parsed);\n  return $debug(\"evaluateQueryType.optimized %O\", optimized), optimized;\n}\nfunction mapDeref(node, scope) {\n  return mapNode(node, scope, (base) => {\n    if (base.type === \"array\")\n      return {\n        type: \"array\",\n        of: mapDeref(base.of, scope)\n      };\n    if (base.type === \"object\") {\n      if (base.dereferencesTo !== void 0)\n        return scope.context.lookupRef(base.dereferencesTo);\n      if (base.rest !== void 0)\n        return mapDeref(resolveInline(base.rest, scope), scope);\n    }\n    return { type: \"null\" };\n  });\n}\nfunction handleDerefNode(node, scope) {\n  $trace(\"deref.node %O\", node);\n  const derefedNode = mapDeref(walk({ node: node.base, scope }), scope);\n  return $trace(\"deref.derefedNode %O\", derefedNode), derefedNode;\n}\nfunction handleObjectSplatNode(attr, scope) {\n  const value = walk({ node: attr.value, scope });\n  return $trace(\"object.splat.value %O\", value), mapNode(value, scope, (node) => {\n    if (node.type === \"unknown\")\n      return { type: \"unknown\" };\n    if (node.type !== \"object\")\n      return { type: \"object\", attributes: {} };\n    const attributes = {};\n    for (const name in node.attributes)\n      node.attributes.hasOwnProperty(name) && (attributes[name] = node.attributes[name]);\n    if (node.rest !== void 0) {\n      const resolvedRest = resolveInline(node.rest, scope);\n      if (resolvedRest.type === \"unknown\")\n        return { type: \"unknown\" };\n      if (resolvedRest.type !== \"object\")\n        return { type: \"null\" };\n      for (const name in resolvedRest.attributes)\n        resolvedRest.attributes.hasOwnProperty(name) && (attributes[name] = resolvedRest.attributes[name]);\n    }\n    return { type: \"object\", attributes };\n  });\n}\nfunction handleObjectNode(node, scope) {\n  if ($trace(\"object.node %O\", node), node.attributes.length === 0)\n    return {\n      type: \"object\",\n      attributes: {}\n    };\n  const objectAttributes = [], splatVariants = [], conditionalVariants = [];\n  for (const [idx, attr] of node.attributes.entries()) {\n    if (attr.type === \"ObjectAttributeValue\") {\n      const attributeNode = walk({ node: attr.value, scope });\n      objectAttributes.push([\n        idx,\n        attr.name,\n        {\n          type: \"objectAttribute\",\n          value: attributeNode\n        }\n      ]);\n      continue;\n    }\n    if (attr.type === \"ObjectSplat\") {\n      const attributeNode = handleObjectSplatNode(attr, scope);\n      switch ($trace(\"object.splat.result %O\", attributeNode), attributeNode.type) {\n        case \"object\": {\n          splatVariants.push([idx, attributeNode]);\n          continue;\n        }\n        case \"union\": {\n          for (const node2 of attributeNode.of)\n            if (node2.type === \"unknown\")\n              return node2;\n          splatVariants.push([idx, attributeNode]);\n          continue;\n        }\n        default:\n          return { type: \"unknown\" };\n      }\n    }\n    if (attr.type === \"ObjectConditionalSplat\") {\n      const condition = booleanValue(walk({ node: attr.condition, scope }), scope);\n      if ($trace(\"object.conditional.splat.condition %O\", condition), condition.canBeTrue === !1)\n        continue;\n      const attributeNode = handleObjectSplatNode(attr, scope);\n      if ($trace(\"object.conditional.splat.result %O\", attributeNode), condition.canBeFalse === !1 && condition.canBeNull === !1)\n        switch (attributeNode.type) {\n          case \"object\": {\n            splatVariants.push([idx, attributeNode]);\n            continue;\n          }\n          case \"union\": {\n            for (const node2 of attributeNode.of)\n              if (node2.type !== \"object\")\n                return { type: \"unknown\" };\n            splatVariants.push([idx, attributeNode]);\n            continue;\n          }\n          default:\n            return { type: \"unknown\" };\n        }\n      const variant = mapNode(attributeNode, scope, (attributeNode2) => ($trace(\"object.conditional.splat.result.concrete %O\", attributeNode2), attributeNode2.type !== \"object\" ? { type: \"unknown\" } : {\n        type: \"object\",\n        attributes: attributeNode2.attributes\n      }));\n      if (variant.type === \"union\") {\n        for (const node2 of variant.of)\n          if (node2.type !== \"object\")\n            return { type: \"unknown\" };\n        variant.of.push({ type: \"object\", attributes: {} }), conditionalVariants.push([idx, variant]);\n        continue;\n      }\n      if (variant.type !== \"object\")\n        return { type: \"unknown\" };\n      conditionalVariants.push([\n        idx,\n        {\n          type: \"union\",\n          of: [{ type: \"object\", attributes: {} }, variant]\n        }\n      ]);\n      continue;\n    }\n    throw new Error(`Unknown object attribute type: ${attr.type}`);\n  }\n  const guaranteedAttributes = [];\n  guaranteedAttributes.push(...objectAttributes);\n  for (const [idx, splatNode] of splatVariants) {\n    if (splatNode.type === \"object\") {\n      for (const name in splatNode.attributes) {\n        if (!splatNode.attributes.hasOwnProperty(name))\n          continue;\n        const attribute = splatNode.attributes[name];\n        guaranteedAttributes.push([idx, name, attribute]);\n      }\n      continue;\n    }\n    conditionalVariants.push([idx, splatNode]);\n  }\n  if (guaranteedAttributes.sort(([a], [b]) => a - b), conditionalVariants.length === 0)\n    return {\n      type: \"object\",\n      attributes: Object.fromEntries(\n        guaranteedAttributes.map(([, name, attribute]) => [name, attribute])\n      )\n    };\n  const matrix = [];\n  for (const [unionIdx, union] of conditionalVariants) {\n    const unionGuaranteedBefore = [], unionGuaranteedAfter = [];\n    for (const [guaranteedIndex, name, attribute] of guaranteedAttributes)\n      guaranteedIndex < unionIdx && unionGuaranteedBefore.push([guaranteedIndex, name, attribute]), guaranteedIndex > unionIdx && unionGuaranteedAfter.push([guaranteedIndex, name, attribute]);\n    const allVariantsAttributes = [];\n    for (const [conditionalVariantIdx, otherUnion] of conditionalVariants) {\n      const variantAttributes = [];\n      for (const node2 of otherUnion.of)\n        variantAttributes.push(node2.attributes);\n      allVariantsAttributes.push([conditionalVariantIdx, variantAttributes]);\n    }\n    for (const node2 of union.of) {\n      matrix.push({\n        type: \"object\",\n        attributes: {\n          ...Object.fromEntries(\n            unionGuaranteedBefore.map(([, name, attribute]) => [name, attribute])\n          ),\n          ...node2.attributes,\n          ...Object.fromEntries(\n            unionGuaranteedAfter.map(([, name, attribute]) => [name, attribute])\n          )\n        }\n      });\n      for (const [outerIdx, outerAttributes] of allVariantsAttributes)\n        for (const outer of outerAttributes)\n          for (const [innerIdx, innerAttributes] of allVariantsAttributes)\n            if (outerIdx !== innerIdx)\n              for (const inner of innerAttributes) {\n                const _before = [...unionGuaranteedBefore], _after = [...unionGuaranteedAfter];\n                for (const name in outer)\n                  outer.hasOwnProperty(name) && outerIdx !== unionIdx && (outerIdx < unionIdx && _before.push([outerIdx, name, outer[name]]), outerIdx > unionIdx && _after.push([outerIdx, name, outer[name]]));\n                for (const name in inner)\n                  inner.hasOwnProperty(name) && outerIdx !== unionIdx && (innerIdx < unionIdx && _before.push([innerIdx, name, inner[name]]), innerIdx > unionIdx && _after.push([innerIdx, name, inner[name]]));\n                _before.sort(([a], [b]) => a - b), _after.sort(([a], [b]) => a - b);\n                const before = Object.fromEntries(\n                  _before.map(([, name, attribute]) => [name, attribute])\n                ), after = Object.fromEntries(\n                  _after.map(([, name, attribute]) => [name, attribute])\n                );\n                matrix.push({\n                  type: \"object\",\n                  attributes: {\n                    ...before,\n                    ...node2.attributes,\n                    ...after\n                  }\n                });\n              }\n    }\n  }\n  return optimizeUnions({\n    type: \"union\",\n    of: matrix\n  });\n}\nfunction handleOpCallNode(node, scope) {\n  $trace(\"opcall.node %O\", node);\n  const lhs = walk({ node: node.left, scope }), rhs = walk({ node: node.right, scope });\n  return mapNode(\n    lhs,\n    scope,\n    (left) => (\n      // eslint-disable-next-line complexity, max-statements\n      mapNode(rhs, scope, (right) => {\n        switch ($trace('opcall.node.concrete \"%s\" %O', node.op, { left, right }), node.op) {\n          case \"==\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? { type: \"boolean\" } : left.type !== right.type ? {\n              type: \"boolean\",\n              value: !1\n            } : left.type === \"null\" ? {\n              type: \"boolean\",\n              value: !0\n            } : !isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right) ? {\n              type: \"boolean\",\n              value: !1\n            } : {\n              type: \"boolean\",\n              value: evaluateComparison(node.op, left, right)\n            };\n          case \"!=\": {\n            if (left.type === \"unknown\" || right.type === \"unknown\")\n              return { type: \"boolean\" };\n            if (left.type !== right.type)\n              return {\n                type: \"boolean\",\n                value: !0\n              };\n            if (left.type === \"null\")\n              return {\n                type: \"boolean\",\n                value: !1\n              };\n            if (!isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right))\n              return {\n                type: \"boolean\",\n                value: !0\n              };\n            let value = evaluateComparison(\"==\", left, right);\n            return value !== void 0 && (value = !value), {\n              type: \"boolean\",\n              value\n            };\n          }\n          case \">\":\n          case \">=\":\n          case \"<\":\n          case \"<=\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : left.type !== right.type ? { type: \"null\" } : !isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right) ? { type: \"null\" } : {\n              type: \"boolean\",\n              value: evaluateComparison(node.op, left, right)\n            };\n          case \"in\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : right.type !== \"array\" ? isFuncCall(node.right, \"global::path\") ? { type: \"boolean\" } : { type: \"null\" } : !isPrimitiveTypeNode(left) && left.type !== \"null\" ? {\n              type: \"boolean\",\n              value: !1\n            } : mapNode(right.of, scope, (arrayTypeNode) => arrayTypeNode.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : left.type === \"null\" ? {\n              type: \"boolean\",\n              value: arrayTypeNode.type === \"null\"\n            } : left.value === void 0 ? {\n              type: \"boolean\"\n            } : isPrimitiveTypeNode(arrayTypeNode) ? arrayTypeNode.value === void 0 ? {\n              type: \"boolean\"\n            } : {\n              type: \"boolean\",\n              value: left.value === arrayTypeNode.value\n            } : {\n              type: \"boolean\",\n              value: !1\n            });\n          case \"match\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? { type: \"boolean\" } : {\n              type: \"boolean\",\n              value: match(left, right)\n            };\n          case \"+\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? { type: \"unknown\" } : left.type === \"string\" && right.type === \"string\" ? {\n              type: \"string\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value + right.value : void 0\n            } : left.type === \"string\" && left[STRING_TYPE_DATETIME] && right.type === \"number\" ? { type: \"string\", [STRING_TYPE_DATETIME]: !0 } : left.type === \"number\" && right.type === \"string\" && right[STRING_TYPE_DATETIME] ? { type: \"string\", [STRING_TYPE_DATETIME]: !0 } : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value + right.value : void 0\n            } : left.type === \"array\" && right.type === \"array\" ? {\n              type: \"array\",\n              of: {\n                type: \"union\",\n                of: [left.of, right.of]\n              }\n            } : left.type === \"object\" && right.type === \"object\" ? {\n              type: \"object\",\n              attributes: { ...left.attributes, ...right.attributes }\n            } : { type: \"null\" };\n          case \"-\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"number\" }) : left.type === \"string\" && left[STRING_TYPE_DATETIME] && right.type === \"number\" ? { type: \"string\", [STRING_TYPE_DATETIME]: !0 } : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value - right.value : void 0\n            } : { type: \"null\" };\n          case \"*\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"number\" }) : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value * right.value : void 0\n            } : { type: \"null\" };\n          case \"/\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"number\" }) : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value / right.value : void 0\n            } : { type: \"null\" };\n          case \"**\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"number\" }) : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value ** right.value : void 0\n            } : { type: \"null\" };\n          case \"%\":\n            return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({ type: \"number\" }) : left.type === \"number\" && right.type === \"number\" ? {\n              type: \"number\",\n              value: left.value !== void 0 && right.value !== void 0 ? left.value % right.value : void 0\n            } : { type: \"null\" };\n          default:\n            return {\n              type: \"unknown\"\n            };\n        }\n      })\n    )\n  );\n}\nfunction handleSelectNode(node, scope) {\n  const values = [];\n  let guaranteed = !1;\n  for (const alternative of node.alternatives) {\n    const conditionValue = walk({ node: alternative.condition, scope }), conditionScope = resolveFilter(alternative.condition, scope);\n    conditionScope.type === \"union\" && conditionScope.of.length > 0 && values.push(walk({ node: alternative.value, scope: scope.createHidden(conditionScope.of) })), conditionValue.type === \"boolean\" && conditionValue.value === !0 && (guaranteed = !0);\n  }\n  return node.fallback && !guaranteed && values.push(walk({ node: node.fallback, scope })), values.length === 0 ? { type: \"null\" } : {\n    type: \"union\",\n    of: values\n  };\n}\nfunction handleArrayCoerceNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return $trace(\"arrayCoerce.base %O\", base), mapArray(base, scope, (base2) => base2);\n}\nfunction handleFlatMap(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return mapArray(base, scope, (base2) => {\n    const inner = walk({ node: node.expr, scope: scope.createHidden([base2.of]) });\n    return mapNode(\n      inner,\n      scope,\n      (inner2) => inner2.type === \"array\" ? inner2 : { type: \"array\", of: inner2 },\n      (nodes) => {\n        const inner2 = [];\n        for (const node2 of nodes) {\n          if (node2.type === \"unknown\") return { type: \"array\", of: node2 };\n          if (node2.type !== \"array\") throw new Error(`Unexpected type: ${node2.type}`);\n          inner2.push(node2.of);\n        }\n        return {\n          type: \"array\",\n          of: optimizeUnions({ type: \"union\", of: inner2 })\n        };\n      }\n    );\n  });\n}\nfunction handleMap(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return $trace(\"map.base %O\", base), mapArray(base, scope, (base2) => ({\n    type: \"array\",\n    of: walk({ node: node.expr, scope: scope.createHidden([base2.of]) })\n  }));\n}\nfunction handleProjectionNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return $trace(\"projection.base %O\", base), mapObject(\n    base,\n    scope,\n    (base2) => walk({ node: node.expr, scope: scope.createNested([base2]) })\n  );\n}\nfunction createFilterScope(base, scope) {\n  return base.type === \"array\" ? base.of.type === \"union\" ? scope.createNested(base.of.of) : scope.createNested([base.of]) : scope.createNested([base]);\n}\nfunction handleFilterNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return $trace(\"filter.base %O\", base), mapNode(base, scope, (base2) => {\n    if ($trace(\"filter.resolving %O\", base2), base2.type === \"null\")\n      return base2;\n    const resolved = resolveFilter(node.expr, createFilterScope(base2, scope));\n    return $trace(\"filter.resolved %O\", resolved), {\n      type: \"array\",\n      of: resolved\n    };\n  });\n}\nfunction handleAccessAttributeNode(node, scope) {\n  let attributeBase = scope.value;\n  return node.base && (attributeBase = walk({ node: node.base, scope })), $trace(\"accessAttribute.base %s %O\", node.name, attributeBase), handleAccessAttributeBase(attributeBase, node.name, scope);\n}\nfunction handleAccessAttributeBase(base, name, scope) {\n  return mapObject(base, scope, (base2) => {\n    $trace('Looking for attribute \"%s\" in object %O', name, base2);\n    const attribute = base2.attributes[name];\n    return attribute !== void 0 ? ($debug(`accessAttribute.attribute found ${name} %O`, attribute), attribute.optional ? nullUnion(attribute.value) : attribute.value) : base2.rest ? handleAccessAttributeBase(base2.rest, name, scope) : ($warn(`attribute \"${name}\" not found in object`), { type: \"null\" });\n  });\n}\nfunction handleAccessElementNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return $trace(\"accessElement.base %O\", base), mapArray(base, scope, (base2) => nullUnion(base2.of));\n}\nfunction handleArrayNode(node, scope) {\n  const of = [];\n  for (const el of node.elements) {\n    const node2 = walk({ node: el.value, scope });\n    if (el.isSplat) {\n      if (node2.type !== \"array\")\n        continue;\n      of.push(node2.of);\n    } else\n      of.push(node2);\n  }\n  return {\n    type: \"array\",\n    of: {\n      type: \"union\",\n      of\n    }\n  };\n}\nfunction handleValueNode(node, scope) {\n  if (node.value === null)\n    return { type: \"null\" };\n  switch (typeof node.value) {\n    case \"string\":\n      return {\n        type: \"string\",\n        value: node.value\n      };\n    case \"number\":\n      return {\n        type: \"number\",\n        value: node.value\n      };\n    case \"boolean\":\n      return {\n        type: \"boolean\",\n        value: node.value\n      };\n    case \"object\":\n      return node.value === null ? { type: \"null\" } : Array.isArray(node.value) ? {\n        type: \"array\",\n        of: {\n          type: \"union\",\n          of: node.value.map((value) => walk({ node: { type: \"Value\", value }, scope }))\n        }\n      } : {\n        type: \"object\",\n        attributes: Object.fromEntries(\n          Object.entries(node.value).map(([key, value]) => [\n            key,\n            {\n              type: \"objectAttribute\",\n              value: walk({ node: { type: \"Value\", value }, scope })\n            }\n          ])\n        )\n      };\n    default:\n      return { type: \"unknown\" };\n  }\n}\nfunction handleSlice(node, scope) {\n  $trace(\"slice.node %O\", node);\n  const base = walk({ node: node.base, scope });\n  return mapArray(base, scope, (base2) => base2);\n}\nfunction handleParentNode({ n }, scope) {\n  $trace(\"handle.parent.currentScope %d %O\", n, scope);\n  let current = scope;\n  for (let i = 0; i < n; i++) {\n    for (; current?.isHidden; )\n      current = current.parent;\n    current = current?.parent;\n  }\n  return $trace(\"handle.parent.newScope %d %O\", n, current), current ? current.value.of.length === 0 ? { type: \"null\" } : current.value : { type: \"null\" };\n}\nfunction handleNotNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return mapNode(base, scope, (base2) => base2.type === \"unknown\" ? nullUnion({ type: \"boolean\" }) : base2.type === \"boolean\" ? base2.value !== void 0 ? { type: \"boolean\", value: base2.value === !1 } : { type: \"boolean\" } : { type: \"null\" });\n}\nfunction handleNegNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return mapNode(base, scope, (base2) => base2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : base2.type !== \"number\" ? { type: \"null\" } : base2.value !== void 0 ? { type: \"number\", value: -base2.value } : base2);\n}\nfunction handlePosNode(node, scope) {\n  const base = walk({ node: node.base, scope });\n  return mapNode(base, scope, (base2) => base2.type === \"unknown\" ? nullUnion({ type: \"number\" }) : base2.type !== \"number\" ? { type: \"null\" } : base2);\n}\nfunction handleEverythingNode(_, scope) {\n  return {\n    type: \"array\",\n    of: {\n      type: \"union\",\n      of: scope.context.schema.filter((obj) => obj.type === \"document\").map((doc) => ({\n        type: \"object\",\n        attributes: doc.attributes\n      }))\n    }\n  };\n}\nfunction handleAndNode(node, scope) {\n  const left = walk({ node: node.left, scope }), right = walk({ node: node.right, scope });\n  return mapNode(\n    left,\n    scope,\n    (lhs) => mapNode(right, scope, (rhs) => {\n      const value = booleanAnd(booleanValue(lhs, scope), booleanValue(rhs, scope));\n      return booleanInterpretationToTypeNode(value);\n    })\n  );\n}\nfunction handleOrNode(node, scope) {\n  const left = walk({ node: node.left, scope }), right = walk({ node: node.right, scope });\n  return mapNode(\n    left,\n    scope,\n    (lhs) => mapNode(right, scope, (rhs) => {\n      const value = booleanOr(booleanValue(lhs, scope), booleanValue(rhs, scope));\n      return booleanInterpretationToTypeNode(value);\n    })\n  );\n}\nconst OVERRIDE_TYPE_SYMBOL = Symbol(\"groq-js.type\");\nfunction walk({ node, scope }) {\n  if (OVERRIDE_TYPE_SYMBOL in node)\n    return node[OVERRIDE_TYPE_SYMBOL];\n  switch (node.type) {\n    // Filtering, traversal & projections\n    case \"Map\":\n      return handleMap(node, scope);\n    case \"Projection\":\n      return handleProjectionNode(node, scope);\n    case \"Filter\":\n      return handleFilterNode(node, scope);\n    case \"AccessAttribute\":\n      return optimizeUnions(handleAccessAttributeNode(node, scope));\n    case \"AccessElement\":\n      return handleAccessElementNode(node, scope);\n    case \"ArrayCoerce\":\n      return handleArrayCoerceNode(node, scope);\n    case \"FlatMap\":\n      return handleFlatMap(node, scope);\n    // Operations\n    case \"OpCall\":\n      return handleOpCallNode(node, scope);\n    case \"And\":\n      return handleAndNode(node, scope);\n    case \"Or\":\n      return handleOrNode(node, scope);\n    case \"Select\":\n      return handleSelectNode(node, scope);\n    case \"PipeFuncCall\":\n      return walk({ node: node.base, scope });\n    // Values\n    case \"Deref\":\n      return handleDerefNode(node, scope);\n    case \"Object\":\n      return handleObjectNode(node, scope);\n    case \"Value\":\n      return handleValueNode(node, scope);\n    case \"Array\":\n      return handleArrayNode(node, scope);\n    // Special cases\n    case \"Everything\":\n      return handleEverythingNode(node, scope);\n    case \"This\":\n      return $trace(\"this %O\", scope.value), scope.value;\n    case \"Parent\":\n      return handleParentNode(node, scope);\n    case \"FuncCall\":\n      return handleFuncCallNode(node, scope);\n    case \"Group\":\n      return walk({ node: node.base, scope });\n    case \"Not\":\n      return handleNotNode(node, scope);\n    case \"Parameter\":\n      return {\n        type: \"unknown\"\n      };\n    case \"Slice\":\n      return handleSlice(node, scope);\n    case \"Neg\":\n      return handleNegNode(node, scope);\n    case \"Pos\":\n      return handlePosNode(node, scope);\n    // everything else\n    case \"Asc\":\n    case \"Desc\":\n    case \"Context\":\n    case \"Tuple\":\n    case \"SelectorFuncCall\":\n    case \"SelectorNested\":\n    case \"InRange\":\n      return { type: \"unknown\" };\n    default:\n      throw new Error(`unknown node type ${node.type}`);\n  }\n}\nfunction isPrimitiveTypeNode(node) {\n  return node.type === \"string\" || node.type === \"number\" || node.type === \"boolean\";\n}\nfunction evaluateComparison(opcall, left, right) {\n  if (!(left.value === void 0 || right.value === void 0))\n    switch (opcall) {\n      case \"==\":\n        return left.value === right.value;\n      case \"<\":\n        return left.value < right.value;\n      case \"<=\":\n        return left.value <= right.value;\n      case \">\":\n        return left.value > right.value;\n      case \">=\":\n        return left.value >= right.value;\n      default:\n        throw new Error(`unknown comparison operator ${opcall}`);\n    }\n}\nfunction resolveFilter(expr, scope) {\n  $trace(\"resolveFilter.expr %O\", expr);\n  const filtered = scope.value.of.filter((node) => {\n    const subScope = scope.createHidden([node]), cond = walk({ node: expr, scope: subScope });\n    return booleanValue(cond, subScope).canBeTrue;\n  });\n  return $trace(\n    `resolveFilter ${expr.type === \"OpCall\" ? `${expr.type}/${expr.op}` : expr.type} %O`,\n    filtered\n  ), { type: \"union\", of: filtered };\n}\nfunction mapArray(node, scope, mapper) {\n  return mapNode(node, scope, (base) => base.type === \"unknown\" ? base : base.type === \"array\" ? mapper(base) : { type: \"null\" });\n}\nfunction mapObject(node, scope, mapper) {\n  return mapNode(node, scope, (base) => base.type === \"unknown\" ? base : base.type === \"object\" ? mapper(base) : { type: \"null\" });\n}\n\n//# sourceMappingURL=1.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwwVkFBMFYsNkJBQTZCO0FBQ3ZYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3Q0FBd0M7QUFDdEQ7QUFDQTtBQUNB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QUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxRQUFRLFdBQVcsTUFBTTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLFVBQVU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhLHNDQUFzQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDQUFpQyw2QkFBNkIsc0JBQXNCLDJCQUEyQix1QkFBdUIsMkJBQTJCO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFVBQVU7QUFDMUQ7QUFDQTtBQUNBLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWEsbUNBQW1DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQ0FBc0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNDQUFzQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFVBQVUsSUFBSSxLQUFLO0FBQ3JFO0FBQ0EscUtBQXFLO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsVUFBVTtBQUNuRTtBQUNBO0FBQ0Esd0RBQXdELEtBQUs7QUFDN0Q7QUFDQSx3REFBd0QsS0FBSztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFVBQVU7QUFDbkU7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyQ0FBMkM7QUFDOUU7QUFDQSxZQUFZO0FBQ1osbUNBQW1DLDRDQUE0QztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELEtBQUs7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3RkFBd0YsZ0RBQWdELHFGQUFxRixpREFBaUQ7QUFDOVE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3REFBd0QscUNBQXFDO0FBQzdGLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbURBQW1ELHFDQUFxQztBQUN4RixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDRDQUE0QztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbURBQW1ELDJCQUEyQjtBQUM5RTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWEsc0NBQXNDO0FBQ25EO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsd0RBQXdELFdBQVc7QUFDekgsVUFBVTtBQUNWO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsVUFBVTtBQUNWO0FBQ0E7QUFDQSwwRUFBMEUsY0FBYztBQUN4RixtQkFBbUI7QUFDbkIsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYSxrQ0FBa0M7QUFDL0M7QUFDQSwwQkFBMEI7QUFDMUIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsVUFBVTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUssZUFBZSxNQUFNLFFBQVEsTUFBTTtBQUM3RjtBQUNBLElBQUk7QUFDSiwwRUFBMEUsS0FBSztBQUMvRTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZUFBZTtBQUM1RTtBQUNBO0FBQ0EsK0RBQStELGdCQUFnQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG1GQUFtRixVQUFVO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxTQUFTLEVBQUUsY0FBYyxPQUFPLE9BQU87QUFDM0Y7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixVQUFVLElBQUksS0FBSztBQUN4RztBQUNBLCtFQUErRSxXQUFXO0FBQzFGO0FBQ0EsYUFBYSx3Q0FBd0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0lBQXNJO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBLFFBQVEsVUFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsV0FBVyxHQUFHLFlBQVksUUFBUSxXQUFXO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVcsR0FBRyxvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBLDhEQUE4RCxXQUFXLElBQUk7QUFDN0UsNkJBQTZCLElBQUksR0FBRyx1QkFBdUIsR0FBRyw2Q0FBNkM7QUFDM0csa0JBQWtCLFFBQVEscUJBQXFCLEdBQUcsK0NBQStDO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxXQUFXLEdBQUcsZ0NBQWdDO0FBQzVGO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVyxHQUFHLFdBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGNBQWMsb0JBQW9CLGNBQWM7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRiwwQkFBMEI7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsZUFBZSxJQUFJLFVBQVU7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLG1DQUFtQywrQ0FBK0Msd0JBQXdCLCtDQUErQyxJQUFJO0FBQzdKO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsaUJBQWlCLE1BQU0sa0JBQWtCLCtCQUErQiw0QkFBNEIsTUFBTSw2QkFBNkIsaURBQWlELDRCQUE0QixNQUFNLDZCQUE2QixJQUFJO0FBQ3BVO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsYUFBYSxlQUFlLEdBQUcsVUFBVTtBQUN6QztBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBLDZCQUE2QixxQkFBcUIsbUJBQW1CO0FBQ3JFO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDhCQUE4QiwyQkFBMkIsbUJBQW1CLDJCQUEyQjtBQUN2RztBQUNBO0FBQ0E7QUFDQSxvSUFBb0ksZ0JBQWdCLGdFQUFnRSxlQUFlLDJFQUEyRSxnQkFBZ0IsOEVBQThFLGVBQWUsSUFBSSxnQkFBZ0I7QUFDL2E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJCQUEyQjtBQUNwRCxpRkFBaUYscUJBQXFCLG1CQUFtQiw4QkFBOEIsZUFBZTtBQUN0SztBQUNBO0FBQ0EsMEJBQTBCLDJCQUEyQixpQkFBaUIsMkJBQTJCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxlQUFlLDZCQUE2QixlQUFlLElBQUksaUJBQWlCO0FBQzlKO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQsaUZBQWlGLGdCQUFnQiwrQkFBK0IsZUFBZTtBQUMvSTtBQUNBO0FBQ0EsUUFBUSxJQUFJLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0EseUJBQXlCLDJCQUEyQjtBQUNwRCxpRkFBaUYsZ0JBQWdCLCtCQUErQixlQUFlO0FBQy9JO0FBQ0E7QUFDQSxRQUFRLElBQUksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQSx5QkFBeUIsMkJBQTJCO0FBQ3BELHlFQUF5RSxrQkFBa0IsSUFBSSwrQ0FBK0M7QUFDOUk7QUFDQTtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQsaUZBQWlGLGdCQUFnQiwrQkFBK0IsaUJBQWlCLElBQUksY0FBYztBQUNuSztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJCQUEyQjtBQUNwRCxpRkFBaUYsZ0JBQWdCLDhCQUE4QixpQkFBaUIsSUFBSSxjQUFjO0FBQ2xLO0FBQ0E7QUFDQSx5QkFBeUIsMkJBQTJCO0FBQ3BELGlGQUFpRiw0Q0FBNEMseUNBQXlDLDRDQUE0QyxNQUFNLGNBQWM7QUFDdE87QUFDQTtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQsaUZBQWlGLGdCQUFnQix3REFBd0QsaUJBQWlCLElBQUksY0FBYztBQUM1TDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsNkJBQTZCLDJCQUEyQjtBQUN4RDtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLHVDQUF1QywyQkFBMkI7QUFDbEUseUdBQXlHLGdCQUFnQixvQ0FBb0MsZUFBZSxJQUFJLGdCQUFnQjtBQUNoTTtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1A7QUFDQTtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQsbUZBQW1GLGdCQUFnQjtBQUNuRztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUSxJQUFJLGNBQWM7QUFDMUI7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQsc0ZBQXNGLGdCQUFnQiwrQkFBK0IsZUFBZSw2RUFBNkUsZ0JBQWdCLHlEQUF5RCxpQkFBaUIsSUFBSSxjQUFjO0FBQzdVO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZELHNGQUFzRixnQkFBZ0IsK0JBQStCLGVBQWUsNkVBQTZFLGdCQUFnQixnQ0FBZ0MsaUJBQWlCLElBQUksY0FBYztBQUNwVDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZELHNGQUFzRixnQkFBZ0IsK0JBQStCLGVBQWUsNkVBQTZFLGdCQUFnQix3Q0FBd0MsY0FBYztBQUN2UztBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJCQUEyQiwyQkFBMkIsMkJBQTJCO0FBQ2xILCtLQUErSyxpQkFBaUIsa0VBQWtFLGVBQWUsSUFBSSxpQkFBaUI7QUFDdFM7QUFDQTtBQUNBLGlDQUFpQywyQkFBMkIsd0JBQXdCLDJCQUEyQjtBQUMvRyxzS0FBc0sscUJBQXFCLGtCQUFrQiwrREFBK0QsZUFBZSxJQUFJLHFCQUFxQixrQkFBa0I7QUFDdFU7QUFDQTtBQUNBLGlDQUFpQywyQkFBMkIsd0JBQXdCLDJCQUEyQjtBQUMvRyxnUEFBZ1AsZUFBZTtBQUMvUDtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0EsOEJBQThCLDJCQUEyQjtBQUN6RCxnR0FBZ0csaUJBQWlCLG9DQUFvQyxlQUFlLElBQUksaUJBQWlCO0FBQ3pMO0FBQ0E7QUFDQSw4QkFBOEIsMkJBQTJCO0FBQ3pELGdHQUFnRyxpQkFBaUIsb0NBQW9DLGVBQWUsSUFBSSxpQkFBaUI7QUFDekw7QUFDQTtBQUNBLDhCQUE4QiwyQkFBMkI7QUFDekQsZ0lBQWdJLGVBQWUsSUFBSSxpQkFBaUI7QUFDcEs7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLDRCQUE0QiwyQkFBMkIsdURBQXVELGVBQWUsaUJBQWlCLDJCQUEyQiwyREFBMkQsZUFBZSxJQUFJLGlCQUFpQjtBQUN4UTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtDQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQ0FBSztBQUNwQjtBQUNBLGVBQWUsa0NBQUs7QUFDcEI7QUFDQSxjQUFjLGtDQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHdCQUF3QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseUJBQXlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw2QkFBNkI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUxBQXFMLGtCQUFrQjtBQUN2TTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiwwQkFBMEIsZ0NBQWdDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQ0FBZ0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsVUFBVTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCLGdCQUFnQix5QkFBeUI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGFBQWE7QUFDL0U7QUFDQSwyRUFBMkUsa0JBQWtCO0FBQzdGO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsaUJBQWlCLGlDQUFpQyxlQUFlLGdFQUFnRSxlQUFlO0FBQ3JPO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLGlCQUFpQix3RUFBd0Usa0JBQWtCLElBQUksZUFBZTtBQUNuTjtBQUNBO0FBQ0EsY0FBYyw2RkFBNkYsaUJBQWlCO0FBQzVIO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMkVBQTJFLGtCQUFrQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxrQkFBa0I7QUFDN0Y7QUFDQTtBQUNBLGNBQWMsc0ZBQXNGLDZDQUE2Qyx1RkFBdUYsNkNBQTZDO0FBQ3JSO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDRCQUE0QjtBQUM1QixjQUFjLElBQUk7QUFDbEI7QUFDQSxxRkFBcUYsZ0JBQWdCLHdGQUF3Riw2Q0FBNkM7QUFDMU87QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQjtBQUNBLHFGQUFxRixnQkFBZ0I7QUFDckc7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQjtBQUNBLHFGQUFxRixnQkFBZ0I7QUFDckc7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQjtBQUNBLHFGQUFxRixnQkFBZ0I7QUFDckc7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQjtBQUNBLHFGQUFxRixnQkFBZ0I7QUFDckc7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9DQUFvQztBQUN0RSwwRkFBMEYsdUVBQXVFO0FBQ2pLO0FBQ0EsNERBQTRELDRCQUE0Qiw0QkFBNEIsZUFBZTtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0EseUJBQXlCLHdEQUF3RDtBQUNqRjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMkJBQTJCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCwwRUFBMEUsV0FBVztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyQkFBMkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQSxlQUFlLHdEQUF3RDtBQUN2RSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFxRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHdCQUF3QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE1BQU0sNktBQTZLLEtBQUssMkJBQTJCLGNBQWM7QUFDOVMsR0FBRztBQUNIO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGVBQWU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVEsc0JBQXNCLFNBQVM7QUFDdEY7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVEsc0JBQXNCLFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBLDRCQUE0QixHQUFHO0FBQy9CO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixXQUFXLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsZUFBZSxvQkFBb0I7QUFDNUk7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUMsZ0ZBQWdGLGlCQUFpQiwwREFBMEQsNkNBQTZDLElBQUksa0JBQWtCLElBQUksY0FBYztBQUNoUDtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QyxnRkFBZ0YsZ0JBQWdCLGdDQUFnQyxlQUFlLDZCQUE2QixzQ0FBc0M7QUFDbE47QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUMsZ0ZBQWdGLGdCQUFnQixnQ0FBZ0MsZUFBZTtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCLGtCQUFrQix5QkFBeUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0Isa0JBQWtCLHlCQUF5QjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELDZCQUE2QjtBQUM1RjtBQUNBLEdBQUc7QUFDSDtBQUNBLHFCQUFxQiw0QkFBNEIsVUFBVSxHQUFHLFFBQVEsZUFBZTtBQUNyRjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esa0hBQWtILGNBQWM7QUFDaEk7QUFDQTtBQUNBLG1IQUFtSCxjQUFjO0FBQ2pJO0FBWUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaXNwLWNsZWFuaW5nLy4vbm9kZV9tb2R1bGVzL2dyb3EtanMvZGlzdC8xLm1qcz80Zjk0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcyKSB7XG4gIHJldHVybiBzdHJpbmcyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbn1cbmZ1bmN0aW9uIHBhdGhSZWdFeHAocGF0dGVybikge1xuICBjb25zdCByZSA9IFtdO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGF0dGVybi5zcGxpdChcIi5cIikpXG4gICAgcGFydCA9PT0gXCIqXCIgPyByZS5wdXNoKFwiW14uXStcIikgOiBwYXJ0ID09PSBcIioqXCIgPyByZS5wdXNoKFwiLipcIikgOiByZS5wdXNoKGVzY2FwZVJlZ0V4cChwYXJ0KSk7XG4gIHJldHVybiBuZXcgUmVnRXhwKGBeJHtyZS5qb2luKFwiLlwiKX0kYCk7XG59XG5jbGFzcyBQYXRoIHtcbiAgcGF0dGVybjtcbiAgcGF0dGVyblJlO1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybiwgdGhpcy5wYXR0ZXJuUmUgPSBwYXRoUmVnRXhwKHBhdHRlcm4pO1xuICB9XG4gIG1hdGNoZXMoc3RyKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0dGVyblJlLnRlc3Qoc3RyKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0dGVybjtcbiAgfVxufVxuY29uc3QgUkZDMzMzOV9SRUdFWCA9IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn1UXFxkezJ9OlxcZHsyfTpcXGR7Mn0oXFwuXFxkKyk/KFp8KFstK11cXGR7Mn06XFxkezJ9KSkkLztcbmZ1bmN0aW9uIHBhcnNlUkZDMzMzOShzdHIpIHtcbiAgcmV0dXJuIFJGQzMzMzlfUkVHRVgudGVzdChzdHIpID8gbmV3IERhdGUoc3RyKSA6IG51bGw7XG59XG5mdW5jdGlvbiBmb3JtYXRSRkMzMzM5KGQpIHtcbiAgY29uc3QgeWVhciA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDRnVsbFllYXIoKSwgNCksIG1vbnRoID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENNb250aCgpICsgMSwgMiksIGRheSA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDRGF0ZSgpLCAyKSwgaG91ciA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDSG91cnMoKSwgMiksIG1pbnV0ZSA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDTWludXRlcygpLCAyKSwgc2Vjb25kID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENTZWNvbmRzKCksIDIpO1xuICBsZXQgZnJhY3Rpb25hbFNlY29uZCA9IFwiXCI7XG4gIGNvbnN0IG1pbGxpcyA9IGQuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gIHJldHVybiBtaWxsaXMgIT0gMCAmJiAoZnJhY3Rpb25hbFNlY29uZCA9IGAuJHthZGRMZWFkaW5nWmVybyhtaWxsaXMsIDMpfWApLCBgJHt5ZWFyfS0ke21vbnRofS0ke2RheX1UJHtob3VyfToke21pbnV0ZX06JHtzZWNvbmR9JHtmcmFjdGlvbmFsU2Vjb25kfVpgO1xufVxuZnVuY3Rpb24gYWRkTGVhZGluZ1plcm8obnVtLCB0YXJnZXRMZW5ndGgpIHtcbiAgbGV0IHN0ciA9IG51bS50b1N0cmluZygpO1xuICBmb3IgKDsgc3RyLmxlbmd0aCA8IHRhcmdldExlbmd0aDsgKVxuICAgIHN0ciA9IGAwJHtzdHJ9YDtcbiAgcmV0dXJuIHN0cjtcbn1cbmNsYXNzIFN0YXRpY1ZhbHVlIHtcbiAgZGF0YTtcbiAgdHlwZTtcbiAgY29uc3RydWN0b3IoZGF0YSwgdHlwZSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGEsIHRoaXMudHlwZSA9IHR5cGU7XG4gIH1cbiAgaXNBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSBcImFycmF5XCI7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXdhaXRcbiAgYXN5bmMgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbiAgYXNTdGF0aWMoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmRhdGEpKVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoZGF0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZGF0YSlcbiAgICAgICAgICB5aWVsZCBmcm9tSlMoZWxlbWVudCk7XG4gICAgICB9KHRoaXMuZGF0YSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaXRlcmF0ZSBvdmVyOiAke3RoaXMudHlwZX1gKTtcbiAgfVxufVxuY29uc3QgTlVMTF9WQUxVRSA9IG5ldyBTdGF0aWNWYWx1ZShudWxsLCBcIm51bGxcIiksIFRSVUVfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUoITAsIFwiYm9vbGVhblwiKSwgRkFMU0VfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUoITEsIFwiYm9vbGVhblwiKTtcbmNsYXNzIERhdGVUaW1lIHtcbiAgZGF0ZTtcbiAgY29uc3RydWN0b3IoZGF0ZSkge1xuICAgIHRoaXMuZGF0ZSA9IGRhdGU7XG4gIH1cbiAgc3RhdGljIHBhcnNlVG9WYWx1ZShzdHIpIHtcbiAgICBjb25zdCBkYXRlID0gcGFyc2VSRkMzMzM5KHN0cik7XG4gICAgcmV0dXJuIGRhdGUgPyBuZXcgU3RhdGljVmFsdWUobmV3IERhdGVUaW1lKGRhdGUpLCBcImRhdGV0aW1lXCIpIDogTlVMTF9WQUxVRTtcbiAgfVxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlLmdldFRpbWUoKSA9PSBvdGhlci5kYXRlLmdldFRpbWUoKTtcbiAgfVxuICBhZGQoc2Vjcykge1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgRGF0ZSh0aGlzLmRhdGUuZ2V0VGltZSgpKTtcbiAgICByZXR1cm4gY29weS5zZXRUaW1lKGNvcHkuZ2V0VGltZSgpICsgc2VjcyAqIDFlMyksIG5ldyBEYXRlVGltZShjb3B5KTtcbiAgfVxuICBkaWZmZXJlbmNlKG90aGVyKSB7XG4gICAgcmV0dXJuICh0aGlzLmRhdGUuZ2V0VGltZSgpIC0gb3RoZXIuZGF0ZS5nZXRUaW1lKCkpIC8gMWUzO1xuICB9XG4gIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0VGltZSgpIC0gb3RoZXIuZGF0ZS5nZXRUaW1lKCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGZvcm1hdFJGQzMzMzkodGhpcy5kYXRlKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfVxufVxuZnVuY3Rpb24gZnJvbU51bWJlcihudW0pIHtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShudW0pID8gbmV3IFN0YXRpY1ZhbHVlKG51bSwgXCJudW1iZXJcIikgOiBOVUxMX1ZBTFVFO1xufVxuZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShzdHIsIFwic3RyaW5nXCIpO1xufVxuZnVuY3Rpb24gZnJvbURhdGVUaW1lKGR0KSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUoZHQsIFwiZGF0ZXRpbWVcIik7XG59XG5mdW5jdGlvbiBmcm9tUGF0aChwYXRoKSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUocGF0aCwgXCJwYXRoXCIpO1xufVxuZnVuY3Rpb24gaXNJdGVyYXRvcihvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqLm5leHQgPT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gZnJvbUFycmF5KHZhbCkge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHZhbCwgXCJhcnJheVwiKTtcbn1cbmZ1bmN0aW9uIGZyb21KUyh2YWwpIHtcbiAgcmV0dXJuIGlzSXRlcmF0b3IodmFsKSA/IG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdmFsKVxuICAgICAgeWllbGQgZnJvbUpTKHZhbHVlKTtcbiAgfSkgOiB2YWwgPT0gbnVsbCA/IE5VTExfVkFMVUUgOiBuZXcgU3RhdGljVmFsdWUodmFsLCBnZXRUeXBlKHZhbCkpO1xufVxuZnVuY3Rpb24gdG9KUyh2YWwpIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IG1heWJlTm9ybWFsaXplKHZhbC5kYXRhKTtcbiAgcmV0dXJuIG5vcm1hbGl6ZWQgPT09IHZvaWQgMCA/IHZhbC5kYXRhIDogbm9ybWFsaXplZDtcbn1cbmZ1bmN0aW9uIG1heWJlTm9ybWFsaXplKGRhdGEpIHtcbiAgaWYgKCEoZGF0YSA9PT0gbnVsbCB8fCB0eXBlb2YgZGF0YSA+IFwidVwiKSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBub3JtYWxpemVkID0gbWF5YmVOb3JtYWxpemUoZGF0YVtpXSk7XG4gICAgICAgIG5vcm1hbGl6ZWQgIT09IHZvaWQgMCAmJiByZXN1bHQgPT09IHZvaWQgMCAmJiAocmVzdWx0ID0gZGF0YS5zbGljZSgwLCBpKSksIHJlc3VsdCAhPT0gdm9pZCAwICYmIChub3JtYWxpemVkID09PSB2b2lkIDAgJiYgKG5vcm1hbGl6ZWQgPSBkYXRhW2ldKSwgcmVzdWx0LnB1c2gobm9ybWFsaXplZCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmIChcInRvSlNPTlwiIGluIGRhdGEgJiYgdHlwZW9mIGRhdGEudG9KU09OID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIGRhdGEudG9KU09OKCk7XG4gICAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZGF0YSk7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGVudHJpZXNbaV07XG4gICAgICAgIGxldCBub3JtYWxpemVkID0gbWF5YmVOb3JtYWxpemUodmFsdWUpO1xuICAgICAgICBub3JtYWxpemVkICE9PSB2b2lkIDAgJiYgcmVzdWx0ID09PSB2b2lkIDAgJiYgKHJlc3VsdCA9IE9iamVjdC5mcm9tRW50cmllcyhlbnRyaWVzLnNsaWNlKDAsIGkpKSksIHJlc3VsdCAhPT0gdm9pZCAwICYmIChub3JtYWxpemVkID09PSB2b2lkIDAgJiYgKG5vcm1hbGl6ZWQgPSB2YWx1ZSksIHJlc3VsdFtrZXldID0gbm9ybWFsaXplZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0VHlwZShkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSBudWxsIHx8IHR5cGVvZiBkYXRhID4gXCJ1XCIgPyBcIm51bGxcIiA6IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBcImFycmF5XCIgOiBkYXRhIGluc3RhbmNlb2YgUGF0aCA/IFwicGF0aFwiIDogZGF0YSBpbnN0YW5jZW9mIERhdGVUaW1lID8gXCJkYXRldGltZVwiIDogdHlwZW9mIGRhdGE7XG59XG5jbGFzcyBTdHJlYW1WYWx1ZSB7XG4gIHR5cGUgPSBcInN0cmVhbVwiO1xuICBnZW5lcmF0b3I7XG4gIHRpY2tlcjtcbiAgaXNEb25lO1xuICBkYXRhO1xuICBjb25zdHJ1Y3RvcihnZW5lcmF0b3IpIHtcbiAgICB0aGlzLmdlbmVyYXRvciA9IGdlbmVyYXRvciwgdGhpcy50aWNrZXIgPSBudWxsLCB0aGlzLmlzRG9uZSA9ICExLCB0aGlzLmRhdGEgPSBbXTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICBpc0FycmF5KCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICBhc3luYyBnZXQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiB0aGlzKVxuICAgICAgcmVzdWx0LnB1c2goYXdhaXQgdmFsdWUuZ2V0KCkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgYXNTdGF0aWMoKSB7XG4gICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShhd2FpdCB0aGlzLmdldCgpLCBcImFycmF5XCIpO1xuICB9XG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgOyApIHtcbiAgICAgIGZvciAoOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICB5aWVsZCB0aGlzLmRhdGFbaV07XG4gICAgICBpZiAodGhpcy5pc0RvbmUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGF3YWl0IHRoaXMuX25leHRUaWNrKCk7XG4gICAgfVxuICB9XG4gIF9uZXh0VGljaygpIHtcbiAgICBpZiAodGhpcy50aWNrZXIpXG4gICAgICByZXR1cm4gdGhpcy50aWNrZXI7XG4gICAgbGV0IGN1cnJlbnRSZXNvbHZlciwgY3VycmVudFJlamVjdG9yO1xuICAgIGNvbnN0IHNldHVwVGlja2VyID0gKCkgPT4ge1xuICAgICAgdGhpcy50aWNrZXIgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGN1cnJlbnRSZXNvbHZlciA9IHJlc29sdmUsIGN1cnJlbnRSZWplY3RvciA9IHJlamVjdDtcbiAgICAgIH0pO1xuICAgIH0sIHRpY2sgPSAoKSA9PiB7XG4gICAgICBjdXJyZW50UmVzb2x2ZXIoKSwgc2V0dXBUaWNrZXIoKTtcbiAgICB9LCBmZXRjaCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdGhpcy5nZW5lcmF0b3IoKSlcbiAgICAgICAgICB0aGlzLmRhdGEucHVzaCh2YWx1ZSksIHRpY2soKTtcbiAgICAgICAgdGhpcy5pc0RvbmUgPSAhMCwgdGljaygpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY3VycmVudFJlamVjdG9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBzZXR1cFRpY2tlcigpLCBmZXRjaCgpLCB0aGlzLnRpY2tlcjtcbiAgfVxufVxuZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgYi50eXBlID09PSBcInN0cmluZ1wiIHx8IGEudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgYi50eXBlID09PSBcImJvb2xlYW5cIiB8fCBhLnR5cGUgPT09IFwibnVsbFwiICYmIGIudHlwZSA9PT0gXCJudWxsXCIgfHwgYS50eXBlID09PSBcIm51bWJlclwiICYmIGIudHlwZSA9PT0gXCJudW1iZXJcIiA/IGEuZGF0YSA9PT0gYi5kYXRhIDogYS50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgYi50eXBlID09PSBcImRhdGV0aW1lXCIgPyBhLmRhdGEuZXF1YWxzKGIuZGF0YSkgOiAhMTtcbn1cbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBudWxsIHx8IGIgPT09IG51bGwpIHJldHVybiBhID09PSBiO1xuICBjb25zdCB0eXBlT2ZBID0gdHlwZW9mIGEsIHR5cGVPZkIgPSB0eXBlb2YgYjtcbiAgaWYgKHR5cGVPZkEgPT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZU9mQiA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuICEwO1xuICBpZiAodHlwZU9mQSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVPZkIgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGEgPT09IGI7XG4gIGlmICh0eXBlT2ZBID09PSBcIm9iamVjdFwiICYmIHR5cGVPZkIgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCBrZXlzT2ZBID0gT2JqZWN0LmtleXMoYSksIGtleXNPZkIgPSBPYmplY3Qua2V5cyhiKTtcbiAgICBpZiAoa2V5c09mQS5sZW5ndGggIT09IGtleXNPZkIubGVuZ3RoKSByZXR1cm4gITE7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5c09mQSlcbiAgICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuICExO1xuICAgIHJldHVybiAhMDtcbiAgfVxuICByZXR1cm4gYSA9PT0gYjtcbn1cbmNvbnN0IENIQVJTID0gLyhbXiFAIyQlXiYqKCksXFxcXC8/XCI7Ont9fFtcXF0rPD5cXHMtXSkrL2csIENIQVJTX1dJVEhfV0lMRENBUkQgPSAvKFteIUAjJCVeJigpLFxcXFwvP1wiOzp7fXxbXFxdKzw+XFxzLV0pKy9nLCBFREdFX0NIQVJTID0gLyhcXGJcXC4rfFxcLitcXGIpL2c7XG5mdW5jdGlvbiBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucykge1xuICByZXR1cm4gdG9rZW5zLmxlbmd0aCA9PT0gMCB8fCBwYXR0ZXJucy5sZW5ndGggPT09IDAgPyAhMSA6IHBhdHRlcm5zLmV2ZXJ5KChwYXR0ZXJuKSA9PiBwYXR0ZXJuKHRva2VucykpO1xufVxuZnVuY3Rpb24gbWF0Y2hUb2tlbml6ZSh0ZXh0Mikge1xuICByZXR1cm4gdGV4dDIucmVwbGFjZShFREdFX0NIQVJTLCBcIlwiKS5tYXRjaChDSEFSUykgfHwgW107XG59XG5mdW5jdGlvbiBtYXRjaEFuYWx5emVQYXR0ZXJuKHRleHQyKSB7XG4gIHJldHVybiBtYXRjaFBhdHRlcm5SZWdleCh0ZXh0MikubWFwKChyZSkgPT4gKHRva2VucykgPT4gdG9rZW5zLnNvbWUoKHRva2VuKSA9PiByZS50ZXN0KHRva2VuKSkpO1xufVxuZnVuY3Rpb24gbWF0Y2hQYXR0ZXJuUmVnZXgodGV4dDIpIHtcbiAgcmV0dXJuICh0ZXh0Mi5yZXBsYWNlKEVER0VfQ0hBUlMsIFwiXCIpLm1hdGNoKENIQVJTX1dJVEhfV0lMRENBUkQpIHx8IFtdKS5tYXAoXG4gICAgKHRlcm0pID0+IG5ldyBSZWdFeHAoYF4ke3Rlcm0uc2xpY2UoMCwgMTAyNCkucmVwbGFjZSgvXFwqL2csIFwiLipcIil9JGAsIFwiaVwiKVxuICApO1xufVxuZnVuY3Rpb24gZ2F0aGVyVGV4dCh2YWx1ZSwgZmxhdE1hcDIpIHtcbiAgaWYgKHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIHsgcGFydHM6IGZsYXRNYXAyKHZhbHVlLmRhdGEpLCBzdWNjZXNzOiAhMCB9O1xuICBpZiAodmFsdWUudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgbGV0IHN1Y2Nlc3MgPSAhMDtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiB2YWx1ZS5kYXRhKVxuICAgICAgdHlwZW9mIHBhcnQgPT0gXCJzdHJpbmdcIiA/IHBhcnRzLnB1c2goLi4uZmxhdE1hcDIocGFydCkpIDogc3VjY2VzcyA9ICExO1xuICAgIHJldHVybiB7IHBhcnRzLCBzdWNjZXNzIH07XG4gIH1cbiAgcmV0dXJuIHZhbHVlLnR5cGUgPT09IFwic3RyZWFtXCIgPyAoYXN5bmMgKCkgPT4ge1xuICAgIGxldCBzdWNjZXNzID0gITA7XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2YgdmFsdWUpXG4gICAgICBwYXJ0LnR5cGUgPT09IFwic3RyaW5nXCIgPyBwYXJ0cy5wdXNoKC4uLmZsYXRNYXAyKHBhcnQuZGF0YSkpIDogc3VjY2VzcyA9ICExO1xuICAgIHJldHVybiB7IHBhcnRzLCBzdWNjZXNzIH07XG4gIH0pKCkgOiB7IHBhcnRzOiBbXSwgc3VjY2VzczogITEgfTtcbn1cbmNvbnN0IFRZUEVfT1JERVIgPSB7XG4gIGRhdGV0aW1lOiAxLFxuICBudW1iZXI6IDIsXG4gIHN0cmluZzogMyxcbiAgYm9vbGVhbjogNFxufTtcbmZ1bmN0aW9uIHBhcnRpYWxDb21wYXJlKGEsIGIpIHtcbiAgY29uc3QgYVR5cGUgPSBnZXRUeXBlKGEpLCBiVHlwZSA9IGdldFR5cGUoYik7XG4gIGlmIChhVHlwZSAhPT0gYlR5cGUpXG4gICAgcmV0dXJuIG51bGw7XG4gIHN3aXRjaCAoYVR5cGUpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBhIC0gYjtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICByZXR1cm4gYS5jb21wYXJlVG8oYik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiB0b3RhbENvbXBhcmUoYSwgYikge1xuICBjb25zdCBhVHlwZSA9IGdldFR5cGUoYSksIGJUeXBlID0gZ2V0VHlwZShiKSwgYVR5cGVPcmRlciA9IFRZUEVfT1JERVJbYVR5cGVdIHx8IDEwMCwgYlR5cGVPcmRlciA9IFRZUEVfT1JERVJbYlR5cGVdIHx8IDEwMDtcbiAgaWYgKGFUeXBlT3JkZXIgIT09IGJUeXBlT3JkZXIpXG4gICAgcmV0dXJuIGFUeXBlT3JkZXIgLSBiVHlwZU9yZGVyO1xuICBsZXQgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUoYSwgYik7XG4gIHJldHVybiByZXN1bHQgPT09IG51bGwgJiYgKHJlc3VsdCA9IDApLCByZXN1bHQ7XG59XG5jb25zdCBvcGVyYXRvcnMgPSB7XG4gIFwiPT1cIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gaXNFcXVhbChsZWZ0LCByaWdodCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiIT1cIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gaXNFcXVhbChsZWZ0LCByaWdodCkgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUU7XG4gIH0sXG4gIFwiPlwiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBudWxsID8gTlVMTF9WQUxVRSA6IHJlc3VsdCA+IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiPj1cIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IE5VTExfVkFMVUUgOiByZXN1bHQgPj0gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCI8XCI6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJlYW1cIiB8fCByaWdodC50eXBlID09PSBcInN0cmVhbVwiKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgIHJldHVybiByZXN1bHQgPT09IG51bGwgPyBOVUxMX1ZBTFVFIDogcmVzdWx0IDwgMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCI8PVwiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBudWxsID8gTlVMTF9WQUxVRSA6IHJlc3VsdCA8PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gIGluOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChyaWdodC50eXBlID09PSBcInBhdGhcIilcbiAgICAgIHJldHVybiBsZWZ0LnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogcmlnaHQuZGF0YS5tYXRjaGVzKGxlZnQuZGF0YSkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgaWYgKHJpZ2h0LnR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgZm9yIChjb25zdCBiIG9mIHJpZ2h0LmRhdGEpXG4gICAgICAgIGlmIChpc0VxdWFsKGxlZnQsIGZyb21KUyhiKSkpXG4gICAgICAgICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiByaWdodC50eXBlID09PSBcInN0cmVhbVwiID8gKGFzeW5jICgpID0+IHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgYiBvZiByaWdodClcbiAgICAgICAgaWYgKGlzRXF1YWwobGVmdCwgYikpXG4gICAgICAgICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gICAgfSkoKSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIG1hdGNoOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IHRva2VucyA9IGdhdGhlclRleHQobGVmdCwgKHBhcnQpID0+IG1hdGNoVG9rZW5pemUocGFydCkpLCBwYXR0ZXJucyA9IGdhdGhlclRleHQocmlnaHQsIChwYXJ0KSA9PiBtYXRjaEFuYWx5emVQYXR0ZXJuKHBhcnQpKSwgcHJvY2VzcyA9ICh0b2tlbnMyLCBwYXR0ZXJuczIpID0+IHBhdHRlcm5zMi5zdWNjZXNzICYmIG1hdGNoVGV4dCh0b2tlbnMyLnBhcnRzLCBwYXR0ZXJuczIucGFydHMpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICAgIHJldHVybiBcInRoZW5cIiBpbiB0b2tlbnMgfHwgXCJ0aGVuXCIgaW4gcGF0dGVybnMgPyAoYXN5bmMgKCkgPT4gcHJvY2Vzcyhhd2FpdCB0b2tlbnMsIGF3YWl0IHBhdHRlcm5zKSkoKSA6IHByb2Nlc3ModG9rZW5zLCBwYXR0ZXJucyk7XG4gIH0sXG4gIFwiK1wiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8gZnJvbURhdGVUaW1lKGxlZnQuZGF0YS5hZGQocmlnaHQuZGF0YSkpIDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyBmcm9tTnVtYmVyKGxlZnQuZGF0YSArIHJpZ2h0LmRhdGEpIDogbGVmdC50eXBlID09PSBcInN0cmluZ1wiICYmIHJpZ2h0LnR5cGUgPT09IFwic3RyaW5nXCIgPyBmcm9tU3RyaW5nKGxlZnQuZGF0YSArIHJpZ2h0LmRhdGEpIDogbGVmdC50eXBlID09PSBcIm9iamVjdFwiICYmIHJpZ2h0LnR5cGUgPT09IFwib2JqZWN0XCIgPyBmcm9tSlMoeyAuLi5sZWZ0LmRhdGEsIC4uLnJpZ2h0LmRhdGEgfSkgOiBsZWZ0LnR5cGUgPT09IFwiYXJyYXlcIiAmJiByaWdodC50eXBlID09PSBcImFycmF5XCIgPyBmcm9tSlMobGVmdC5kYXRhLmNvbmNhdChyaWdodC5kYXRhKSkgOiBsZWZ0LmlzQXJyYXkoKSAmJiByaWdodC5pc0FycmF5KCkgPyBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIGxlZnQpXG4gICAgICAgIHlpZWxkIHZhbDtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIHJpZ2h0KVxuICAgICAgICB5aWVsZCB2YWw7XG4gICAgfSkgOiBOVUxMX1ZBTFVFO1xuICB9LFxuICBcIi1cIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdC50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IGZyb21EYXRlVGltZShsZWZ0LmRhdGEuYWRkKC1yaWdodC5kYXRhKSkgOiBsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcImRhdGV0aW1lXCIgPyBmcm9tTnVtYmVyKGxlZnQuZGF0YS5kaWZmZXJlbmNlKHJpZ2h0LmRhdGEpKSA6IGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8gZnJvbU51bWJlcihsZWZ0LmRhdGEgLSByaWdodC5kYXRhKSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIFwiKlwiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IGEgKiBiKSxcbiAgXCIvXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gYSAvIGIpLFxuICBcIiVcIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBhICUgYiksXG4gIFwiKipcIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBNYXRoLnBvdyhhLCBiKSlcbn07XG5mdW5jdGlvbiBudW1lcmljT3BlcmF0b3IoaW1wbCkge1xuICByZXR1cm4gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGltcGwobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9O1xufVxubGV0IFNjb3BlJDEgPSBjbGFzcyBTY29wZSB7XG4gIHBhcmFtcztcbiAgc291cmNlO1xuICB2YWx1ZTtcbiAgcGFyZW50O1xuICBjb250ZXh0O1xuICBpc0hpZGRlbiA9ICExO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuICBjb25zdHJ1Y3RvcihwYXJhbXMsIHNvdXJjZSwgdmFsdWUsIGNvbnRleHQsIHBhcmVudCkge1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zLCB0aGlzLnNvdXJjZSA9IHNvdXJjZSwgdGhpcy52YWx1ZSA9IHZhbHVlLCB0aGlzLmNvbnRleHQgPSBjb250ZXh0LCB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgfVxuICBjcmVhdGVOZXN0ZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5pc0hpZGRlbiA/IG5ldyBTY29wZSh0aGlzLnBhcmFtcywgdGhpcy5zb3VyY2UsIHZhbHVlLCB0aGlzLmNvbnRleHQsIHRoaXMucGFyZW50KSA6IG5ldyBTY29wZSh0aGlzLnBhcmFtcywgdGhpcy5zb3VyY2UsIHZhbHVlLCB0aGlzLmNvbnRleHQsIHRoaXMpO1xuICB9XG4gIGNyZWF0ZUhpZGRlbih2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY3JlYXRlTmVzdGVkKHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0LmlzSGlkZGVuID0gITAsIHJlc3VsdDtcbiAgfVxufTtcbmZ1bmN0aW9uIGV2YWx1YXRlKG5vZGUsIHNjb3BlKSB7XG4gIHJldHVybiBleGVjdXRlQXN5bmMobm9kZSwgc2NvcGUpO1xufVxuZnVuY3Rpb24gZXhlY3V0ZVN5bmMobm9kZSwgc2NvcGUpIHtcbiAgcmV0dXJuIEVYRUNVVE9SU1tub2RlLnR5cGVdLmV4ZWN1dGVTeW5jKG5vZGUsIHNjb3BlKTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVBc3luYyhub2RlLCBzY29wZSkge1xuICByZXR1cm4gRVhFQ1VUT1JTW25vZGUudHlwZV0uZXhlY3V0ZUFzeW5jKG5vZGUsIHNjb3BlKTtcbn1cbmZ1bmN0aW9uIGFzeW5jT25seUV4ZWN1dG9yKGV4ZWN1dGVBc3luYzIpIHtcbiAgcmV0dXJuIHtcbiAgICBleGVjdXRlU3luYygpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImV4ZWN1dGVTeW5jIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfSxcbiAgICBleGVjdXRlQXN5bmM6IGV4ZWN1dGVBc3luYzJcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnN0YW50RXhlY3V0b3IoZm4pIHtcbiAgcmV0dXJuIHtcbiAgICBleGVjdXRlU3luYyhub2RlLCBzY29wZSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBmbihub2RlLCBzY29wZSk7XG4gICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJzdHJlYW1cIikgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGVuY291bnRlcmVkIGluIGV2YWx1YXRlU3luY1wiKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIGFzeW5jIGV4ZWN1dGVBc3luYyhub2RlLCBzY29wZSkge1xuICAgICAgcmV0dXJuIGZuKG5vZGUsIHNjb3BlKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBtYXBwZWRFeGVjdXRvcihtYXAyLCByZWR1Y2UpIHtcbiAgcmV0dXJuIHtcbiAgICBleGVjdXRlU3luYyhub2RlLCBzY29wZSkge1xuICAgICAgY29uc3QgdmFsdWVzID0gbWFwMihub2RlKS5tYXAoKG5vZGUyKSA9PiBleGVjdXRlU3luYyhub2RlMiwgc2NvcGUpKSwgdmFsdWUgPSByZWR1Y2Uobm9kZSwgLi4udmFsdWVzKTtcbiAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcInN0cmVhbVwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0vaXRlcmF0b3Igbm90IHN1cHBvcnRlZCBpbiBzeW5jaHJvbm91cyBtb2RlXCIpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgYXN5bmMgZXhlY3V0ZUFzeW5jKG5vZGUsIHNjb3BlKSB7XG4gICAgICBjb25zdCBub2RlcyA9IG1hcDIobm9kZSksIHZhbHVlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBub2Rlcy5tYXAoKG5vZGUyKSA9PiBleGVjdXRlQXN5bmMobm9kZTIsIHNjb3BlKS50aGVuKCh2YWx1ZSkgPT4gdmFsdWUuYXNTdGF0aWMoKSkpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHJlZHVjZShub2RlLCAuLi52YWx1ZXMpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IFNUT1BfSVRFUkFUT1IgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIGFycmF5UmVkdWNlckV4ZWN1dG9yKG1hcDIsIGluaXQsIHJlZHVjZSwgd3JhcCkge1xuICByZXR1cm4ge1xuICAgIGV4ZWN1dGVTeW5jKG5vZGUsIHNjb3BlKSB7XG4gICAgICBjb25zdCB7IGFycmF5OiBhcnJheU5vZGUsIGFyZ3M6IGFyZ05vZGVzID0gW10gfSA9IG1hcDIobm9kZSksIGFyciA9IGV4ZWN1dGVTeW5jKGFycmF5Tm9kZSwgc2NvcGUpO1xuICAgICAgaWYgKGFyci50eXBlICE9PSBcImFycmF5XCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgY29uc3QgYXJncyA9IGFyZ05vZGVzLm1hcCgobm9kZTIpID0+IGV4ZWN1dGVTeW5jKG5vZGUyLCBzY29wZSkpO1xuICAgICAgbGV0IHN0YXRlID0gaW5pdChub2RlLCAuLi5hcmdzKTtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIuZGF0YSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZWR1Y2Uobm9kZSwgc3RhdGUsIGl0ZW0sIC4uLmFyZ3MpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBTVE9QX0lURVJBVE9SKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgICAgc3RhdGUgPSByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcChzdGF0ZSk7XG4gICAgfSxcbiAgICBhc3luYyBleGVjdXRlQXN5bmMobm9kZSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IHsgYXJyYXk6IGFycmF5Tm9kZSwgYXJnczogYXJnTm9kZXMgPSBbXSB9ID0gbWFwMihub2RlKSwgYXJyID0gYXdhaXQgZXhlY3V0ZUFzeW5jKGFycmF5Tm9kZSwgc2NvcGUpO1xuICAgICAgaWYgKGFyci50eXBlICE9PSBcImFycmF5XCIgJiYgYXJyLnR5cGUgIT09IFwic3RyZWFtXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgY29uc3QgYXJncyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBhcmdOb2Rlcy5tYXAoKG5vZGUyKSA9PiBleGVjdXRlQXN5bmMobm9kZTIsIHNjb3BlKS50aGVuKCh2KSA9PiB2LmFzU3RhdGljKCkpKVxuICAgICAgKTtcbiAgICAgIGxldCBzdGF0ZSA9IGluaXQobm9kZSwgLi4uYXJncyk7XG4gICAgICBpZiAoYXJyLnR5cGUgPT09IFwic3RyZWFtXCIpXG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWR1Y2Uobm9kZSwgc3RhdGUsIGF3YWl0IGl0ZW0uZ2V0KCksIC4uLmFyZ3MpO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IFNUT1BfSVRFUkFUT1IpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgICAgIHN0YXRlID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIuZGF0YSkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZHVjZShub2RlLCBzdGF0ZSwgaXRlbSwgLi4uYXJncyk7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gU1RPUF9JVEVSQVRPUikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAgICAgc3RhdGUgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwKHN0YXRlKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBhcnJheUV4ZWN1dG9yKG1hcDIsIHJlZHVjZSwgeyBoaWRkZW4gPSAhMSB9ID0ge30pIHtcbiAgcmV0dXJuIHtcbiAgICBleGVjdXRlU3luYyhub2RlLCBzY29wZSkge1xuICAgICAgY29uc3QgbWFwcGluZyA9IG1hcDIobm9kZSksIGFyciA9IGV4ZWN1dGVTeW5jKG1hcHBpbmcuYXJyYXksIHNjb3BlKTtcbiAgICAgIGlmIChhcnIudHlwZSAhPT0gXCJhcnJheVwiKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFyci5kYXRhKSB7XG4gICAgICAgIGxldCBpbm5lcjtcbiAgICAgICAgaWYgKG1hcHBpbmcuaW5uZXIpIHtcbiAgICAgICAgICBjb25zdCBuZXdTY29wZSA9IGhpZGRlbiA/IHNjb3BlLmNyZWF0ZUhpZGRlbihmcm9tSlMoaXRlbSkpIDogc2NvcGUuY3JlYXRlTmVzdGVkKGZyb21KUyhpdGVtKSk7XG4gICAgICAgICAgaW5uZXIgPSBleGVjdXRlU3luYyhtYXBwaW5nLmlubmVyLCBuZXdTY29wZSkuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHJlZHVjZShub2RlLCBpdGVtLCBpbm5lciwgbWFwcGluZy5zdGF0ZSkpXG4gICAgICAgICAgcmVzdWx0LnB1c2goZW50cnkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheShyZXN1bHQpO1xuICAgIH0sXG4gICAgYXN5bmMgZXhlY3V0ZUFzeW5jKG5vZGUsIHNjb3BlKSB7XG4gICAgICBjb25zdCBtYXBwaW5nID0gbWFwMihub2RlKSwgYXJyID0gYXdhaXQgZXhlY3V0ZUFzeW5jKG1hcHBpbmcuYXJyYXksIHNjb3BlKTtcbiAgICAgIHJldHVybiBhcnIuaXNBcnJheSgpID8gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgICAgICBsZXQgaW5uZXI7XG4gICAgICAgICAgaWYgKG1hcHBpbmcuaW5uZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Njb3BlID0gaGlkZGVuID8gc2NvcGUuY3JlYXRlSGlkZGVuKGl0ZW0pIDogc2NvcGUuY3JlYXRlTmVzdGVkKGl0ZW0pO1xuICAgICAgICAgICAgaW5uZXIgPSBhd2FpdCAoYXdhaXQgZXhlY3V0ZUFzeW5jKG1hcHBpbmcuaW5uZXIsIG5ld1Njb3BlKSkuZ2V0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgcmVkdWNlKG5vZGUsIGF3YWl0IGl0ZW0uZ2V0KCksIGlubmVyLCBtYXBwaW5nLnN0YXRlKSlcbiAgICAgICAgICAgIHlpZWxkIGZyb21KUyhlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgIH0pIDogTlVMTF9WQUxVRTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBFWEVDVVRPUlMgPSB7XG4gIFRoaXM6IGNvbnN0YW50RXhlY3V0b3IoKF8sIHNjb3BlKSA9PiBzY29wZS52YWx1ZSksXG4gIFNlbGVjdG9yTmVzdGVkOiBjb25zdGFudEV4ZWN1dG9yKCgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG5vZGUgdHlwZTogU2VsZWN0b3JOZXN0ZWRcIik7XG4gIH0pLFxuICBTZWxlY3RvckZ1bmNDYWxsOiBjb25zdGFudEV4ZWN1dG9yKCgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG5vZGUgdHlwZTogU2VsZWN0b3JGdW5jQ2FsbFwiKTtcbiAgfSksXG4gIEV2ZXJ5dGhpbmc6IGNvbnN0YW50RXhlY3V0b3IoKF8sIHNjb3BlKSA9PiBzY29wZS5zb3VyY2UpLFxuICBQYXJhbWV0ZXI6IGNvbnN0YW50RXhlY3V0b3IoKHsgbmFtZSB9LCBzY29wZSkgPT4gZnJvbUpTKHNjb3BlLnBhcmFtc1tuYW1lXSkpLFxuICBDb250ZXh0OiBjb25zdGFudEV4ZWN1dG9yKCh7IGtleSB9LCBzY29wZSkgPT4ge1xuICAgIGlmIChrZXkgPT09IFwiYmVmb3JlXCIgfHwga2V5ID09PSBcImFmdGVyXCIpXG4gICAgICByZXR1cm4gc2NvcGUuY29udGV4dFtrZXldIHx8IE5VTExfVkFMVUU7XG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIGNvbnRleHQga2V5OiAke2tleX1gKTtcbiAgfSksXG4gIFBhcmVudDogY29uc3RhbnRFeGVjdXRvcigoeyBuIH0sIHNjb3BlKSA9PiB7XG4gICAgbGV0IGN1cnJlbnQgPSBzY29wZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgaWYgKCFjdXJyZW50LnBhcmVudClcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50LnZhbHVlO1xuICB9KSxcbiAgT3BDYWxsOiB7XG4gICAgYXN5bmMgZXhlY3V0ZUFzeW5jKHsgb3AsIGxlZnQsIHJpZ2h0IH0sIHNjb3BlKSB7XG4gICAgICBjb25zdCBmdW5jID0gb3BlcmF0b3JzW29wXTtcbiAgICAgIGlmICghZnVuYylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG9wZXJhdG9yOiAke29wfWApO1xuICAgICAgY29uc3QgbGVmdFZhbHVlID0gYXdhaXQgZXhlY3V0ZUFzeW5jKGxlZnQsIHNjb3BlKSwgcmlnaHRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGVBc3luYyhyaWdodCwgc2NvcGUpO1xuICAgICAgcmV0dXJuIGZ1bmMobGVmdFZhbHVlLCByaWdodFZhbHVlKTtcbiAgICB9LFxuICAgIGV4ZWN1dGVTeW5jKHsgb3AsIGxlZnQsIHJpZ2h0IH0sIHNjb3BlKSB7XG4gICAgICBjb25zdCBmdW5jID0gb3BlcmF0b3JzW29wXTtcbiAgICAgIGlmICghZnVuYylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG9wZXJhdG9yOiAke29wfWApO1xuICAgICAgY29uc3QgbGVmdFZhbHVlID0gZXhlY3V0ZVN5bmMobGVmdCwgc2NvcGUpLCByaWdodFZhbHVlID0gZXhlY3V0ZVN5bmMocmlnaHQsIHNjb3BlKSwgcmVzdWx0ID0gZnVuYyhsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpO1xuICAgICAgaWYgKFwidGhlblwiIGluIHJlc3VsdCB8fCByZXN1bHQudHlwZSA9PT0gXCJzdHJlYW1cIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPcGVyYXRvciAke29wfSBub3QgcG9zc2libGUgaW4gZXZhbHV0ZVN5bmNgKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LFxuICBTZWxlY3Q6IHtcbiAgICBleGVjdXRlU3luYyh7IGFsdGVybmF0aXZlcywgZmFsbGJhY2sgfSwgc2NvcGUpIHtcbiAgICAgIGZvciAoY29uc3QgYWx0IG9mIGFsdGVybmF0aXZlcykge1xuICAgICAgICBjb25zdCBhbHRDb25kID0gZXhlY3V0ZVN5bmMoYWx0LmNvbmRpdGlvbiwgc2NvcGUpO1xuICAgICAgICBpZiAoYWx0Q29uZC50eXBlID09PSBcImJvb2xlYW5cIiAmJiBhbHRDb25kLmRhdGEgPT09ICEwKVxuICAgICAgICAgIHJldHVybiBleGVjdXRlU3luYyhhbHQudmFsdWUsIHNjb3BlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxsYmFjayA/IGV4ZWN1dGVTeW5jKGZhbGxiYWNrLCBzY29wZSkgOiBOVUxMX1ZBTFVFO1xuICAgIH0sXG4gICAgYXN5bmMgZXhlY3V0ZUFzeW5jKHsgYWx0ZXJuYXRpdmVzLCBmYWxsYmFjayB9LCBzY29wZSkge1xuICAgICAgZm9yIChjb25zdCBhbHQgb2YgYWx0ZXJuYXRpdmVzKSB7XG4gICAgICAgIGNvbnN0IGFsdENvbmQgPSBhd2FpdCBleGVjdXRlQXN5bmMoYWx0LmNvbmRpdGlvbiwgc2NvcGUpO1xuICAgICAgICBpZiAoYWx0Q29uZC50eXBlID09PSBcImJvb2xlYW5cIiAmJiBhbHRDb25kLmRhdGEgPT09ICEwKVxuICAgICAgICAgIHJldHVybiBleGVjdXRlQXN5bmMoYWx0LnZhbHVlLCBzY29wZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsbGJhY2sgPyBleGVjdXRlQXN5bmMoZmFsbGJhY2ssIHNjb3BlKSA6IE5VTExfVkFMVUU7XG4gICAgfVxuICB9LFxuICBJblJhbmdlOiBtYXBwZWRFeGVjdXRvcihcbiAgICAoeyBiYXNlLCBsZWZ0LCByaWdodCB9KSA9PiBbYmFzZSwgbGVmdCwgcmlnaHRdLFxuICAgICh7IGlzSW5jbHVzaXZlIH0sIHZhbHVlLCBsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGxlZnRDbXAgPSBwYXJ0aWFsQ29tcGFyZSh2YWx1ZS5kYXRhLCBsZWZ0VmFsdWUuZGF0YSk7XG4gICAgICBpZiAobGVmdENtcCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICBjb25zdCByaWdodENtcCA9IHBhcnRpYWxDb21wYXJlKHZhbHVlLmRhdGEsIHJpZ2h0VmFsdWUuZGF0YSk7XG4gICAgICByZXR1cm4gcmlnaHRDbXAgPT09IG51bGwgPyBOVUxMX1ZBTFVFIDogaXNJbmNsdXNpdmUgPyBsZWZ0Q21wID49IDAgJiYgcmlnaHRDbXAgPD0gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRSA6IGxlZnRDbXAgPj0gMCAmJiByaWdodENtcCA8IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgfVxuICApLFxuICBGaWx0ZXI6IGFycmF5RXhlY3V0b3IoXG4gICAgKHsgYmFzZSwgZXhwciB9KSA9PiAoeyBhcnJheTogYmFzZSwgaW5uZXI6IGV4cHIgfSksXG4gICAgZnVuY3Rpb24qIChfLCBlbGVtLCBpbm5lcikge1xuICAgICAgaW5uZXIgPT09ICEwICYmICh5aWVsZCBlbGVtKTtcbiAgICB9XG4gICksXG4gIFByb2plY3Rpb246IHtcbiAgICBleGVjdXRlU3luYyh7IGJhc2UsIGV4cHIgfSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGV4ZWN1dGVTeW5jKGJhc2UsIHNjb3BlKTtcbiAgICAgIGlmIChiYXNlVmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZChiYXNlVmFsdWUpO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVTeW5jKGV4cHIsIG5ld1Njb3BlKTtcbiAgICB9LFxuICAgIGFzeW5jIGV4ZWN1dGVBc3luYyh7IGJhc2UsIGV4cHIgfSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGVBc3luYyhiYXNlLCBzY29wZSk7XG4gICAgICBpZiAoYmFzZVZhbHVlLnR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQoYmFzZVZhbHVlKTtcbiAgICAgIHJldHVybiBleGVjdXRlQXN5bmMoZXhwciwgbmV3U2NvcGUpO1xuICAgIH1cbiAgfSxcbiAgRnVuY0NhbGw6IHtcbiAgICBleGVjdXRlQXN5bmMoeyBmdW5jLCBhcmdzIH0sIHNjb3BlKSB7XG4gICAgICByZXR1cm4gZnVuYy5leGVjdXRlQXN5bmMoYXJncywgc2NvcGUpO1xuICAgIH0sXG4gICAgZXhlY3V0ZVN5bmMoeyBmdW5jLCBhcmdzIH0sIHNjb3BlKSB7XG4gICAgICByZXR1cm4gZnVuYy5leGVjdXRlU3luYyhhcmdzLCBzY29wZSk7XG4gICAgfVxuICB9LFxuICBQaXBlRnVuY0NhbGw6IHtcbiAgICBhc3luYyBleGVjdXRlQXN5bmMoeyBmdW5jLCBiYXNlLCBhcmdzIH0sIHNjb3BlKSB7XG4gICAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlQXN5bmMoYmFzZSwgc2NvcGUpO1xuICAgICAgcmV0dXJuIGJhc2VWYWx1ZS50eXBlICE9PSBcInN0cmVhbVwiICYmIGJhc2VWYWx1ZS50eXBlICE9PSBcImFycmF5XCIgPyBOVUxMX1ZBTFVFIDogZnVuYy5leGVjdXRlQXN5bmMoeyBiYXNlOiBiYXNlVmFsdWUsIGFyZ3MgfSwgc2NvcGUpO1xuICAgIH0sXG4gICAgZXhlY3V0ZVN5bmMoeyBmdW5jLCBiYXNlLCBhcmdzIH0sIHNjb3BlKSB7XG4gICAgICBjb25zdCBiYXNlVmFsdWUgPSBleGVjdXRlU3luYyhiYXNlLCBzY29wZSk7XG4gICAgICByZXR1cm4gYmFzZVZhbHVlLnR5cGUgIT09IFwiYXJyYXlcIiA/IE5VTExfVkFMVUUgOiBmdW5jLmV4ZWN1dGVTeW5jKHsgYmFzZTogYmFzZVZhbHVlLCBhcmdzIH0sIHNjb3BlKTtcbiAgICB9XG4gIH0sXG4gIEFjY2Vzc0F0dHJpYnV0ZTogbWFwcGVkRXhlY3V0b3IoXG4gICAgKHsgYmFzZSB9KSA9PiBbYmFzZSB8fCB7IHR5cGU6IFwiVGhpc1wiIH1dLFxuICAgICh7IG5hbWUgfSwgdmFsdWUpID0+IHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUuZGF0YS5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IGZyb21KUyh2YWx1ZS5kYXRhW25hbWVdKSA6IE5VTExfVkFMVUVcbiAgKSxcbiAgQWNjZXNzRWxlbWVudDogbWFwcGVkRXhlY3V0b3IoXG4gICAgKHsgYmFzZSB9KSA9PiBbYmFzZV0sXG4gICAgKHsgaW5kZXggfSwgYmFzZVZhbHVlKSA9PiB7XG4gICAgICBpZiAoYmFzZVZhbHVlLnR5cGUgIT09IFwiYXJyYXlcIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICBjb25zdCBkYXRhID0gYmFzZVZhbHVlLmRhdGEsIGZpbmFsSW5kZXggPSBpbmRleCA8IDAgPyBpbmRleCArIGRhdGEubGVuZ3RoIDogaW5kZXg7XG4gICAgICByZXR1cm4gZnJvbUpTKGRhdGFbZmluYWxJbmRleF0pO1xuICAgIH1cbiAgKSxcbiAgU2xpY2U6IG1hcHBlZEV4ZWN1dG9yKFxuICAgICh7IGJhc2UgfSkgPT4gW2Jhc2VdLFxuICAgICh7IGxlZnQsIHJpZ2h0LCBpc0luY2x1c2l2ZSB9LCBiYXNlVmFsdWUpID0+IHtcbiAgICAgIGlmIChiYXNlVmFsdWUudHlwZSAhPT0gXCJhcnJheVwiKVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIGNvbnN0IGFycmF5MiA9IGJhc2VWYWx1ZS5kYXRhO1xuICAgICAgbGV0IGxlZnRJZHggPSBsZWZ0LCByaWdodElkeCA9IHJpZ2h0O1xuICAgICAgcmV0dXJuIGxlZnRJZHggPCAwICYmIChsZWZ0SWR4ID0gYXJyYXkyLmxlbmd0aCArIGxlZnRJZHgpLCByaWdodElkeCA8IDAgJiYgKHJpZ2h0SWR4ID0gYXJyYXkyLmxlbmd0aCArIHJpZ2h0SWR4KSwgaXNJbmNsdXNpdmUgJiYgcmlnaHRJZHgrKywgbGVmdElkeCA8IDAgJiYgKGxlZnRJZHggPSAwKSwgcmlnaHRJZHggPCAwICYmIChyaWdodElkeCA9IDApLCBmcm9tQXJyYXkoYXJyYXkyLnNsaWNlKGxlZnRJZHgsIHJpZ2h0SWR4KSk7XG4gICAgfVxuICApLFxuICBEZXJlZjoge1xuICAgIGV4ZWN1dGVTeW5jKHsgYmFzZSB9LCBzY29wZSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBleGVjdXRlU3luYyhiYXNlLCBzY29wZSk7XG4gICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICBjb25zdCBpZCA9IHZhbHVlLmRhdGEuX3JlZjtcbiAgICAgIGlmICh0eXBlb2YgaWQgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICBpZiAoc2NvcGUuY29udGV4dC5kZXJlZmVyZW5jZSkge1xuICAgICAgICBjb25zdCB2YWx1ZTIgPSBzY29wZS5jb250ZXh0LmRlcmVmZXJlbmNlKHsgX3JlZjogaWQgfSk7XG4gICAgICAgIGlmICh2YWx1ZTIgJiYgdHlwZW9mIHZhbHVlMiA9PSBcIm9iamVjdFwiICYmIFwidGhlblwiIGluIHZhbHVlMilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZXJlZmVyZW5jZSByZXR1cm5lZCBwcm9taXNlIGluIHN5bmNocm9ub3VzIG1vZGVcIik7XG4gICAgICAgIHJldHVybiBmcm9tSlModmFsdWUyKTtcbiAgICAgIH1cbiAgICAgIGlmIChzY29wZS5zb3VyY2UudHlwZSAhPT0gXCJhcnJheVwiKVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIGZvciAoY29uc3QgZG9jIG9mIHNjb3BlLnNvdXJjZS5kYXRhKVxuICAgICAgICBpZiAoZG9jICYmIHR5cGVvZiBkb2MgPT0gXCJvYmplY3RcIiAmJiBcIl9pZFwiIGluIGRvYyAmJiBpZCA9PT0gZG9jLl9pZClcbiAgICAgICAgICByZXR1cm4gZnJvbUpTKGRvYyk7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9LFxuICAgIGFzeW5jIGV4ZWN1dGVBc3luYyh7IGJhc2UgfSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZUFzeW5jKGJhc2UsIHNjb3BlKTtcbiAgICAgIGlmICghc2NvcGUuc291cmNlLmlzQXJyYXkoKSB8fCB2YWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIGNvbnN0IGlkID0gdmFsdWUuZGF0YS5fcmVmO1xuICAgICAgaWYgKHR5cGVvZiBpZCAhPSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIGlmIChzY29wZS5jb250ZXh0LmRlcmVmZXJlbmNlKVxuICAgICAgICByZXR1cm4gZnJvbUpTKGF3YWl0IHNjb3BlLmNvbnRleHQuZGVyZWZlcmVuY2UoeyBfcmVmOiBpZCB9KSk7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGRvYyBvZiBzY29wZS5zb3VyY2UpXG4gICAgICAgIGlmIChkb2MudHlwZSA9PT0gXCJvYmplY3RcIiAmJiBpZCA9PT0gZG9jLmRhdGEuX2lkKVxuICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gIH0sXG4gIFZhbHVlOiBjb25zdGFudEV4ZWN1dG9yKCh7IHZhbHVlIH0pID0+IGZyb21KUyh2YWx1ZSkpLFxuICBHcm91cDoge1xuICAgIGV4ZWN1dGVTeW5jKHsgYmFzZSB9LCBzY29wZSkge1xuICAgICAgcmV0dXJuIGV4ZWN1dGVTeW5jKGJhc2UsIHNjb3BlKTtcbiAgICB9LFxuICAgIGV4ZWN1dGVBc3luYyh7IGJhc2UgfSwgc2NvcGUpIHtcbiAgICAgIHJldHVybiBleGVjdXRlQXN5bmMoYmFzZSwgc2NvcGUpO1xuICAgIH1cbiAgfSxcbiAgT2JqZWN0OiB7XG4gICAgZXhlY3V0ZVN5bmMoeyBhdHRyaWJ1dGVzIH0sIHNjb3BlKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnN0IGF0dHJUeXBlID0gYXR0ci50eXBlO1xuICAgICAgICBzd2l0Y2ggKGF0dHIudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiOiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGV4ZWN1dGVTeW5jKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICAgIHJlc3VsdFthdHRyLm5hbWVdID0gdmFsdWUuZGF0YTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiT2JqZWN0Q29uZGl0aW9uYWxTcGxhdFwiOiB7XG4gICAgICAgICAgICBjb25zdCBjb25kID0gZXhlY3V0ZVN5bmMoYXR0ci5jb25kaXRpb24sIHNjb3BlKTtcbiAgICAgICAgICAgIGlmIChjb25kLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IGNvbmQuZGF0YSA9PT0gITEpXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBleGVjdXRlU3luYyhhdHRyLnZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgICB2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiT2JqZWN0U3BsYXRcIjoge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBleGVjdXRlU3luYyhhdHRyLnZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgICB2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG5vZGUgdHlwZTogJHthdHRyVHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21KUyhyZXN1bHQpO1xuICAgIH0sXG4gICAgYXN5bmMgZXhlY3V0ZUFzeW5jKHsgYXR0cmlidXRlcyB9LCBzY29wZSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgYXR0cmlidXRlcykge1xuICAgICAgICBjb25zdCBhdHRyVHlwZSA9IGF0dHIudHlwZTtcbiAgICAgICAgc3dpdGNoIChhdHRyLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiT2JqZWN0QXR0cmlidXRlVmFsdWVcIjoge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlQXN5bmMoYXR0ci52YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgICAgcmVzdWx0W2F0dHIubmFtZV0gPSBhd2FpdCB2YWx1ZS5nZXQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiT2JqZWN0Q29uZGl0aW9uYWxTcGxhdFwiOiB7XG4gICAgICAgICAgICBjb25zdCBjb25kID0gYXdhaXQgZXhlY3V0ZUFzeW5jKGF0dHIuY29uZGl0aW9uLCBzY29wZSk7XG4gICAgICAgICAgICBpZiAoY29uZC50eXBlICE9PSBcImJvb2xlYW5cIiB8fCBjb25kLmRhdGEgPT09ICExKVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZUFzeW5jKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICAgIHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHZhbHVlLmRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJPYmplY3RTcGxhdFwiOiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGVBc3luYyhhdHRyLnZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgICB2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG5vZGUgdHlwZTogJHthdHRyVHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21KUyhyZXN1bHQpO1xuICAgIH1cbiAgfSxcbiAgQXJyYXk6IHtcbiAgICBleGVjdXRlU3luYyh7IGVsZW1lbnRzIH0sIHNjb3BlKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGV4ZWN1dGVTeW5jKGVsZW1lbnQudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgaWYgKGVsZW1lbnQuaXNTcGxhdCkge1xuICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUuZGF0YSlcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2godik7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlLmRhdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheShyZXN1bHQpO1xuICAgIH0sXG4gICAgYXN5bmMgZXhlY3V0ZUFzeW5jKHsgZWxlbWVudHMgfSwgc2NvcGUpIHtcbiAgICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlQXN5bmMoZWxlbWVudC52YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgIGlmIChlbGVtZW50LmlzU3BsYXQpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5pc0FycmF5KCkpXG4gICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgdiBvZiB2YWx1ZSlcbiAgICAgICAgICAgICAgICB5aWVsZCB2O1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgVHVwbGU6IGNvbnN0YW50RXhlY3V0b3IoKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcInR1cGxlcyBjYW4gbm90IGJlIGV2YWx1YXRlZFwiKTtcbiAgfSksXG4gIE9yOiBtYXBwZWRFeGVjdXRvcihcbiAgICAoeyBsZWZ0LCByaWdodCB9KSA9PiBbbGVmdCwgcmlnaHRdLFxuICAgIChfLCBsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpID0+IGxlZnRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBsZWZ0VmFsdWUuZGF0YSA9PT0gITAgfHwgcmlnaHRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIiAmJiByaWdodFZhbHVlLmRhdGEgPT09ICEwID8gVFJVRV9WQUxVRSA6IGxlZnRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIiB8fCByaWdodFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiID8gTlVMTF9WQUxVRSA6IEZBTFNFX1ZBTFVFXG4gICksXG4gIEFuZDogbWFwcGVkRXhlY3V0b3IoXG4gICAgKHsgbGVmdCwgcmlnaHQgfSkgPT4gW2xlZnQsIHJpZ2h0XSxcbiAgICAoXywgbGVmdFZhbHVlLCByaWdodFZhbHVlKSA9PiBsZWZ0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgbGVmdFZhbHVlLmRhdGEgPT09ICExIHx8IHJpZ2h0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgcmlnaHRWYWx1ZS5kYXRhID09PSAhMSA/IEZBTFNFX1ZBTFVFIDogbGVmdFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIgPyBOVUxMX1ZBTFVFIDogVFJVRV9WQUxVRVxuICApLFxuICBOb3Q6IG1hcHBlZEV4ZWN1dG9yKFxuICAgICh7IGJhc2UgfSkgPT4gW2Jhc2VdLFxuICAgIChfLCB2YWx1ZSkgPT4gdmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIgPyBOVUxMX1ZBTFVFIDogdmFsdWUuZGF0YSA/IEZBTFNFX1ZBTFVFIDogVFJVRV9WQUxVRVxuICApLFxuICBOZWc6IG1hcHBlZEV4ZWN1dG9yKFxuICAgICh7IGJhc2UgfSkgPT4gW2Jhc2VdLFxuICAgIChfLCB2YWx1ZSkgPT4gdmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiA/IE5VTExfVkFMVUUgOiBmcm9tTnVtYmVyKC12YWx1ZS5kYXRhKVxuICApLFxuICBQb3M6IG1hcHBlZEV4ZWN1dG9yKFxuICAgICh7IGJhc2UgfSkgPT4gW2Jhc2VdLFxuICAgIChfLCB2YWx1ZSkgPT4gdmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiA/IE5VTExfVkFMVUUgOiBmcm9tTnVtYmVyKHZhbHVlLmRhdGEpXG4gICksXG4gIEFzYzogY29uc3RhbnRFeGVjdXRvcigoKSA9PiBOVUxMX1ZBTFVFKSxcbiAgRGVzYzogY29uc3RhbnRFeGVjdXRvcigoKSA9PiBOVUxMX1ZBTFVFKSxcbiAgQXJyYXlDb2VyY2U6IHtcbiAgICBleGVjdXRlU3luYyh7IGJhc2UgfSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZXhlY3V0ZVN5bmMoYmFzZSwgc2NvcGUpO1xuICAgICAgcmV0dXJuIHZhbHVlLmlzQXJyYXkoKSA/IHZhbHVlIDogTlVMTF9WQUxVRTtcbiAgICB9LFxuICAgIGFzeW5jIGV4ZWN1dGVBc3luYyh7IGJhc2UgfSwgc2NvcGUpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZUFzeW5jKGJhc2UsIHNjb3BlKTtcbiAgICAgIHJldHVybiB2YWx1ZS5pc0FycmF5KCkgPyB2YWx1ZSA6IE5VTExfVkFMVUU7XG4gICAgfVxuICB9LFxuICBNYXA6IGFycmF5RXhlY3V0b3IoXG4gICAgKHsgYmFzZSwgZXhwciB9KSA9PiAoeyBhcnJheTogYmFzZSwgaW5uZXI6IGV4cHIgfSksXG4gICAgZnVuY3Rpb24qIChfLCBfaXRlbSwgaW5uZXIpIHtcbiAgICAgIHlpZWxkIGlubmVyO1xuICAgIH0sXG4gICAgeyBoaWRkZW46ICEwIH1cbiAgKSxcbiAgRmxhdE1hcDogYXJyYXlFeGVjdXRvcihcbiAgICAoeyBiYXNlLCBleHByIH0pID0+ICh7IGFycmF5OiBiYXNlLCBpbm5lcjogZXhwciB9KSxcbiAgICBmdW5jdGlvbiogKF8sIF9pdGVtLCBpbm5lcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5uZXIpKVxuICAgICAgICBmb3IgKGNvbnN0IGlubmVySW5uZXIgb2YgaW5uZXIpXG4gICAgICAgICAgeWllbGQgaW5uZXJJbm5lcjtcbiAgICAgIGVsc2VcbiAgICAgICAgeWllbGQgaW5uZXI7XG4gICAgfSxcbiAgICB7IGhpZGRlbjogITAgfVxuICApXG59O1xuZnVuY3Rpb24gZXZhbHVhdGVRdWVyeSh0cmVlLCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIGV4ZWN1dGVBc3luYyh0cmVlLCBzY29wZUZyb21PcHRpb25zKG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlUXVlcnlTeW5jKHRyZWUsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gZXhlY3V0ZVN5bmModHJlZSwgc2NvcGVGcm9tT3B0aW9ucyhvcHRpb25zKSk7XG59XG5mdW5jdGlvbiBzY29wZUZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgY29uc3Qgcm9vdCA9IGZyb21KUyhvcHRpb25zLnJvb3QpLCBkYXRhc2V0ID0gZnJvbUpTKG9wdGlvbnMuZGF0YXNldCksIHBhcmFtcyA9IHsgLi4ub3B0aW9ucy5wYXJhbXMgfTtcbiAgcmV0dXJuIG5ldyBTY29wZSQxKFxuICAgIHBhcmFtcyxcbiAgICBkYXRhc2V0LFxuICAgIHJvb3QsXG4gICAge1xuICAgICAgdGltZXN0YW1wOiBvcHRpb25zLnRpbWVzdGFtcCB8fCAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgIGlkZW50aXR5OiBvcHRpb25zLmlkZW50aXR5ID09PSB2b2lkIDAgPyBcIm1lXCIgOiBvcHRpb25zLmlkZW50aXR5LFxuICAgICAgc2FuaXR5OiBvcHRpb25zLnNhbml0eSxcbiAgICAgIGFmdGVyOiBvcHRpb25zLmFmdGVyID8gZnJvbUpTKG9wdGlvbnMuYWZ0ZXIpIDogbnVsbCxcbiAgICAgIGJlZm9yZTogb3B0aW9ucy5iZWZvcmUgPyBmcm9tSlMob3B0aW9ucy5iZWZvcmUpIDogbnVsbCxcbiAgICAgIGRlcmVmZXJlbmNlOiBvcHRpb25zLmRlcmVmZXJlbmNlXG4gICAgfSxcbiAgICBudWxsXG4gICk7XG59XG5mdW5jdGlvbiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUpIHtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiR3JvdXBcIjpcbiAgICAgIHJldHVybiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUuYmFzZSk7XG4gICAgY2FzZSBcIlZhbHVlXCI6XG4gICAgY2FzZSBcIlBhcmFtZXRlclwiOlxuICAgICAgcmV0dXJuICEwO1xuICAgIGNhc2UgXCJQb3NcIjpcbiAgICBjYXNlIFwiTmVnXCI6XG4gICAgICByZXR1cm4gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlLmJhc2UpO1xuICAgIGNhc2UgXCJPcENhbGxcIjpcbiAgICAgIHN3aXRjaCAobm9kZS5vcCkge1xuICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICBjYXNlIFwiLVwiOlxuICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICBjYXNlIFwiJVwiOlxuICAgICAgICBjYXNlIFwiKipcIjpcbiAgICAgICAgICByZXR1cm4gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlLmxlZnQpICYmIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5yaWdodCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gITE7XG4gIH1cbn1cbmNvbnN0IERVTU1ZX1NDT1BFID0gbmV3IFNjb3BlJDEoXG4gIHt9LFxuICBOVUxMX1ZBTFVFLFxuICBOVUxMX1ZBTFVFLFxuICB7IHRpbWVzdGFtcDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKDApLCBpZGVudGl0eTogXCJtZVwiLCBiZWZvcmU6IG51bGwsIGFmdGVyOiBudWxsIH0sXG4gIG51bGxcbik7XG5mdW5jdGlvbiB0cnlDb25zdGFudEV2YWx1YXRlKG5vZGUpIHtcbiAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZSkgPyBjb25zdGFudEV2YWx1YXRlKG5vZGUpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICByZXR1cm4gZXhlY3V0ZVN5bmMobm9kZSwgRFVNTVlfU0NPUEUpO1xufVxuZnVuY3Rpb24gaXNTZWxlY3Rvck5vZGUobm9kZSkge1xuICByZXR1cm4gW1xuICAgIFwiQWNjZXNzQXR0cmlidXRlXCIsXG4gICAgXCJTZWxlY3RvckZ1bmNDYWxsXCIsXG4gICAgXCJHcm91cFwiLFxuICAgIFwiVHVwbGVcIixcbiAgICBcIkFycmF5Q29lcmNlXCIsXG4gICAgXCJGaWx0ZXJcIixcbiAgICBcIlNlbGVjdG9yTmVzdGVkXCJcbiAgXS5pbmNsdWRlcyhub2RlLnR5cGUpO1xufVxuZnVuY3Rpb24gaXNTZWxlY3Rvck5lc3RlZChub2RlKSB7XG4gIHJldHVybiBbXCJBY2Nlc3NBdHRyaWJ1dGVcIiwgXCJBcnJheUNvZXJjZVwiLCBcIkZpbHRlclwiLCBcIkdyb3VwXCIsIFwiVHVwbGVcIiwgXCJTZWxlY3Rvck5lc3RlZFwiXS5pbmNsdWRlcyhcbiAgICBub2RlLnR5cGVcbiAgKTtcbn1cbmNvbnN0IGFycmF5ID0ge307XG5hcnJheS5qb2luID0gbWFwcGVkRXhlY3V0b3IoXG4gIChhcmdzKSA9PiBhcmdzLFxuICAoXywgYXJyLCBzZXApID0+IHtcbiAgICBpZiAoYXJyLnR5cGUgIT09IFwiYXJyYXlcIiB8fCBzZXAudHlwZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGxldCBidWYgPSBcIlwiLCBuZWVkU2VwID0gITE7XG4gICAgZm9yIChjb25zdCBlbGVtIG9mIGFyci5kYXRhKSB7XG4gICAgICBzd2l0Y2ggKG5lZWRTZXAgJiYgKGJ1ZiArPSBzZXAuZGF0YSksIGdldFR5cGUoZWxlbSkpIHtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgICAgIGJ1ZiArPSBgJHtlbGVtfWA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICB9XG4gICAgICBuZWVkU2VwID0gITA7XG4gICAgfVxuICAgIHJldHVybiBmcm9tU3RyaW5nKGJ1Zik7XG4gIH1cbik7XG5hcnJheS5qb2luLmFyaXR5ID0gMjtcbmFycmF5LmNvbXBhY3QgPSBhcnJheUV4ZWN1dG9yKFxuICAoW2FycmF5Ml0pID0+ICh7IGFycmF5OiBhcnJheTIgfSksXG4gIGZ1bmN0aW9uKiAoXywgaXRlbSkge1xuICAgIGl0ZW0gIT09IG51bGwgJiYgKHlpZWxkIGl0ZW0pO1xuICB9XG4pO1xuYXJyYXkuY29tcGFjdC5hcml0eSA9IDE7XG5hcnJheS51bmlxdWUgPSBhcnJheUV4ZWN1dG9yKFxuICAoYXJncykgPT4gKHsgYXJyYXk6IGFyZ3NbMF0sIHN0YXRlOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpIH0pLFxuICBmdW5jdGlvbiogKF9ub2RlLCBpdGVyLCBfaW5uZXIsIGFkZGVkKSB7XG4gICAgc3dpdGNoIChnZXRUeXBlKGl0ZXIpKSB7XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICAgIGFkZGVkLmhhcyhpdGVyKSB8fCAoYWRkZWQuYWRkKGl0ZXIpLCB5aWVsZCBpdGVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB5aWVsZCBpdGVyO1xuICAgIH1cbiAgfVxuKTtcbmFycmF5LnVuaXF1ZS5hcml0eSA9IDE7XG5hcnJheS5pbnRlcnNlY3RzID0gbWFwcGVkRXhlY3V0b3IoXG4gIChhcmdzKSA9PiBhcmdzLFxuICAoXywgYXJyMSwgYXJyMikgPT4ge1xuICAgIGlmIChhcnIxLnR5cGUgIT09IFwiYXJyYXlcIiB8fCBhcnIyLnR5cGUgIT09IFwiYXJyYXlcIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGZvciAoY29uc3QgdjEgb2YgYXJyMS5kYXRhKVxuICAgICAgZm9yIChjb25zdCB2MiBvZiBhcnIyLmRhdGEpXG4gICAgICAgIGlmIChpc0VxdWFsKGZyb21KUyh2MSksIGZyb21KUyh2MikpKVxuICAgICAgICAgIHJldHVybiBUUlVFX1ZBTFVFO1xuICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgfVxuKTtcbmFycmF5LmludGVyc2VjdHMuYXJpdHkgPSAyO1xuY29uc3QgZGF0ZVRpbWUgPSB7fTtcbmRhdGVUaW1lLm5vdyA9IGNvbnN0YW50RXhlY3V0b3IoXG4gIChfLCBzY29wZSkgPT4gZnJvbURhdGVUaW1lKG5ldyBEYXRlVGltZShzY29wZS5jb250ZXh0LnRpbWVzdGFtcCkpXG4pO1xuZGF0ZVRpbWUubm93LmFyaXR5ID0gMDtcbmFzeW5jIGZ1bmN0aW9uIHZhbHVlQXRQYXRoKGFyZywga2V5UGF0aCkge1xuICBmdW5jdGlvbiB0cnlBY2Nlc3NvcihhcmcyLCBhY2Nlc3Nvcikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXJnMlthY2Nlc3Nvcl07XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGxldCBjdXJyZW50ID0gYXdhaXQgYXJnLmdldCgpO1xuICBmb3IgKGNvbnN0IHBhcnQgb2Yga2V5UGF0aClcbiAgICBpZiAoY3VycmVudCA9IHRyeUFjY2Vzc29yKGN1cnJlbnQsIHBhcnQpLCAhY3VycmVudCkgYnJlYWs7XG4gIHJldHVybiBjdXJyZW50O1xufVxuZnVuY3Rpb24gc3RhcnRzV2l0aChrZXlQYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIHByZWZpeC5ldmVyeSgoaXRlbSwgaW5kZXgpID0+IGtleVBhdGhbaW5kZXhdID09PSBpdGVtKTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBkaWZmS2V5UGF0aHMoYmVmb3JlLCBhZnRlcikge1xuICBjb25zdCBjdXJyUGF0aHMgPSBbW11dO1xuICBmb3IgKDsgY3VyclBhdGhzLmxlbmd0aCA+IDA7ICkge1xuICAgIGNvbnN0IGN1cnJQYXRoID0gY3VyclBhdGhzLnNoaWZ0KCkgfHwgW10sIGIgPSBmcm9tSlMoYXdhaXQgdmFsdWVBdFBhdGgoYmVmb3JlLCBjdXJyUGF0aCkpLCBhID0gZnJvbUpTKGF3YWl0IHZhbHVlQXRQYXRoKGFmdGVyLCBjdXJyUGF0aCkpO1xuICAgIGlmIChhLnR5cGUgIT09IGIudHlwZSlcbiAgICAgIHlpZWxkIGN1cnJQYXRoO1xuICAgIGVsc2UgaWYgKGEudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBiLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgYS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBiLnR5cGUgPT09IFwiYm9vbGVhblwiIHx8IGEudHlwZSA9PT0gXCJudWxsXCIgJiYgYi50eXBlID09PSBcIm51bGxcIiB8fCBhLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgYi50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgYS5kYXRhICE9PSBiLmRhdGEgJiYgKHlpZWxkIGN1cnJQYXRoKTtcbiAgICBlbHNlIGlmIChhLnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiBiLnR5cGUgPT09IFwiZGF0ZXRpbWVcIilcbiAgICAgIGEuZGF0YS5lcXVhbHMoYi5kYXRhKSB8fCAoeWllbGQgY3VyclBhdGgpO1xuICAgIGVsc2UgaWYgKGEudHlwZSA9PT0gXCJvYmplY3RcIiAmJiBiLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmICghZGVlcEVxdWFsKGEuZGF0YSwgYi5kYXRhKSkge1xuICAgICAgICBjb25zdCBhS2V5cyA9IE9iamVjdC5rZXlzKGEuZGF0YSksIGJLZXlzID0gT2JqZWN0LmtleXMoYi5kYXRhKTtcbiAgICAgICAgbmV3IFNldChhS2V5cy5jb25jYXQoYktleXMpKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICBjdXJyUGF0aHMucHVzaChbLi4uY3VyclBhdGgsIGtleV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGEudHlwZSA9PT0gXCJhcnJheVwiICYmIGIudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICBpZiAoYS5kYXRhLmxlbmd0aCAhPT0gYi5kYXRhLmxlbmd0aClcbiAgICAgICAgeWllbGQgY3VyclBhdGg7XG4gICAgICBlbHNlIGlmICghZGVlcEVxdWFsKGEuZGF0YSwgYi5kYXRhKSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiLmRhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgY3VyclBhdGhzLnB1c2goWy4uLmN1cnJQYXRoLCBpXSk7XG4gICAgfSBlbHNlIGlmIChhLnR5cGUgPT09IFwic3RyZWFtXCIgJiYgYi50eXBlID09PSBcInN0cmVhbVwiKSB7XG4gICAgICBjb25zdCBhcnJheUEgPSBhd2FpdCBhLmdldCgpLCBhcnJheUIgPSBhd2FpdCBiLmdldCgpO1xuICAgICAgaWYgKGFycmF5QS5sZW5ndGggIT09IGFycmF5Qi5sZW5ndGgpXG4gICAgICAgIHlpZWxkIGN1cnJQYXRoO1xuICAgICAgZWxzZSBpZiAoIWRlZXBFcXVhbChhcnJheUEsIGFycmF5QikpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlCLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIGN1cnJQYXRocy5wdXNoKFsuLi5jdXJyUGF0aCwgaV0pO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZXZhbHVhdGVTZWxlY3Rvcihub2RlLCB2YWx1ZSwgc2NvcGUpIHtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiR3JvdXBcIjpcbiAgICAgIHJldHVybiBhd2FpdCBldmFsdWF0ZVNlbGVjdG9yKG5vZGUuYmFzZSwgdmFsdWUsIHNjb3BlKTtcbiAgICBjYXNlIFwiVHVwbGVcIjpcbiAgICAgIGNvbnN0IHR1cGxlUGF0aHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIG5vZGUubWVtYmVycykge1xuICAgICAgICBjb25zdCBtZW1iZXJQYXRocyA9IGF3YWl0IGV2YWx1YXRlU2VsZWN0b3IobWVtYmVyLCB2YWx1ZSwgc2NvcGUpO1xuICAgICAgICB0dXBsZVBhdGhzLnB1c2goLi4ubWVtYmVyUGF0aHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR1cGxlUGF0aHM7XG4gICAgY2FzZSBcIkFjY2Vzc0F0dHJpYnV0ZVwiOlxuICAgICAgcmV0dXJuIG5vZGUuYmFzZSA/IChhd2FpdCBldmFsdWF0ZVNlbGVjdG9yKG5vZGUuYmFzZSwgdmFsdWUsIHNjb3BlKSkubWFwKChwYXRoKSA9PiBbLi4ucGF0aCwgbm9kZS5uYW1lXSkgOiBbW25vZGUubmFtZV1dO1xuICAgIGNhc2UgXCJBcnJheUNvZXJjZVwiOiB7XG4gICAgICBjb25zdCBwYXRocyA9IGF3YWl0IGV2YWx1YXRlU2VsZWN0b3Iobm9kZS5iYXNlLCB2YWx1ZSwgc2NvcGUpLCBhcnJheVBhdGhzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGtleVBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgY29uc3QgaW5uZXJWYWx1ZSA9IGF3YWl0IHZhbHVlQXRQYXRoKHZhbHVlLCBrZXlQYXRoKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5uZXJWYWx1ZSkpXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbm5lclZhbHVlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgYXJyYXlQYXRocy5wdXNoKFsuLi5rZXlQYXRoLCBpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlQYXRocztcbiAgICB9XG4gICAgY2FzZSBcIkZpbHRlclwiOiB7XG4gICAgICBjb25zdCBwYXRocyA9IGF3YWl0IGV2YWx1YXRlU2VsZWN0b3Iobm9kZS5iYXNlLCB2YWx1ZSwgc2NvcGUpLCBmaWx0ZXIgPSB7XG4gICAgICAgIC4uLm5vZGUsXG4gICAgICAgIGJhc2U6IHsgdHlwZTogXCJUaGlzXCIgfVxuICAgICAgfSwgYXJyYXlQYXRocyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBrZXlQYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgIGNvbnN0IGlubmVyVmFsdWUgPSBhd2FpdCB2YWx1ZUF0UGF0aCh2YWx1ZSwga2V5UGF0aCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlubmVyVmFsdWUpKVxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5uZXJWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGlubmVyVmFsdWVbaV0sIG5lc3RlZFNjb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKGZyb21KUyhbaXRlbV0pKTtcbiAgICAgICAgICAgIChhd2FpdCAoYXdhaXQgZXZhbHVhdGUoZmlsdGVyLCBuZXN0ZWRTY29wZSkpLmdldCgpKS5sZW5ndGggPiAwICYmIGFycmF5UGF0aHMucHVzaChbLi4ua2V5UGF0aCwgaV0pO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVBhdGhzO1xuICAgIH1cbiAgICBjYXNlIFwiU2VsZWN0b3JGdW5jQ2FsbFwiOlxuICAgICAgcmV0dXJuIGFueXdoZXJlKG5vZGUuYXJnLCBzY29wZS5jcmVhdGVIaWRkZW4odmFsdWUpKTtcbiAgICBjYXNlIFwiU2VsZWN0b3JOZXN0ZWRcIjoge1xuICAgICAgY29uc3QgeyBiYXNlLCBuZXN0ZWQ6IGV4cHIgfSA9IG5vZGUsIHBhdGhzID0gYXdhaXQgZXZhbHVhdGVTZWxlY3RvcihiYXNlLCB2YWx1ZSwgc2NvcGUpLCBuZXN0ZWRQYXRocyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBrZXlQYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgIGNvbnN0IGlubmVyVmFsdWUgPSBhd2FpdCB2YWx1ZUF0UGF0aCh2YWx1ZSwga2V5UGF0aCk7XG4gICAgICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIkFjY2Vzc0F0dHJpYnV0ZVwiOlxuICAgICAgICAgIGNhc2UgXCJBcnJheUNvZXJjZVwiOlxuICAgICAgICAgIGNhc2UgXCJGaWx0ZXJcIjpcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc1BhdGhzID0gYXdhaXQgZXZhbHVhdGVTZWxlY3RvcihleHByLCBmcm9tSlMoaW5uZXJWYWx1ZSksIHNjb3BlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWNjZXNzUGF0aHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgIG5lc3RlZFBhdGhzLnB1c2goWy4uLmtleVBhdGgsIC4uLmFjY2Vzc1BhdGhzW2ldXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiR3JvdXBcIjpcbiAgICAgICAgICAgIGNvbnN0IGlubmVyUmVzdWx0ID0gYXdhaXQgZXZhbHVhdGVTZWxlY3RvcihleHByLmJhc2UsIGZyb21KUyhpbm5lclZhbHVlKSwgc2NvcGUpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbm5lcktleVBhdGggb2YgaW5uZXJSZXN1bHQpXG4gICAgICAgICAgICAgIG5lc3RlZFBhdGhzLnB1c2goWy4uLmtleVBhdGgsIC4uLmlubmVyS2V5UGF0aF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIlR1cGxlXCI6XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlubmVyIG9mIGV4cHIubWVtYmVycykge1xuICAgICAgICAgICAgICBjb25zdCBpbm5lclJlc3VsdDIgPSBhd2FpdCBldmFsdWF0ZVNlbGVjdG9yKGlubmVyLCBmcm9tSlMoaW5uZXJWYWx1ZSksIHNjb3BlKTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBpbm5lcktleVBhdGggb2YgaW5uZXJSZXN1bHQyKVxuICAgICAgICAgICAgICAgIG5lc3RlZFBhdGhzLnB1c2goWy4uLmtleVBhdGgsIC4uLmlubmVyS2V5UGF0aF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmVzdGVkUGF0aHM7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBhbnl3aGVyZShleHByLCBzY29wZSwgYmFzZSA9IFtdKSB7XG4gIGNvbnN0IHZhbHVlID0gc2NvcGUudmFsdWUsIHBhdGhMaXN0ID0gW107XG4gIGlmICh2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICBjb25zdCBhcnIgPSBhd2FpdCB2YWx1ZS5nZXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3ViUGF0aHMgPSBhd2FpdCBhbnl3aGVyZShleHByLCBzY29wZS5jcmVhdGVIaWRkZW4oZnJvbUpTKGFycltpXSkpLCBbLi4uYmFzZSwgaV0pO1xuICAgICAgcGF0aExpc3QucHVzaCguLi5zdWJQYXRocyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBldmFsdWF0ZShleHByLCBzY29wZSk7XG4gICAgcmVzdWx0LnR5cGUgPT09IFwiYm9vbGVhblwiICYmIHJlc3VsdC5kYXRhID09PSAhMCAmJiBwYXRoTGlzdC5wdXNoKGJhc2UpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbHVlLmRhdGEpKSB7XG4gICAgICBjb25zdCBzdWJQYXRocyA9IGF3YWl0IGFueXdoZXJlKGV4cHIsIHNjb3BlLmNyZWF0ZUhpZGRlbihmcm9tSlModmFsdWUuZGF0YVtrZXldKSksIFtcbiAgICAgICAgLi4uYmFzZSxcbiAgICAgICAga2V5XG4gICAgICBdKTtcbiAgICAgIHBhdGhMaXN0LnB1c2goLi4uc3ViUGF0aHMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0aExpc3Q7XG59XG5hc3luYyBmdW5jdGlvbiBjaGFuZ2VkQW55KGJlZm9yZSwgYWZ0ZXIsIHNlbGVjdG9yLCBzY29wZSkge1xuICBjb25zdCBiZWZvcmVTZWxlY3RvclNjb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKGJlZm9yZSksIGJlZm9yZVBhdGhzID0gYXdhaXQgZXZhbHVhdGVTZWxlY3RvcihcbiAgICBzZWxlY3RvcixcbiAgICBiZWZvcmVTZWxlY3RvclNjb3BlLnZhbHVlLFxuICAgIGJlZm9yZVNlbGVjdG9yU2NvcGVcbiAgKSwgYWZ0ZXJTZWxlY3RvclNjb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKGFmdGVyKSwgYWZ0ZXJQYXRocyA9IGF3YWl0IGV2YWx1YXRlU2VsZWN0b3Ioc2VsZWN0b3IsIGFmdGVyU2VsZWN0b3JTY29wZS52YWx1ZSwgYWZ0ZXJTZWxlY3RvclNjb3BlKTtcbiAgaWYgKGJlZm9yZVBhdGhzLmxlbmd0aCAhPT0gYWZ0ZXJQYXRocy5sZW5ndGgpXG4gICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gIGZvciAoY29uc3QgcGF0aCBvZiBiZWZvcmVQYXRocykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKylcbiAgICAgIGlmICh0eXBlb2YgcGF0aFtpXSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGNvbnN0IHNsaWNlID0gcGF0aC5zbGljZSgwLCBpKSwgYmVmb3JlQXJyID0gYXdhaXQgdmFsdWVBdFBhdGgoYmVmb3JlLCBzbGljZSksIGFmdGVyQXJyID0gYXdhaXQgdmFsdWVBdFBhdGgoYWZ0ZXIsIHNsaWNlKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGJlZm9yZUFycikgfHwgIUFycmF5LmlzQXJyYXkoYWZ0ZXJBcnIpIHx8IGJlZm9yZUFyci5sZW5ndGggIT09IGFmdGVyQXJyLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgICAgIH1cbiAgICBjb25zdCBiZWZvcmVWYWx1ZSA9IGF3YWl0IHZhbHVlQXRQYXRoKGJlZm9yZSwgcGF0aCksIGFmdGVyVmFsdWUgPSBhd2FpdCB2YWx1ZUF0UGF0aChhZnRlciwgcGF0aCk7XG4gICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlVmFsdWUsIGFmdGVyVmFsdWUpKVxuICAgICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xufVxuYXN5bmMgZnVuY3Rpb24gY2hhbmdlZE9ubHkoYmVmb3JlLCBhZnRlciwgc2VsZWN0b3IsIHNjb3BlKSB7XG4gIGNvbnN0IGJlZm9yZVNlbGVjdG9yU2NvcGUgPSBzY29wZS5jcmVhdGVIaWRkZW4oYmVmb3JlKSwgc2VsZWN0ZWRQYXRocyA9IGF3YWl0IGV2YWx1YXRlU2VsZWN0b3IoXG4gICAgc2VsZWN0b3IsXG4gICAgYmVmb3JlU2VsZWN0b3JTY29wZS52YWx1ZSxcbiAgICBiZWZvcmVTZWxlY3RvclNjb3BlXG4gICk7XG4gIGZvciBhd2FpdCAoY29uc3QgZGlmZlBhdGggb2YgZGlmZktleVBhdGhzKGJlZm9yZSwgYWZ0ZXIpKSB7XG4gICAgbGV0IGZvdW5kID0gITE7XG4gICAgZm9yIChjb25zdCBzZWxlY3RlZFBhdGggb2Ygc2VsZWN0ZWRQYXRocylcbiAgICAgIGlmIChzdGFydHNXaXRoKGRpZmZQYXRoLCBzZWxlY3RlZFBhdGgpKSB7XG4gICAgICAgIGZvdW5kID0gITA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGlmICghZm91bmQpXG4gICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIFRSVUVfVkFMVUU7XG59XG5jb25zdCBkaWZmID0ge307XG5kaWZmLmNoYW5nZWRBbnkgPSBhc3luY09ubHlFeGVjdXRvcihhc3luYyAoYXJncywgc2NvcGUpID0+IHtcbiAgY29uc3QgbGhzID0gYXJnc1swXSwgcmhzID0gYXJnc1sxXSwgc2VsZWN0b3IgPSBhcmdzWzJdO1xuICBpZiAoIWlzU2VsZWN0b3JOb2RlKHNlbGVjdG9yKSkgdGhyb3cgbmV3IEVycm9yKFwiY2hhbmdlZEFueSB0aGlyZCBhcmd1bWVudCBtdXN0IGJlIGEgc2VsZWN0b3JcIik7XG4gIGNvbnN0IGJlZm9yZSA9IGF3YWl0IGV4ZWN1dGVBc3luYyhsaHMsIHNjb3BlKSwgYWZ0ZXIgPSBhd2FpdCBleGVjdXRlQXN5bmMocmhzLCBzY29wZSk7XG4gIHJldHVybiBjaGFuZ2VkQW55KGJlZm9yZSwgYWZ0ZXIsIHNlbGVjdG9yLCBzY29wZSk7XG59KTtcbmRpZmYuY2hhbmdlZEFueS5hcml0eSA9IDM7XG5kaWZmLmNoYW5nZWRPbmx5ID0gYXN5bmNPbmx5RXhlY3V0b3IoYXN5bmMgKGFyZ3MsIHNjb3BlKSA9PiB7XG4gIGNvbnN0IGxocyA9IGFyZ3NbMF0sIHJocyA9IGFyZ3NbMV0sIHNlbGVjdG9yID0gYXJnc1syXTtcbiAgaWYgKCFpc1NlbGVjdG9yTm9kZShzZWxlY3RvcikpIHRocm93IG5ldyBFcnJvcihcImNoYW5nZWRPbmx5IHRoaXJkIGFyZ3VtZW50IG11c3QgYmUgYSBzZWxlY3RvclwiKTtcbiAgY29uc3QgYmVmb3JlID0gYXdhaXQgZXhlY3V0ZUFzeW5jKGxocywgc2NvcGUpLCBhZnRlciA9IGF3YWl0IGV4ZWN1dGVBc3luYyhyaHMsIHNjb3BlKTtcbiAgcmV0dXJuIGNoYW5nZWRPbmx5KGJlZm9yZSwgYWZ0ZXIsIHNlbGVjdG9yLCBzY29wZSk7XG59KTtcbmRpZmYuY2hhbmdlZE9ubHkuYXJpdHkgPSAzO1xuY29uc3QgZGVsdGEgPSB7fTtcbmRlbHRhLm9wZXJhdGlvbiA9IGNvbnN0YW50RXhlY3V0b3IoKF8sIHNjb3BlKSA9PiB7XG4gIGNvbnN0IGhhc0JlZm9yZSA9IHNjb3BlLmNvbnRleHQuYmVmb3JlICE9PSBudWxsLCBoYXNBZnRlciA9IHNjb3BlLmNvbnRleHQuYWZ0ZXIgIT09IG51bGw7XG4gIHJldHVybiBoYXNCZWZvcmUgJiYgaGFzQWZ0ZXIgPyBmcm9tU3RyaW5nKFwidXBkYXRlXCIpIDogaGFzQWZ0ZXIgPyBmcm9tU3RyaW5nKFwiY3JlYXRlXCIpIDogaGFzQmVmb3JlID8gZnJvbVN0cmluZyhcImRlbGV0ZVwiKSA6IE5VTExfVkFMVUU7XG59KTtcbmRlbHRhLmNoYW5nZWRBbnkgPSBhc3luY09ubHlFeGVjdXRvcihhc3luYyAoYXJncywgc2NvcGUpID0+IHtcbiAgY29uc3QgYmVmb3JlID0gc2NvcGUuY29udGV4dC5iZWZvcmUgfHwgTlVMTF9WQUxVRSwgYWZ0ZXIgPSBzY29wZS5jb250ZXh0LmFmdGVyIHx8IE5VTExfVkFMVUUsIHNlbGVjdG9yID0gYXJnc1swXTtcbiAgaWYgKCFpc1NlbGVjdG9yTm9kZShzZWxlY3RvcikpIHRocm93IG5ldyBFcnJvcihcImNoYW5nZWRBbnkgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHNlbGVjdG9yXCIpO1xuICByZXR1cm4gY2hhbmdlZEFueShiZWZvcmUsIGFmdGVyLCBzZWxlY3Rvciwgc2NvcGUpO1xufSk7XG5kZWx0YS5jaGFuZ2VkQW55LmFyaXR5ID0gMTtcbmRlbHRhLmNoYW5nZWRBbnkubW9kZSA9IFwiZGVsdGFcIjtcbmRlbHRhLmNoYW5nZWRPbmx5ID0gYXN5bmNPbmx5RXhlY3V0b3IoYXN5bmMgKGFyZ3MsIHNjb3BlKSA9PiB7XG4gIGNvbnN0IGJlZm9yZSA9IHNjb3BlLmNvbnRleHQuYmVmb3JlIHx8IE5VTExfVkFMVUUsIGFmdGVyID0gc2NvcGUuY29udGV4dC5hZnRlciB8fCBOVUxMX1ZBTFVFLCBzZWxlY3RvciA9IGFyZ3NbMF07XG4gIGlmICghaXNTZWxlY3Rvck5vZGUoc2VsZWN0b3IpKSB0aHJvdyBuZXcgRXJyb3IoXCJjaGFuZ2VkT25seSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc2VsZWN0b3JcIik7XG4gIHJldHVybiBjaGFuZ2VkT25seShiZWZvcmUsIGFmdGVyLCBzZWxlY3Rvciwgc2NvcGUpO1xufSk7XG5kZWx0YS5jaGFuZ2VkT25seS5hcml0eSA9IDE7XG5kZWx0YS5jaGFuZ2VkT25seS5tb2RlID0gXCJkZWx0YVwiO1xuY29uc3QgZG9jdW1lbnRzID0ge307XG5kb2N1bWVudHMuZ2V0ID0gY29uc3RhbnRFeGVjdXRvcigoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn0pO1xuZG9jdW1lbnRzLmluY29taW5nUmVmQ291bnQgPSBjb25zdGFudEV4ZWN1dG9yKCgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufSk7XG5kb2N1bWVudHMuaW5jb21pbmdHbG9iYWxEb2N1bWVudFJlZmVyZW5jZUNvdW50ID0gY29uc3RhbnRFeGVjdXRvcigoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn0pO1xuY29uc3QgZ2VvID0ge307XG5nZW8ubGF0TG5nID0gY29uc3RhbnRFeGVjdXRvcigoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn0pO1xuZ2VvLmNvbnRhaW5zID0gY29uc3RhbnRFeGVjdXRvcigoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn0pO1xuZ2VvLmludGVyc2VjdHMgPSBjb25zdGFudEV4ZWN1dG9yKCgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufSk7XG5nZW8uZGlzdGFuY2UgPSBjb25zdGFudEV4ZWN1dG9yKCgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufSk7XG5jb25zdCBzdHJpbmcgPSB7fTtcbnN0cmluZy5sb3dlciA9IG1hcHBlZEV4ZWN1dG9yKFxuICAoYXJncykgPT4gYXJncyxcbiAgKF8sIHZhbHVlKSA9PiB2YWx1ZS50eXBlICE9PSBcInN0cmluZ1wiID8gTlVMTF9WQUxVRSA6IGZyb21TdHJpbmcodmFsdWUuZGF0YS50b0xvd2VyQ2FzZSgpKVxuKTtcbnN0cmluZy5sb3dlci5hcml0eSA9IDE7XG5zdHJpbmcudXBwZXIgPSBtYXBwZWRFeGVjdXRvcihcbiAgKGFyZ3MpID0+IGFyZ3MsXG4gIChfLCB2YWx1ZSkgPT4gdmFsdWUudHlwZSAhPT0gXCJzdHJpbmdcIiA/IE5VTExfVkFMVUUgOiBmcm9tU3RyaW5nKHZhbHVlLmRhdGEudG9VcHBlckNhc2UoKSlcbik7XG5zdHJpbmcudXBwZXIuYXJpdHkgPSAxO1xuc3RyaW5nLnNwbGl0ID0gbWFwcGVkRXhlY3V0b3IoXG4gIChhcmdzKSA9PiBhcmdzLFxuICAoXywgc3RyLCBzZXApID0+IHN0ci50eXBlICE9PSBcInN0cmluZ1wiIHx8IHNlcC50eXBlICE9PSBcInN0cmluZ1wiID8gTlVMTF9WQUxVRSA6IHN0ci5kYXRhLmxlbmd0aCA9PT0gMCA/IGZyb21BcnJheShbXSkgOiBzZXAuZGF0YS5sZW5ndGggPT09IDAgPyBmcm9tQXJyYXkoQXJyYXkuZnJvbShzdHIuZGF0YSkpIDogZnJvbUFycmF5KHN0ci5kYXRhLnNwbGl0KHNlcC5kYXRhKSlcbik7XG5zdHJpbmcuc3BsaXQuYXJpdHkgPSAyO1xuc3RyaW5nLnN0YXJ0c1dpdGggPSBtYXBwZWRFeGVjdXRvcihcbiAgKGFyZ3MpID0+IGFyZ3MsXG4gIChfLCBzdHIsIHByZWZpeCkgPT4gc3RyLnR5cGUgIT09IFwic3RyaW5nXCIgfHwgcHJlZml4LnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogc3RyLmRhdGEuc3RhcnRzV2l0aChwcmVmaXguZGF0YSkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUVcbik7XG5zdHJpbmcuc3RhcnRzV2l0aC5hcml0eSA9IDI7XG5jb25zdCBfZ2xvYmFsID0ge307XG5fZ2xvYmFsLmFueXdoZXJlID0gY29uc3RhbnRFeGVjdXRvcigoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn0pO1xuX2dsb2JhbC5hbnl3aGVyZS5hcml0eSA9IDE7XG5fZ2xvYmFsLmNvYWxlc2NlID0ge1xuICBhc3luYyBleGVjdXRlQXN5bmMoYXJncywgc2NvcGUpIHtcbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGVBc3luYyhhcmcsIHNjb3BlKTtcbiAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bGxcIilcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgZXhlY3V0ZVN5bmMoYXJncywgc2NvcGUpIHtcbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGV4ZWN1dGVTeW5jKGFyZywgc2NvcGUpO1xuICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVsbFwiKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG59O1xuX2dsb2JhbC5jb3VudCA9IGFycmF5UmVkdWNlckV4ZWN1dG9yKFxuICAoYXJncykgPT4gKHsgYXJyYXk6IGFyZ3NbMF0gfSksXG4gICgpID0+IDAsXG4gIChfLCBjb3VudCkgPT4gY291bnQgKyAxLFxuICBmcm9tTnVtYmVyXG4pO1xuX2dsb2JhbC5jb3VudC5hcml0eSA9IDE7XG5fZ2xvYmFsLmRhdGVUaW1lID0gbWFwcGVkRXhlY3V0b3IoXG4gIChhcmdzKSA9PiBhcmdzLFxuICAoXywgdmFsKSA9PiB2YWwudHlwZSA9PT0gXCJkYXRldGltZVwiID8gdmFsIDogdmFsLnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogRGF0ZVRpbWUucGFyc2VUb1ZhbHVlKHZhbC5kYXRhKVxuKTtcbl9nbG9iYWwuZGF0ZVRpbWUuYXJpdHkgPSAxO1xuX2dsb2JhbC5kZWZpbmVkID0gbWFwcGVkRXhlY3V0b3IoXG4gIChhcmdzKSA9PiBhcmdzLFxuICAoXywgaW5uZXIpID0+IGlubmVyLnR5cGUgPT09IFwibnVsbFwiID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFXG4pO1xuX2dsb2JhbC5kZWZpbmVkLmFyaXR5ID0gMTtcbl9nbG9iYWwuaWRlbnRpdHkgPSBjb25zdGFudEV4ZWN1dG9yKChfYXJncywgc2NvcGUpID0+IGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5pZGVudGl0eSkpO1xuX2dsb2JhbC5pZGVudGl0eS5hcml0eSA9IDA7XG5fZ2xvYmFsLmxlbmd0aCA9IG1hcHBlZEV4ZWN1dG9yKFxuICAoYXJncykgPT4gYXJncyxcbiAgKF8sIGlubmVyKSA9PiBpbm5lci50eXBlID09PSBcInN0cmluZ1wiID8gZnJvbU51bWJlcihjb3VudFVURjgoaW5uZXIuZGF0YSkpIDogaW5uZXIudHlwZSA9PT0gXCJhcnJheVwiID8gZnJvbU51bWJlcihpbm5lci5kYXRhLmxlbmd0aCkgOiBOVUxMX1ZBTFVFXG4pO1xuX2dsb2JhbC5sZW5ndGguYXJpdHkgPSAxO1xuX2dsb2JhbC5wYXRoID0gbWFwcGVkRXhlY3V0b3IoXG4gIChhcmdzKSA9PiBhcmdzLFxuICAoXywgaW5uZXIpID0+IGlubmVyLnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogZnJvbVBhdGgobmV3IFBhdGgoaW5uZXIuZGF0YSkpXG4pO1xuX2dsb2JhbC5wYXRoLmFyaXR5ID0gMTtcbl9nbG9iYWwuc3RyaW5nID0gbWFwcGVkRXhlY3V0b3IoXG4gIChhcmdzKSA9PiBhcmdzLFxuICAoXywgdmFsdWUpID0+IHtcbiAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoYCR7dmFsdWUuZGF0YX1gKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgfVxuKTtcbl9nbG9iYWwuc3RyaW5nLmFyaXR5ID0gMTtcbl9nbG9iYWwucmVmZXJlbmNlcyA9IG1hcHBlZEV4ZWN1dG9yKFxuICAoYXJncykgPT4gW3sgdHlwZTogXCJUaGlzXCIgfSwgLi4uYXJnc10sXG4gIChfLCBzY29wZVZhbHVlLCAuLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgcGF0aFNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIGFyZ3MpXG4gICAgICBpZiAocGF0aC50eXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgICBwYXRoU2V0LmFkZChwYXRoLmRhdGEpO1xuICAgICAgZWxzZSBpZiAocGF0aC50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgIGZvciAoY29uc3QgZWxlbSBvZiBwYXRoLmRhdGEpXG4gICAgICAgICAgdHlwZW9mIGVsZW0gPT0gXCJzdHJpbmdcIiAmJiBwYXRoU2V0LmFkZChlbGVtKTtcbiAgICByZXR1cm4gcGF0aFNldC5zaXplID09PSAwID8gRkFMU0VfVkFMVUUgOiBoYXNSZWZlcmVuY2Uoc2NvcGVWYWx1ZSwgcGF0aFNldCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH1cbik7XG5fZ2xvYmFsLnJlZmVyZW5jZXMuYXJpdHkgPSAoYykgPT4gYyA+PSAxO1xuX2dsb2JhbC5yb3VuZCA9IG1hcHBlZEV4ZWN1dG9yKFxuICAoYXJncykgPT4gYXJncyxcbiAgKF8sIHZhbHVlLCBwcmVjVmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IG51bSA9IHZhbHVlLmRhdGE7XG4gICAgbGV0IHByZWMgPSAwO1xuICAgIGlmIChwcmVjVmFsdWUpIHtcbiAgICAgIGlmIChwcmVjVmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiB8fCBwcmVjVmFsdWUuZGF0YSA8IDAgfHwgIU51bWJlci5pc0ludGVnZXIocHJlY1ZhbHVlLmRhdGEpKVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIHByZWMgPSBwcmVjVmFsdWUuZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHByZWMgPT09IDAgPyBudW0gPCAwID8gZnJvbU51bWJlcigtTWF0aC5yb3VuZCgtbnVtKSkgOiBmcm9tTnVtYmVyKE1hdGgucm91bmQobnVtKSkgOiBmcm9tTnVtYmVyKE51bWJlcihudW0udG9GaXhlZChwcmVjKSkpO1xuICB9XG4pO1xuX2dsb2JhbC5yb3VuZC5hcml0eSA9IChjb3VudCkgPT4gY291bnQgPj0gMSAmJiBjb3VudCA8PSAyO1xuX2dsb2JhbC5ub3cgPSBjb25zdGFudEV4ZWN1dG9yKChfYXJncywgc2NvcGUpID0+IGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC50aW1lc3RhbXAudG9JU09TdHJpbmcoKSkpO1xuX2dsb2JhbC5ub3cuYXJpdHkgPSAwO1xuX2dsb2JhbC5ib29zdCA9IGNvbnN0YW50RXhlY3V0b3IoKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIGJvb3N0IGNhbGxcIik7XG59KTtcbl9nbG9iYWwuYm9vc3QuYXJpdHkgPSAyO1xuX2dsb2JhbC5sb3dlciA9IHN0cmluZy5sb3dlcjtcbl9nbG9iYWwudXBwZXIgPSBzdHJpbmcudXBwZXI7XG5mdW5jdGlvbiBjb3VudFVURjgoc3RyKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGNvZGUgPj0gNTUyOTYgJiYgY29kZSA8PSA1NjMxOSB8fCBjb3VudCsrO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIGhhc1JlZmVyZW5jZSh2YWx1ZSwgcGF0aFNldCkge1xuICBzd2l0Y2ggKGdldFR5cGUodmFsdWUpKSB7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpXG4gICAgICAgIGlmIChoYXNSZWZlcmVuY2UodiwgcGF0aFNldCkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYgKHZhbHVlLl9yZWYpXG4gICAgICAgIHJldHVybiBwYXRoU2V0Lmhhcyh2YWx1ZS5fcmVmKTtcbiAgICAgIGZvciAoY29uc3QgdiBvZiBPYmplY3QudmFsdWVzKHZhbHVlKSlcbiAgICAgICAgaWYgKGhhc1JlZmVyZW5jZSh2LCBwYXRoU2V0KSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gITE7XG59XG5jb25zdCBtYXRoID0ge307XG5tYXRoLm1pbiA9IGFycmF5UmVkdWNlckV4ZWN1dG9yKFxuICAoYXJncykgPT4gKHsgYXJyYXk6IGFyZ3NbMF0gfSksXG4gICgpID0+IHtcbiAgfSxcbiAgKF8sIG4sIGl0ZW0pID0+IGl0ZW0gPT09IG51bGwgPyBuIDogdHlwZW9mIGl0ZW0gIT0gXCJudW1iZXJcIiA/IFNUT1BfSVRFUkFUT1IgOiBuID09PSB2b2lkIDAgfHwgaXRlbSA8IG4gPyBpdGVtIDogbixcbiAgKG4pID0+IG4gPT09IHZvaWQgMCA/IE5VTExfVkFMVUUgOiBmcm9tTnVtYmVyKG4pXG4pO1xubWF0aC5taW4uYXJpdHkgPSAxO1xubWF0aC5tYXggPSBhcnJheVJlZHVjZXJFeGVjdXRvcihcbiAgKGFyZ3MpID0+ICh7IGFycmF5OiBhcmdzWzBdIH0pLFxuICAoKSA9PiB7XG4gIH0sXG4gIChfLCBuLCBpdGVtKSA9PiBpdGVtID09PSBudWxsID8gbiA6IHR5cGVvZiBpdGVtICE9IFwibnVtYmVyXCIgPyBTVE9QX0lURVJBVE9SIDogbiA9PT0gdm9pZCAwIHx8IGl0ZW0gPiBuID8gaXRlbSA6IG4sXG4gIChuKSA9PiBuID09PSB2b2lkIDAgPyBOVUxMX1ZBTFVFIDogZnJvbU51bWJlcihuKVxuKTtcbm1hdGgubWF4LmFyaXR5ID0gMTtcbm1hdGguc3VtID0gYXJyYXlSZWR1Y2VyRXhlY3V0b3IoXG4gIChhcmdzKSA9PiAoeyBhcnJheTogYXJnc1swXSB9KSxcbiAgKCkgPT4gMCxcbiAgKF8sIG4sIGl0ZW0pID0+IGl0ZW0gPT09IG51bGwgPyBuIDogdHlwZW9mIGl0ZW0gIT0gXCJudW1iZXJcIiA/IFNUT1BfSVRFUkFUT1IgOiBuICsgaXRlbSxcbiAgZnJvbU51bWJlclxuKTtcbm1hdGguc3VtLmFyaXR5ID0gMTtcbm1hdGguYXZnID0gYXJyYXlSZWR1Y2VyRXhlY3V0b3IoXG4gIChhcmdzKSA9PiAoeyBhcnJheTogYXJnc1swXSB9KSxcbiAgKCkgPT4gKHsgY291bnQ6IDAsIHN1bTogMCB9KSxcbiAgKF8sIHsgY291bnQsIHN1bSB9LCBpdGVtKSA9PiBpdGVtID09PSBudWxsID8geyBjb3VudCwgc3VtIH0gOiB0eXBlb2YgaXRlbSAhPSBcIm51bWJlclwiID8gU1RPUF9JVEVSQVRPUiA6IHsgY291bnQ6IGNvdW50ICsgMSwgc3VtOiBzdW0gKyBpdGVtIH0sXG4gICh7IGNvdW50LCBzdW0gfSkgPT4gY291bnQgPT09IDAgPyBOVUxMX1ZBTFVFIDogZnJvbU51bWJlcihzdW0gLyBjb3VudClcbik7XG5tYXRoLmF2Zy5hcml0eSA9IDE7XG5jb25zdCBtZWRpYSA9IHt9O1xubWVkaWEuYXNwZWN0ID0gY29uc3RhbnRFeGVjdXRvcigoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn0pO1xubWVkaWEuYXNwZWN0LmFyaXR5ID0gMjtcbmZ1bmN0aW9uIHBvcnRhYmxlVGV4dENvbnRlbnQodmFsdWUpIHtcbiAgaWYgKHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIGJsb2NrVGV4dCh2YWx1ZS5kYXRhKTtcbiAgaWYgKHZhbHVlLnR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgIGNvbnN0IHRleHRzID0gYXJyYXlUZXh0KHZhbHVlLmRhdGEpO1xuICAgIGlmICh0ZXh0cy5sZW5ndGggPiAwKVxuICAgICAgcmV0dXJuIHRleHRzLmpvaW4oYFxuXG5gKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGFycmF5VGV4dCh2YWx1ZSwgcmVzdWx0ID0gW10pIHtcbiAgZm9yIChjb25zdCBibG9jayBvZiB2YWx1ZSlcbiAgICBpZiAoQXJyYXkuaXNBcnJheShibG9jaykpXG4gICAgICBhcnJheVRleHQoYmxvY2ssIHJlc3VsdCk7XG4gICAgZWxzZSBpZiAodHlwZW9mIGJsb2NrID09IFwib2JqZWN0XCIgJiYgYmxvY2spIHtcbiAgICAgIGNvbnN0IHRleHQyID0gYmxvY2tUZXh0KGJsb2NrKTtcbiAgICAgIHRleHQyICE9PSBudWxsICYmIHJlc3VsdC5wdXNoKHRleHQyKTtcbiAgICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBibG9ja1RleHQob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqLl90eXBlICE9IFwic3RyaW5nXCIpIHJldHVybiBudWxsO1xuICBjb25zdCBjaGlsZHJlbiA9IG9iai5jaGlsZHJlbjtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgcmV0dXJuIG51bGw7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgIGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBjaGlsZC5fdHlwZSA9PSBcInN0cmluZ1wiICYmIGNoaWxkLl90eXBlID09PSBcInNwYW5cIiAmJiB0eXBlb2YgY2hpbGQudGV4dCA9PSBcInN0cmluZ1wiICYmIChyZXN1bHQgKz0gY2hpbGQudGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBwdCA9IHt9O1xucHQudGV4dCA9IG1hcHBlZEV4ZWN1dG9yKFxuICAoYXJncykgPT4gYXJncyxcbiAgZnVuY3Rpb24oXywgdmFsdWUpIHtcbiAgICBjb25zdCB0ZXh0MiA9IHBvcnRhYmxlVGV4dENvbnRlbnQodmFsdWUpO1xuICAgIHJldHVybiB0ZXh0MiA9PT0gbnVsbCA/IE5VTExfVkFMVUUgOiBmcm9tU3RyaW5nKHRleHQyKTtcbiAgfVxuKTtcbnB0LnRleHQuYXJpdHkgPSAxO1xuY29uc3QgcmVsZWFzZXMgPSB7fTtcbnJlbGVhc2VzLmFsbCA9IGFycmF5RXhlY3V0b3IoXG4gICgpID0+ICh7IGFycmF5OiB7IHR5cGU6IFwiRXZlcnl0aGluZ1wiIH0gfSksXG4gIGZ1bmN0aW9uKiAoXywgdmFsdWUpIHtcbiAgICB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAmJiBcIl90eXBlXCIgaW4gdmFsdWUgJiYgdmFsdWUuX3R5cGUgPT09IFwic3lzdGVtLnJlbGVhc2VcIiAmJiAoeWllbGQgdmFsdWUpO1xuICB9XG4pO1xucmVsZWFzZXMuYWxsLmFyaXR5ID0gMDtcbmNvbnN0IHNhbml0eSA9IHt9O1xuc2FuaXR5LnByb2plY3RJZCA9IGNvbnN0YW50RXhlY3V0b3IoKF8sIHNjb3BlKSA9PiBzY29wZS5jb250ZXh0LnNhbml0eSA/IGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5zYW5pdHkucHJvamVjdElkKSA6IE5VTExfVkFMVUUpO1xuc2FuaXR5LmRhdGFzZXQgPSBjb25zdGFudEV4ZWN1dG9yKChfLCBzY29wZSkgPT4gc2NvcGUuY29udGV4dC5zYW5pdHkgPyBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuc2FuaXR5LmRhdGFzZXQpIDogTlVMTF9WQUxVRSk7XG5zYW5pdHkudmVyc2lvbk9mID0gbWFwcGVkRXhlY3V0b3IoXG4gIChbdmFsdWVdKSA9PiBbdmFsdWUsIHsgdHlwZTogXCJUaGlzXCIgfV0sXG4gIChfLCB2YWx1ZSwgdmFsKSA9PiB7XG4gICAgaWYgKHZhbHVlLnR5cGUgIT09IFwic3RyaW5nXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IGJhc2VJZCA9IHZhbHVlLmRhdGE7XG4gICAgaWYgKHZhbC50eXBlICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWwuZGF0YS5faWQgIT0gXCJzdHJpbmdcIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgaWYgKHZhbC5kYXRhLl9pZCA9PT0gYmFzZUlkKSByZXR1cm4gVFJVRV9WQUxVRTtcbiAgICBjb25zdCBjb21wb25lbnRzID0gdmFsLmRhdGEuX2lkLnNwbGl0KFwiLlwiKTtcbiAgICByZXR1cm4gY29tcG9uZW50cy5sZW5ndGggPj0gMiAmJiBjb21wb25lbnRzWzBdID09PSBcImRyYWZ0c1wiICYmIGNvbXBvbmVudHMuc2xpY2UoMSkuam9pbihcIi5cIikgPT09IGJhc2VJZCB8fCBjb21wb25lbnRzLmxlbmd0aCA+PSAzICYmIGNvbXBvbmVudHNbMF0gPT09IFwidmVyc2lvbnNcIiAmJiBjb21wb25lbnRzLnNsaWNlKDIpLmpvaW4oXCIuXCIpID09PSBiYXNlSWQgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH1cbik7XG5zYW5pdHkudmVyc2lvbk9mLmFyaXR5ID0gMTtcbnNhbml0eS5wYXJ0T2ZSZWxlYXNlID0gbWFwcGVkRXhlY3V0b3IoXG4gIChhcmdzKSA9PiBbYXJnc1swXSwgeyB0eXBlOiBcIlRoaXNcIiB9XSxcbiAgKF8sIHZhbHVlLCB2YWwpID0+IHtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgYmFzZUlkID0gdmFsdWUuZGF0YTtcbiAgICBpZiAodmFsLnR5cGUgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbC5kYXRhLl9pZCAhPSBcInN0cmluZ1wiKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCBjb21wb25lbnRzID0gdmFsLmRhdGEuX2lkLnNwbGl0KFwiLlwiKTtcbiAgICByZXR1cm4gY29tcG9uZW50cy5sZW5ndGggPj0gMyAmJiBjb21wb25lbnRzWzBdID09PSBcInZlcnNpb25zXCIgJiYgY29tcG9uZW50c1sxXSA9PT0gYmFzZUlkID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9XG4pO1xuc2FuaXR5LnBhcnRPZlJlbGVhc2UuYXJpdHkgPSAxO1xuY29uc3QgdGV4dCA9IHt9O1xudGV4dC5xdWVyeSA9IGNvbnN0YW50RXhlY3V0b3IoKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59KTtcbnRleHQucXVlcnkuYXJpdHkgPSAxO1xuY29uc3QgQk0yNWsgPSAxLjI7XG5hc3luYyBmdW5jdGlvbiBldmFsdWF0ZVNjb3JlQXN5bmMobm9kZSwgc2NvcGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJPcENhbGxcIiAmJiBub2RlLm9wID09PSBcIm1hdGNoXCIpXG4gICAgcmV0dXJuIGV2YWx1YXRlTWF0Y2hTY29yZUFzeW5jKG5vZGUubGVmdCwgbm9kZS5yaWdodCwgc2NvcGUpO1xuICBpZiAobm9kZS50eXBlID09PSBcIkZ1bmNDYWxsXCIgJiYgbm9kZS5uYW1lID09PSBcImJvb3N0XCIpIHtcbiAgICBjb25zdCBpbm5lclNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZUFzeW5jKG5vZGUuYXJnc1swXSwgc2NvcGUpLCBib29zdCA9IGF3YWl0IGV4ZWN1dGVBc3luYyhub2RlLmFyZ3NbMV0sIHNjb3BlKTtcbiAgICByZXR1cm4gYm9vc3QudHlwZSA9PT0gXCJudW1iZXJcIiAmJiBpbm5lclNjb3JlID4gMCA/IGlubmVyU2NvcmUgKyBib29zdC5kYXRhIDogMDtcbiAgfVxuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJPclwiOiB7XG4gICAgICBjb25zdCBsZWZ0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlQXN5bmMobm9kZS5sZWZ0LCBzY29wZSksIHJpZ2h0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlQXN5bmMobm9kZS5yaWdodCwgc2NvcGUpO1xuICAgICAgcmV0dXJuIGxlZnRTY29yZSArIHJpZ2h0U2NvcmU7XG4gICAgfVxuICAgIGNhc2UgXCJBbmRcIjoge1xuICAgICAgY29uc3QgbGVmdFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZUFzeW5jKG5vZGUubGVmdCwgc2NvcGUpLCByaWdodFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZUFzeW5jKG5vZGUucmlnaHQsIHNjb3BlKTtcbiAgICAgIHJldHVybiBsZWZ0U2NvcmUgPT09IDAgfHwgcmlnaHRTY29yZSA9PT0gMCA/IDAgOiBsZWZ0U2NvcmUgKyByaWdodFNjb3JlO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBleGVjdXRlQXN5bmMobm9kZSwgc2NvcGUpO1xuICAgICAgcmV0dXJuIHJlcy50eXBlID09PSBcImJvb2xlYW5cIiAmJiByZXMuZGF0YSA9PT0gITAgPyAxIDogMDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGV2YWx1YXRlU2NvcmVTeW5jKG5vZGUsIHNjb3BlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiT3BDYWxsXCIgJiYgbm9kZS5vcCA9PT0gXCJtYXRjaFwiKVxuICAgIHJldHVybiBldmFsdWF0ZU1hdGNoU2NvcmVTeW5jKG5vZGUubGVmdCwgbm9kZS5yaWdodCwgc2NvcGUpO1xuICBpZiAobm9kZS50eXBlID09PSBcIkZ1bmNDYWxsXCIgJiYgbm9kZS5uYW1lID09PSBcImJvb3N0XCIpIHtcbiAgICBjb25zdCBpbm5lclNjb3JlID0gZXZhbHVhdGVTY29yZVN5bmMobm9kZS5hcmdzWzBdLCBzY29wZSksIGJvb3N0ID0gZXhlY3V0ZVN5bmMobm9kZS5hcmdzWzFdLCBzY29wZSk7XG4gICAgcmV0dXJuIGJvb3N0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgaW5uZXJTY29yZSA+IDAgPyBpbm5lclNjb3JlICsgYm9vc3QuZGF0YSA6IDA7XG4gIH1cbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiT3JcIjoge1xuICAgICAgY29uc3QgbGVmdFNjb3JlID0gZXZhbHVhdGVTY29yZVN5bmMobm9kZS5sZWZ0LCBzY29wZSksIHJpZ2h0U2NvcmUgPSBldmFsdWF0ZVNjb3JlU3luYyhub2RlLnJpZ2h0LCBzY29wZSk7XG4gICAgICByZXR1cm4gbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcbiAgICB9XG4gICAgY2FzZSBcIkFuZFwiOiB7XG4gICAgICBjb25zdCBsZWZ0U2NvcmUgPSBldmFsdWF0ZVNjb3JlU3luYyhub2RlLmxlZnQsIHNjb3BlKSwgcmlnaHRTY29yZSA9IGV2YWx1YXRlU2NvcmVTeW5jKG5vZGUucmlnaHQsIHNjb3BlKTtcbiAgICAgIHJldHVybiBsZWZ0U2NvcmUgPT09IDAgfHwgcmlnaHRTY29yZSA9PT0gMCA/IDAgOiBsZWZ0U2NvcmUgKyByaWdodFNjb3JlO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCByZXMgPSBleGVjdXRlU3luYyhub2RlLCBzY29wZSk7XG4gICAgICByZXR1cm4gcmVzLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIHJlcy5kYXRhID09PSAhMCA/IDEgOiAwO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXZhbHVhdGVNYXRjaFNjb3JlU3luYyhsZWZ0LCByaWdodCwgc2NvcGUpIHtcbiAgY29uc3QgdGV4dDIgPSBleGVjdXRlU3luYyhsZWZ0LCBzY29wZSksIHBhdHRlcm4gPSBleGVjdXRlU3luYyhyaWdodCwgc2NvcGUpLCByZXN1bHQgPSBwcm9jZXNzTWF0Y2hTY29yZSh0ZXh0MiwgcGF0dGVybik7XG4gIGlmICh0eXBlb2YgcmVzdWx0ID09IFwibnVtYmVyXCIpIHJldHVybiByZXN1bHQ7XG4gIHRocm93IG5ldyBFcnJvcihcIkZvdW5kIHN5bmNocm9ub3VzIHZhbHVlIGluIG1hdGNoKClcIik7XG59XG5hc3luYyBmdW5jdGlvbiBldmFsdWF0ZU1hdGNoU2NvcmVBc3luYyhsZWZ0LCByaWdodCwgc2NvcGUpIHtcbiAgY29uc3QgdGV4dDIgPSBhd2FpdCBleGVjdXRlQXN5bmMobGVmdCwgc2NvcGUpLCBwYXR0ZXJuID0gYXdhaXQgZXhlY3V0ZUFzeW5jKHJpZ2h0LCBzY29wZSk7XG4gIHJldHVybiBwcm9jZXNzTWF0Y2hTY29yZSh0ZXh0MiwgcGF0dGVybik7XG59XG5mdW5jdGlvbiBwcm9jZXNzTWF0Y2hTY29yZSh0ZXh0MiwgcGF0dGVybikge1xuICBjb25zdCB0b2tlbnMgPSBnYXRoZXJUZXh0KHRleHQyLCAocGFydCkgPT4gbWF0Y2hUb2tlbml6ZShwYXJ0KSksIHRlcm1zID0gZ2F0aGVyVGV4dChwYXR0ZXJuLCAocGFydCkgPT4gbWF0Y2hQYXR0ZXJuUmVnZXgocGFydCkpLCBwcm9jZXNzID0gKHRva2VuczIsIHRlcm1zMikgPT4ge1xuICAgIGlmICghdGVybXMyLnN1Y2Nlc3MgfHwgdG9rZW5zMi5wYXJ0cy5sZW5ndGggPT09IDAgfHwgdGVybXMyLnBhcnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiAwO1xuICAgIGxldCBzY29yZSA9IDA7XG4gICAgZm9yIChjb25zdCByZSBvZiB0ZXJtczIucGFydHMpIHtcbiAgICAgIGNvbnN0IGZyZXEgPSB0b2tlbnMyLnBhcnRzLnJlZHVjZSgoYywgdG9rZW4pID0+IGMgKyAocmUudGVzdCh0b2tlbikgPyAxIDogMCksIDApO1xuICAgICAgc2NvcmUgKz0gZnJlcSAqIChCTTI1ayArIDEpIC8gKGZyZXEgKyBCTTI1ayk7XG4gICAgfVxuICAgIHJldHVybiBzY29yZTtcbiAgfTtcbiAgcmV0dXJuIFwidGhlblwiIGluIHRva2VucyB8fCBcInRoZW5cIiBpbiB0ZXJtcyA/IChhc3luYyAoKSA9PiBwcm9jZXNzKGF3YWl0IHRva2VucywgYXdhaXQgdGVybXMpKSgpIDogcHJvY2Vzcyh0b2tlbnMsIHRlcm1zKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RPcmRlckFyZ3MoYXJncykge1xuICBjb25zdCBtYXBwZXJzID0gW10sIGRpcmVjdGlvbnMgPSBbXTtcbiAgZm9yIChsZXQgbWFwcGVyIG9mIGFyZ3MpIHtcbiAgICBsZXQgZGlyZWN0aW9uID0gXCJhc2NcIjtcbiAgICBtYXBwZXIudHlwZSA9PT0gXCJEZXNjXCIgPyAoZGlyZWN0aW9uID0gXCJkZXNjXCIsIG1hcHBlciA9IG1hcHBlci5iYXNlKSA6IG1hcHBlci50eXBlID09PSBcIkFzY1wiICYmIChtYXBwZXIgPSBtYXBwZXIuYmFzZSksIG1hcHBlcnMucHVzaChtYXBwZXIpLCBkaXJlY3Rpb25zLnB1c2goZGlyZWN0aW9uKTtcbiAgfVxuICByZXR1cm4geyBtYXBwZXJzLCBkaXJlY3Rpb25zIH07XG59XG5mdW5jdGlvbiBzb3J0QXJyYXkoYXV4LCBkaXJlY3Rpb25zKSB7XG4gIHJldHVybiBhdXguc29ydCgoYVR1cGxlLCBiVHVwbGUpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcmVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBjID0gdG90YWxDb21wYXJlKGFUdXBsZVtpICsgMl0sIGJUdXBsZVtpICsgMl0pO1xuICAgICAgaWYgKGRpcmVjdGlvbnNbaV0gPT09IFwiZGVzY1wiICYmIChjID0gLWMpLCBjICE9PSAwKVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgcmV0dXJuIGFUdXBsZVsxXSAtIGJUdXBsZVsxXTtcbiAgfSksIGF1eC5tYXAoKHYpID0+IHZbMF0pO1xufVxuY29uc3QgcGlwZUZ1bmN0aW9ucyA9IHt9O1xucGlwZUZ1bmN0aW9ucy5vcmRlciA9IHtcbiAgZXhlY3V0ZVN5bmMoeyBiYXNlLCBhcmdzIH0sIHNjb3BlKSB7XG4gICAgY29uc3QgeyBtYXBwZXJzLCBkaXJlY3Rpb25zIH0gPSBleHRyYWN0T3JkZXJBcmdzKGFyZ3MpLCBhdXggPSBbXTtcbiAgICBsZXQgaWR4ID0gMDtcbiAgICBjb25zdCBuID0gZGlyZWN0aW9ucy5sZW5ndGg7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBiYXNlLmRhdGEpIHtcbiAgICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKGZyb21KUyh2YWx1ZSkpLCB0dXBsZSA9IFt2YWx1ZSwgaWR4XTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGV4ZWN1dGVTeW5jKG1hcHBlcnNbaV0sIG5ld1Njb3BlKTtcbiAgICAgICAgdHVwbGUucHVzaChyZXN1bHQuZGF0YSk7XG4gICAgICB9XG4gICAgICBhdXgucHVzaCh0dXBsZSksIGlkeCsrO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5KHNvcnRBcnJheShhdXgsIGRpcmVjdGlvbnMpKTtcbiAgfSxcbiAgYXN5bmMgZXhlY3V0ZUFzeW5jKHsgYmFzZSwgYXJncyB9LCBzY29wZSkge1xuICAgIGNvbnN0IHsgbWFwcGVycywgZGlyZWN0aW9ucyB9ID0gZXh0cmFjdE9yZGVyQXJncyhhcmdzKSwgYXV4ID0gW107XG4gICAgbGV0IGlkeCA9IDA7XG4gICAgY29uc3QgbiA9IGRpcmVjdGlvbnMubGVuZ3RoO1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgYmFzZSkge1xuICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQodmFsdWUpLCB0dXBsZSA9IFthd2FpdCB2YWx1ZS5nZXQoKSwgaWR4XTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWN1dGVBc3luYyhtYXBwZXJzW2ldLCBuZXdTY29wZSk7XG4gICAgICAgIHR1cGxlLnB1c2goYXdhaXQgcmVzdWx0LmdldCgpKTtcbiAgICAgIH1cbiAgICAgIGF1eC5wdXNoKHR1cGxlKSwgaWR4Kys7XG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXkoc29ydEFycmF5KGF1eCwgZGlyZWN0aW9ucykpO1xuICB9XG59O1xucGlwZUZ1bmN0aW9ucy5vcmRlci5hcml0eSA9IChjb3VudCkgPT4gY291bnQgPj0gMTtcbnBpcGVGdW5jdGlvbnMuc2NvcmUgPSB7XG4gIGFzeW5jIGV4ZWN1dGVBc3luYyh7IGJhc2UsIGFyZ3MgfSwgc2NvcGUpIHtcbiAgICBjb25zdCB1bmtub3duID0gW10sIHNjb3JlZCA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgYmFzZSkge1xuICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdW5rbm93bi5wdXNoKGF3YWl0IHZhbHVlLmdldCgpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgICBsZXQgdmFsdWVTY29yZSA9IHR5cGVvZiB2YWx1ZS5kYXRhLl9zY29yZSA9PSBcIm51bWJlclwiID8gdmFsdWUuZGF0YS5fc2NvcmUgOiAwO1xuICAgICAgZm9yIChjb25zdCBhcmcgb2YgYXJncylcbiAgICAgICAgdmFsdWVTY29yZSArPSBhd2FpdCBldmFsdWF0ZVNjb3JlQXN5bmMoYXJnLCBuZXdTY29wZSk7XG4gICAgICBjb25zdCBuZXdPYmplY3QgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZS5kYXRhLCB7IF9zY29yZTogdmFsdWVTY29yZSB9KTtcbiAgICAgIHNjb3JlZC5wdXNoKG5ld09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBzY29yZWQuc29ydCgoYSwgYikgPT4gYi5fc2NvcmUgLSBhLl9zY29yZSksIGZyb21KUyhzY29yZWQpO1xuICB9LFxuICBleGVjdXRlU3luYyh7IGJhc2UsIGFyZ3MgfSwgc2NvcGUpIHtcbiAgICBjb25zdCBzY29yZWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGJhc2UuZGF0YSkge1xuICAgICAgaWYgKGdldFR5cGUodmFsdWUpICE9PSBcIm9iamVjdFwiKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHZhbHVlT2JqID0gdmFsdWUsIG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKGZyb21KUyh2YWx1ZSkpO1xuICAgICAgbGV0IHZhbHVlU2NvcmUgPSB0eXBlb2YgdmFsdWVPYmouX3Njb3JlID09IFwibnVtYmVyXCIgPyB2YWx1ZU9iai5fc2NvcmUgOiAwO1xuICAgICAgZm9yIChjb25zdCBhcmcgb2YgYXJncylcbiAgICAgICAgdmFsdWVTY29yZSArPSBldmFsdWF0ZVNjb3JlU3luYyhhcmcsIG5ld1Njb3BlKTtcbiAgICAgIGNvbnN0IG5ld09iamVjdCA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlT2JqLCB7IF9zY29yZTogdmFsdWVTY29yZSB9KTtcbiAgICAgIHNjb3JlZC5wdXNoKG5ld09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBzY29yZWQuc29ydCgoYSwgYikgPT4gYi5fc2NvcmUgLSBhLl9zY29yZSksIGZyb21BcnJheShzY29yZWQpO1xuICB9XG59O1xucGlwZUZ1bmN0aW9ucy5zY29yZS5hcml0eSA9IChjb3VudCkgPT4gY291bnQgPj0gMTtcbmNvbnN0IG5hbWVzcGFjZXMgPSB7XG4gIGdsb2JhbDogX2dsb2JhbCxcbiAgc3RyaW5nLFxuICBhcnJheSxcbiAgcHQsXG4gIGRlbHRhLFxuICBkaWZmLFxuICBtZWRpYSxcbiAgc2FuaXR5LFxuICBtYXRoLFxuICBkYXRlVGltZSxcbiAgcmVsZWFzZXMsXG4gIHRleHQsXG4gIGdlbyxcbiAgZG9jdW1lbnRzXG59O1xuY2xhc3MgTWFya1Byb2Nlc3NvciB7XG4gIF9zdHJpbmc7XG4gIG1hcmtzO1xuICBpbmRleDtcbiAgY3VzdG9tRnVuY3Rpb25zO1xuICBwYXJzZU9wdGlvbnM7XG4gIGFsbG93Qm9vc3QgPSAhMTtcbiAgY29uc3RydWN0b3Ioc3RyaW5nMiwgbWFya3MsIGN1c3RvbUZ1bmN0aW9ucywgcGFyc2VPcHRpb25zKSB7XG4gICAgdGhpcy5fc3RyaW5nID0gc3RyaW5nMiwgdGhpcy5tYXJrcyA9IG1hcmtzLCB0aGlzLmN1c3RvbUZ1bmN0aW9ucyA9IGN1c3RvbUZ1bmN0aW9ucywgdGhpcy5pbmRleCA9IDAsIHRoaXMucGFyc2VPcHRpb25zID0gcGFyc2VPcHRpb25zO1xuICB9XG4gIGhhc01hcmsocG9zID0gMCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4ICsgcG9zIDwgdGhpcy5tYXJrcy5sZW5ndGg7XG4gIH1cbiAgZ2V0TWFyayhwb3MgPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMubWFya3NbdGhpcy5pbmRleCArIHBvc107XG4gIH1cbiAgc2hpZnQoKSB7XG4gICAgdGhpcy5pbmRleCArPSAxO1xuICB9XG4gIHByb2Nlc3ModmlzaXRvcikge1xuICAgIGNvbnN0IG1hcmsgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdO1xuICAgIHRoaXMuc2hpZnQoKTtcbiAgICBjb25zdCBmdW5jID0gdmlzaXRvclttYXJrLm5hbWVdO1xuICAgIGlmICghZnVuYylcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBoYW5kbGVyOiAke21hcmsubmFtZX1gKTtcbiAgICByZXR1cm4gZnVuYy5jYWxsKHZpc2l0b3IsIHRoaXMsIG1hcmspO1xuICB9XG4gIHByb2Nlc3NTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hpZnQoKSwgdGhpcy5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gIH1cbiAgcHJvY2Vzc1N0cmluZ0VuZCgpIHtcbiAgICBjb25zdCBwcmV2ID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4IC0gMV0sIGN1cnIgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdO1xuICAgIHJldHVybiB0aGlzLnNoaWZ0KCksIHRoaXMuc3RyaW5nLnNsaWNlKHByZXYucG9zaXRpb24sIGN1cnIucG9zaXRpb24pO1xuICB9XG4gIHNsaWNlKGxlbikge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMubWFya3NbdGhpcy5pbmRleF0ucG9zaXRpb247XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHBvcywgcG9zICsgbGVuKTtcbiAgfVxuICBnZXQgc3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJpbmc7XG4gIH1cbn1cbmNvbnN0IFdTID0gL14oW1xcdFxcblxcdlxcZlxcciBcXHUwMDg1XFx1MDBBMF18KFxcL1xcL1teXFxuXSpcXG4pKSsvLCBOVU0gPSAvXlxcZCsvLCBJREVOVCA9IC9eW2EtekEtWl9dW2EtekEtWl8wLTldKi87XG5mdW5jdGlvbiBwYXJzZSQxKHN0cikge1xuICBsZXQgcG9zID0gMDtcbiAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgbGV0IGN1c3RvbUZ1bmN0aW9ucyA9IHt9O1xuICBmb3IgKDsgcG9zIDwgc3RyLmxlbmd0aCAmJiBzdHIuc3Vic3RyaW5nKHBvcywgcG9zICsgMikgPT09IFwiZm5cIjsgKSB7XG4gICAgbGV0IGZ1bmNSZXN1bHQgPSBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oc3RyLCBwb3MpO1xuICAgIGlmIChmdW5jUmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIGZ1bmNSZXN1bHQ7XG4gICAgY3VzdG9tRnVuY3Rpb25zW2Ake2Z1bmNSZXN1bHQubmFtZXNwYWNlfTo6JHtmdW5jUmVzdWx0Lm5hbWV9YF0gPSBmdW5jUmVzdWx0LCBwb3MgPSBza2lwV1Moc3RyLCBmdW5jUmVzdWx0LnBvc2l0aW9uKTtcbiAgfVxuICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgcmV0dXJuIHJlc3VsdC50eXBlID09PSBcImVycm9yXCIgPyByZXN1bHQgOiAocG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKSwgcG9zICE9PSBzdHIubGVuZ3RoID8gKHJlc3VsdC5mYWlsUG9zaXRpb24gJiYgKHBvcyA9IHJlc3VsdC5mYWlsUG9zaXRpb24gLSAxKSwgeyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6IFwiVW5leHBlY3RlZCBlbmQgb2YgcXVlcnlcIiwgcG9zaXRpb246IHBvcyB9KSA6IChkZWxldGUgcmVzdWx0LnBvc2l0aW9uLCBkZWxldGUgcmVzdWx0LmZhaWxQb3NpdGlvbiwgcmVzdWx0LmN1c3RvbUZ1bmN0aW9ucyA9IGN1c3RvbUZ1bmN0aW9ucywgcmVzdWx0KSk7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHIoc3RyLCBwb3MsIGxldmVsKSB7XG4gIGxldCBzdGFydFBvcyA9IHBvcywgdG9rZW4gPSBzdHJbcG9zXSwgbWFya3M7XG4gIHN3aXRjaCAodG9rZW4pIHtcbiAgICBjYXNlIFwiK1wiOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIDEwKTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcInBvc1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiLVwiOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIDgpO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwibmVnXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKSwgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCIoXCI6IHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZUdyb3VwT3JUdXBsZShzdHIsIHBvcyk7XG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbiwgbWFya3MgPSByZXN1bHQubWFya3M7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIiFcIjoge1xuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCAxMCk7XG4gICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJub3RcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIntcIjoge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgbWFya3MgPSByZXN1bHQubWFya3MsIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiW1wiOlxuICAgICAgaWYgKG1hcmtzID0gW3sgbmFtZTogXCJhcnJheVwiLCBwb3NpdGlvbjogcG9zIH1dLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKSwgc3RyW3Bvc10gIT09IFwiXVwiKVxuICAgICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgICBzdHIuc2xpY2UocG9zLCBwb3MgKyAzKSA9PT0gXCIuLi5cIiAmJiAobWFya3MucHVzaCh7IG5hbWU6IFwiYXJyYXlfc3BsYXRcIiwgcG9zaXRpb246IHBvcyB9KSwgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMykpO1xuICAgICAgICAgIGxldCByZXMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgICAgIGlmIChyZXMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzO1xuICAgICAgICAgIGlmIChtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXMubWFya3MpLCBwb3MgPSByZXMucG9zaXRpb24sIHBvcyA9IHNraXBXUyhzdHIsIHBvcyksIHN0cltwb3NdICE9PSBcIixcIiB8fCAocG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSksIHN0cltwb3NdID09PSBcIl1cIikpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBpZiAoc3RyW3Bvc10gPT09IFwiXVwiKVxuICAgICAgICBwb3MrKywgbWFya3MucHVzaCh7IG5hbWU6IFwiYXJyYXlfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogJ0V4cGVjdGVkIFwiXVwiIGFmdGVyIGFycmF5IGV4cHJlc3Npb24nLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiJ1wiOlxuICAgIGNhc2UgJ1wiJzoge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlU3RyaW5nKHN0ciwgcG9zKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgbWFya3MgPSByZXN1bHQubWFya3MsIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiXlwiOiB7XG4gICAgICBmb3IgKHBvcysrLCBtYXJrcyA9IFtdOyBzdHJbcG9zXSA9PT0gXCIuXCIgJiYgc3RyW3BvcyArIDFdID09PSBcIl5cIjsgKVxuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJkYmxwYXJlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgKz0gMjtcbiAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInBhcmVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIkBcIjpcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJ0aGlzXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XSwgcG9zKys7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiKlwiOlxuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcImV2ZXJ5dGhpbmdcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLCBwb3MrKztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIkXCI6IHtcbiAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MgKyAxLCBJREVOVCk7XG4gICAgICBpZGVudExlbiAmJiAocG9zICs9IDEgKyBpZGVudExlbiwgbWFya3MgPSBbXG4gICAgICAgIHsgbmFtZTogXCJwYXJhbVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyArIDEgfSxcbiAgICAgICAgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cbiAgICAgIF0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGxldCBudW1MZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBOVU0pO1xuICAgICAgaWYgKG51bUxlbikge1xuICAgICAgICBwb3MgKz0gbnVtTGVuO1xuICAgICAgICBsZXQgbmFtZSA9IFwiaW50ZWdlclwiO1xuICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiLlwiKSB7XG4gICAgICAgICAgbGV0IGZyYWNMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zICsgMSwgTlVNKTtcbiAgICAgICAgICBmcmFjTGVuICYmIChuYW1lID0gXCJmbG9hdFwiLCBwb3MgKz0gMSArIGZyYWNMZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCJlXCIgfHwgc3RyW3Bvc10gPT09IFwiRVwiKSB7XG4gICAgICAgICAgbmFtZSA9IFwic2NpXCIsIHBvcysrLCAoc3RyW3Bvc10gPT09IFwiK1wiIHx8IHN0cltwb3NdID09PSBcIi1cIikgJiYgcG9zKys7XG4gICAgICAgICAgbGV0IGV4cExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIE5VTSk7XG4gICAgICAgICAgaWYgKCFleHBMZW4pIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogXCJFeHBvbmVudCBtdXN0IGJlIGEgbnVtYmVyXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgICAgICBwb3MgKz0gZXhwTGVuO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtzID0gW1xuICAgICAgICAgIHsgbmFtZSwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgICAgeyBuYW1lOiBuYW1lICsgXCJfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxuICAgICAgICBdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIElERU5UKTtcbiAgICAgIGlmIChpZGVudExlbikge1xuICAgICAgICBzd2l0Y2ggKHBvcyArPSBpZGVudExlbiwgc3RyW3Bvc10pIHtcbiAgICAgICAgICBjYXNlIFwiOlwiOlxuICAgICAgICAgIGNhc2UgXCIoXCI6IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZ1bmNDYWxsKHN0ciwgc3RhcnRQb3MsIHBvcyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIG1hcmtzID0gcmVzdWx0Lm1hcmtzLCBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG1hcmtzID0gW1xuICAgICAgICAgICAgICB7IG5hbWU6IFwidGhpc19hdHRyXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgICAgICAgIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIW1hcmtzKVxuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogXCJFeHBlY3RlZCBleHByZXNzaW9uXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgbGV0IGxoc0xldmVsID0gMTIsIHRyYXY7XG4gIGxvb3A6IGZvciAoOyA7ICkge1xuICAgIGxldCBpbm5lclBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gICAgaWYgKGlubmVyUG9zID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICBwb3MgPSBpbm5lclBvcztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodHJhdiA9IHBhcnNlVHJhdmVyc2FsKHN0ciwgaW5uZXJQb3MpLCB0cmF2LnR5cGUgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICBmb3IgKG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInRyYXZlcnNlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTsgdHJhdi50eXBlID09PSBcInN1Y2Nlc3NcIjsgKVxuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh0cmF2Lm1hcmtzKSwgcG9zID0gdHJhdi5wb3NpdGlvbiwgdHJhdiA9IHBhcnNlVHJhdmVyc2FsKHN0ciwgc2tpcFdTKHN0ciwgcG9zKSk7XG4gICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJ0cmF2ZXJzYWxfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgc3dpdGNoIChzdHJbaW5uZXJQb3NdKSB7XG4gICAgICBjYXNlIFwiPVwiOiB7XG4gICAgICAgIHN3aXRjaCAoc3RyW2lubmVyUG9zICsgMV0pIHtcbiAgICAgICAgICBjYXNlIFwiPlwiOiB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiAxIHx8IGxoc0xldmVsIDw9IDEpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgMSk7XG4gICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInBhaXJcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiPVwiOiB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiA0IHx8IGxoc0xldmVsIDw9IDQpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgNSk7XG4gICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyAyIH0pLCBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCIrXCI6IHtcbiAgICAgICAgaWYgKGxldmVsID4gNiB8fCBsaHNMZXZlbCA8IDYpIGJyZWFrIGxvb3A7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCA3KTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImFkZFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA2O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCItXCI6IHtcbiAgICAgICAgaWYgKGxldmVsID4gNiB8fCBsaHNMZXZlbCA8IDYpIGJyZWFrIGxvb3A7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCA3KTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInN1YlwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA2O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCIqXCI6IHtcbiAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdID09PSBcIipcIikge1xuICAgICAgICAgIGlmIChsZXZlbCA+IDggfHwgbGhzTGV2ZWwgPD0gOCkgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgcmhzMiA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIDgpO1xuICAgICAgICAgIGlmIChyaHMyLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJoczI7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzMi5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInBvd1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJoczIucG9zaXRpb24sIGxoc0xldmVsID0gODtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGV2ZWwgPiA3IHx8IGxoc0xldmVsIDwgNykgYnJlYWsgbG9vcDtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIDgpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwibXVsXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIi9cIjoge1xuICAgICAgICBpZiAobGV2ZWwgPiA3IHx8IGxoc0xldmVsIDwgNykgYnJlYWsgbG9vcDtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIDgpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiZGl2XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIiVcIjoge1xuICAgICAgICBpZiAobGV2ZWwgPiA3IHx8IGxoc0xldmVsIDwgNykgYnJlYWsgbG9vcDtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIDgpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwibW9kXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIjxcIjpcbiAgICAgIGNhc2UgXCI+XCI6IHtcbiAgICAgICAgaWYgKGxldmVsID4gNCB8fCBsaHNMZXZlbCA8PSA0KSBicmVhayBsb29wO1xuICAgICAgICBsZXQgbmV4dFBvcyA9IGlubmVyUG9zICsgMTtcbiAgICAgICAgc3RyW25leHRQb3NdID09PSBcIj1cIiAmJiBuZXh0UG9zKys7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBuZXh0UG9zKSwgNSk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJjb21wXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IG5leHRQb3MgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ8XCI6IHtcbiAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdID09PSBcInxcIikge1xuICAgICAgICAgIGlmIChsZXZlbCA+IDIgfHwgbGhzTGV2ZWwgPCAyKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCAzKTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJvclwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChsZXZlbCA+IDExIHx8IGxoc0xldmVsIDwgMTEpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IGlkZW50UG9zID0gc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgaWRlbnRQb3MsIElERU5UKTtcbiAgICAgICAgICBpZiAoIWlkZW50TGVuKSByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6IFwiRXhwZWN0ZWQgaWRlbnRpZmllclwiLCBwb3NpdGlvbjogaWRlbnRQb3MgfTtcbiAgICAgICAgICBpZiAocG9zID0gaWRlbnRQb3MgKyBpZGVudExlbiwgc3RyW3Bvc10gPT09IFwiKFwiIHx8IHN0cltwb3NdID09PSBcIjpcIikge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRnVuY0NhbGwoc3RyLCBpZGVudFBvcywgcG9zKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwicGlwZWNhbGxcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByZXN1bHQucG9zaXRpb24sIGxoc0xldmVsID0gMTE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIiZcIjoge1xuICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gIT0gXCImXCIgfHwgbGV2ZWwgPiAzIHx8IGxoc0xldmVsIDwgMykgYnJlYWsgbG9vcDtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIDQpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiYW5kXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIiFcIjoge1xuICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gIT09IFwiPVwiIHx8IGxldmVsID4gNCB8fCBsaHNMZXZlbCA8PSA0KSBicmVhayBsb29wO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgNSk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJjb21wXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IGlubmVyUG9zICsgMiB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRcIjoge1xuICAgICAgICBpZiAoc3RyLnNsaWNlKGlubmVyUG9zLCBpbm5lclBvcyArIDQpICE9PSBcImRlc2NcIiB8fCBsZXZlbCA+IDQgfHwgbGhzTGV2ZWwgPCA0KSBicmVhayBsb29wO1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJkZXNjXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gaW5uZXJQb3MgKyA0LCBsaHNMZXZlbCA9IDQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImFcIjoge1xuICAgICAgICBpZiAoc3RyLnNsaWNlKGlubmVyUG9zLCBpbm5lclBvcyArIDMpICE9PSBcImFzY1wiIHx8IGxldmVsID4gNCB8fCBsaHNMZXZlbCA8IDQpIGJyZWFrIGxvb3A7XG4gICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImFzY1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IGlubmVyUG9zICsgMywgbGhzTGV2ZWwgPSA0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN3aXRjaCAocGFyc2VSZWdleFN0cihzdHIsIGlubmVyUG9zLCBJREVOVCkpIHtcbiAgICAgICAgICBjYXNlIFwiaW5cIjoge1xuICAgICAgICAgICAgaWYgKGxldmVsID4gNCB8fCBsaHNMZXZlbCA8PSA0KSBicmVhayBsb29wO1xuICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKTtcbiAgICAgICAgICAgIGxldCBpc0dyb3VwID0gITE7XG4gICAgICAgICAgICBzdHJbcG9zXSA9PT0gXCIoXCIgJiYgKGlzR3JvdXAgPSAhMCwgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSkpO1xuICAgICAgICAgICAgbGV0IHJhbmdlUG9zID0gcG9zLCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDUpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKSwgc3RyW3Bvc10gPT09IFwiLlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgbGV0IHR5cGUgPSBcImluY19yYW5nZVwiO1xuICAgICAgICAgICAgICBzdHJbcG9zICsgMl0gPT09IFwiLlwiID8gKHR5cGUgPSBcImV4Y19yYW5nZVwiLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKSkgOiBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAyKTtcbiAgICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgNSk7XG4gICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJpbl9yYW5nZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KHsgbmFtZTogdHlwZSwgcG9zaXRpb246IHJhbmdlUG9zIH0sIHJlc3VsdC5tYXJrcywgcmhzLm1hcmtzKSwgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyAyIH0pLCBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpO1xuICAgICAgICAgICAgaWYgKGlzR3JvdXApIHtcbiAgICAgICAgICAgICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyksIHN0cltwb3NdICE9PSBcIilcIilcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6ICdFeHBlY3RlZCBcIilcIiBpbiBncm91cCcsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaHNMZXZlbCA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm1hdGNoXCI6IHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IDQgfHwgbGhzTGV2ZWwgPD0gNCkgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDUpLCA1KTtcbiAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDUgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGxldCBmYWlsUG9zaXRpb24gPSB0cmF2Py50eXBlID09PSBcImVycm9yXCIgJiYgdHJhdi5wb3NpdGlvbjtcbiAgcmV0dXJuIHsgdHlwZTogXCJzdWNjZXNzXCIsIG1hcmtzLCBwb3NpdGlvbjogcG9zLCBmYWlsUG9zaXRpb24gfTtcbn1cbmZ1bmN0aW9uIHBhcnNlR3JvdXBPclR1cGxlKHN0ciwgcG9zKSB7XG4gIGNvbnN0IHN0YXJ0UG9zID0gcG9zO1xuICBsZXQgbWFya3MsIHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCAwKTtcbiAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gIHN3aXRjaCAocG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKSwgc3RyW3Bvc10pIHtcbiAgICBjYXNlIFwiLFwiOiB7XG4gICAgICBmb3IgKG1hcmtzID0gW3sgbmFtZTogXCJ0dXBsZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpOyA7ICkge1xuICAgICAgICBpZiAocmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKSwgcmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgaWYgKG1hcmtzLnB1c2goLi4ucmhzLm1hcmtzKSwgcG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKSwgc3RyW3Bvc10gIT09IFwiLFwiKSBicmVhaztcbiAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6ICdFeHBlY3RlZCBcIilcIiBhZnRlciB0dXBsZSBleHByZXNzaW9uJywgcG9zaXRpb246IHBvcyB9O1xuICAgICAgcG9zKyssIG1hcmtzLnB1c2goeyBuYW1lOiBcInR1cGxlX2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCIpXCI6IHtcbiAgICAgIHBvcysrLCBtYXJrcyA9IFt7IG5hbWU6IFwiZ3JvdXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6IGBVbmV4cGVjdGVkIGNoYXJhY3RlciBcIiR7c3RyW3Bvc119XCJgLCBwb3NpdGlvbjogcG9zIH07XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogXCJzdWNjZXNzXCIsIG1hcmtzLCBwb3NpdGlvbjogcG9zIH07XG59XG5mdW5jdGlvbiBwYXJzZVRyYXZlcnNhbChzdHIsIHBvcykge1xuICBsZXQgc3RhcnRQb3MgPSBwb3M7XG4gIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICBjYXNlIFwiLlwiOiB7XG4gICAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSksIHN0cltwb3NdID09PSBcIihcIilcbiAgICAgICAgcmV0dXJuIHBhcnNlR3JvdXBPclR1cGxlKHN0ciwgcG9zKTtcbiAgICAgIGxldCBpZGVudFN0YXJ0ID0gcG9zLCBpZGVudExlbjIgPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgICByZXR1cm4gaWRlbnRMZW4yID8gKHBvcyArPSBpZGVudExlbjIsIHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIG1hcmtzOiBbXG4gICAgICAgICAgeyBuYW1lOiBcImF0dHJfYWNjZXNzXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogaWRlbnRTdGFydCB9LFxuICAgICAgICAgIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICAgIF0sXG4gICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgIH0pIDogeyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6ICdFeHBlY3RlZCBpZGVudGlmaWVyIGFmdGVyIFwiLlwiJywgcG9zaXRpb246IHBvcyB9O1xuICAgIH1cbiAgICBjYXNlIFwiLVwiOlxuICAgICAgaWYgKHN0cltwb3MgKyAxXSAhPT0gXCI+XCIpXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogJ0V4cGVjdGVkIFwiPlwiIGluIHJlZmVyZW5jZScsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgIGxldCBtYXJrcyA9IFt7IG5hbWU6IFwiZGVyZWZcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dO1xuICAgICAgcG9zICs9IDI7XG4gICAgICBsZXQgaWRlbnRQb3MgPSBza2lwV1Moc3RyLCBwb3MpLCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBpZGVudFBvcywgSURFTlQpO1xuICAgICAgcmV0dXJuIGlkZW50TGVuICYmIChwb3MgPSBpZGVudFBvcyArIGlkZW50TGVuLCBtYXJrcy5wdXNoKFxuICAgICAgICB7IG5hbWU6IFwiZGVyZWZfYXR0clwiLCBwb3NpdGlvbjogaWRlbnRQb3MgfSxcbiAgICAgICAgeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBpZGVudFBvcyB9LFxuICAgICAgICB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxuICAgICAgKSksIHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIG1hcmtzLFxuICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICB9O1xuICAgIGNhc2UgXCJbXCI6IHtcbiAgICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKSwgc3RyW3Bvc10gPT09IFwiXVwiKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgIG1hcmtzOiBbeyBuYW1lOiBcImFycmF5X3Bvc3RmaXhcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gICAgICAgIH07XG4gICAgICBsZXQgcmFuZ2VQb3MgPSBwb3MsIHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pLCBzdHJbcG9zXSA9PT0gXCIuXCIgJiYgc3RyW3BvcyArIDFdID09PSBcIi5cIikge1xuICAgICAgICBsZXQgdHlwZSA9IFwiaW5jX3JhbmdlXCI7XG4gICAgICAgIHN0cltwb3MgKyAyXSA9PT0gXCIuXCIgPyAodHlwZSA9IFwiZXhjX3JhbmdlXCIsIHBvcyArPSAzKSA6IHBvcyArPSAyLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgcmV0dXJuIHJocy50eXBlID09PSBcImVycm9yXCIgPyByaHMgOiAocG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKSwgc3RyW3Bvc10gIT09IFwiXVwiID8geyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6ICdFeHBlY3RlZCBcIl1cIiBhZnRlciBhcnJheSBleHByZXNzaW9uJywgcG9zaXRpb246IHBvcyB9IDoge1xuICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgIG1hcmtzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwic2xpY2VcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgICAgICB7IG5hbWU6IHR5cGUsIHBvc2l0aW9uOiByYW5nZVBvcyB9XG4gICAgICAgICAgXS5jb25jYXQocmVzdWx0Lm1hcmtzLCByaHMubWFya3MpLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cltwb3NdICE9PSBcIl1cIiA/IHsgdHlwZTogXCJlcnJvclwiLCBtZXNzYWdlOiAnRXhwZWN0ZWQgXCJdXCIgYWZ0ZXIgYXJyYXkgZXhwcmVzc2lvbicsIHBvc2l0aW9uOiBwb3MgfSA6IHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIG1hcmtzOiBbeyBuYW1lOiBcInNxdWFyZV9icmFja2V0XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmVzdWx0Lm1hcmtzKSxcbiAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJ8XCI6IHtcbiAgICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKSwgc3RyW3Bvc10gPT09IFwie1wiKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBwYXJzZU9iamVjdChzdHIsIHBvcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiIHx8IHJlc3VsdC5tYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwcm9qZWN0aW9uXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcmVzdWx0O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJ7XCI6IHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZU9iamVjdChzdHIsIHBvcyk7XG4gICAgICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIiB8fCByZXN1bHQubWFya3MudW5zaGlmdCh7IG5hbWU6IFwicHJvamVjdGlvblwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBtZXNzYWdlOiBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyIGluIHRyYXZlcnNhbFwiLCBwb3NpdGlvbjogcG9zIH07XG59XG5mdW5jdGlvbiBwYXJzZUZ1bmNDYWxsKHN0ciwgc3RhcnRQb3MsIHBvcykge1xuICBsZXQgbWFya3MgPSBbXTtcbiAgaWYgKG1hcmtzLnB1c2goeyBuYW1lOiBcImZ1bmNfY2FsbFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHN0cltwb3NdID09PSBcIjpcIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiOlwiKSB7XG4gICAgbWFya3MucHVzaCh7IG5hbWU6IFwibmFtZXNwYWNlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgbWFya3MucHVzaCh7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9KSwgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMik7XG4gICAgbGV0IG5hbWVMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgaWYgKCFuYW1lTGVuKSByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6IFwiRXhwZWN0ZWQgZnVuY3Rpb24gbmFtZVwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgaWYgKG1hcmtzLnB1c2goeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBwb3MgfSwgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zICsgbmFtZUxlbiB9KSwgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgbmFtZUxlbiksIHN0cltwb3NdICE9PSBcIihcIilcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogJ0V4cGVjdGVkIFwiKFwiIGFmdGVyIGZ1bmN0aW9uIG5hbWUnLCBwb3NpdGlvbjogcG9zIH07XG4gICAgcG9zKyssIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gIH0gZWxzZVxuICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LCB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSksIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICBsZXQgbGFzdFBvcyA9IHBvcztcbiAgaWYgKHN0cltwb3NdICE9PSBcIilcIilcbiAgICBmb3IgKDsgOyApIHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAobWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKSwgbGFzdFBvcyA9IHJlc3VsdC5wb3NpdGlvbiwgcG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKSwgc3RyW3Bvc10gIT09IFwiLFwiIHx8IChwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKSwgc3RyW3Bvc10gPT09IFwiKVwiKSkgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gc3RyW3Bvc10gIT09IFwiKVwiID8geyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6ICdFeHBlY3RlZCBcIilcIiBhZnRlciBmdW5jdGlvbiBhcmd1bWVudHMnLCBwb3NpdGlvbjogcG9zIH0gOiAobWFya3MucHVzaCh7IG5hbWU6IFwiZnVuY19hcmdzX2VuZFwiLCBwb3NpdGlvbjogbGFzdFBvcyB9KSwge1xuICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgIG1hcmtzLFxuICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VPYmplY3Qoc3RyLCBwb3MpIHtcbiAgbGV0IG1hcmtzID0gW3sgbmFtZTogXCJvYmplY3RcIiwgcG9zaXRpb246IHBvcyB9XTtcbiAgZm9yIChwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTsgc3RyW3Bvc10gIT09IFwifVwiOyApIHtcbiAgICBsZXQgcGFpclBvcyA9IHBvcztcbiAgICBpZiAoc3RyLnNsaWNlKHBvcywgcG9zICsgMykgPT09IFwiLi4uXCIpXG4gICAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMyksIHN0cltwb3NdICE9PSBcIn1cIiAmJiBzdHJbcG9zXSAhPT0gXCIsXCIpIHtcbiAgICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgICBpZiAoZXhwci50eXBlID09PSBcImVycm9yXCIpIHJldHVybiBleHByO1xuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvYmplY3Rfc3BsYXRcIiwgcG9zaXRpb246IHBhaXJQb3MgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KGV4cHIubWFya3MpLCBwb3MgPSBleHByLnBvc2l0aW9uO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9iamVjdF9zcGxhdF90aGlzXCIsIHBvc2l0aW9uOiBwYWlyUG9zIH0pO1xuICAgIGVsc2Uge1xuICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgaWYgKGV4cHIudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gZXhwcjtcbiAgICAgIGxldCBuZXh0UG9zID0gc2tpcFdTKHN0ciwgZXhwci5wb3NpdGlvbik7XG4gICAgICBpZiAoZXhwci5tYXJrc1swXS5uYW1lID09PSBcInN0clwiICYmIHN0cltuZXh0UG9zXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgbmV4dFBvcyArIDEpLCAwKTtcbiAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHZhbHVlO1xuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvYmplY3RfcGFpclwiLCBwb3NpdGlvbjogcGFpclBvcyB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQoZXhwci5tYXJrcywgdmFsdWUubWFya3MpLCBwb3MgPSB2YWx1ZS5wb3NpdGlvbjtcbiAgICAgIH0gZWxzZVxuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7IG5hbWU6IFwib2JqZWN0X2V4cHJcIiwgcG9zaXRpb246IHBvcyB9LCBleHByLm1hcmtzKSwgcG9zID0gZXhwci5wb3NpdGlvbjtcbiAgICB9XG4gICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyksIHN0cltwb3NdICE9PSBcIixcIikgYnJlYWs7XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gIH1cbiAgcmV0dXJuIHN0cltwb3NdICE9PSBcIn1cIiA/IHsgdHlwZTogXCJlcnJvclwiLCBtZXNzYWdlOiAnRXhwZWN0ZWQgXCJ9XCIgYWZ0ZXIgb2JqZWN0JywgcG9zaXRpb246IHBvcyB9IDogKHBvcysrLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJvYmplY3RfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSksIHsgdHlwZTogXCJzdWNjZXNzXCIsIG1hcmtzLCBwb3NpdGlvbjogcG9zIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyLCBwb3MpIHtcbiAgbGV0IHRva2VuID0gc3RyW3Bvc107XG4gIHBvcyA9IHBvcyArIDE7XG4gIGNvbnN0IG1hcmtzID0gW3sgbmFtZTogXCJzdHJcIiwgcG9zaXRpb246IHBvcyB9XTtcbiAgc3RyOiBmb3IgKDsgOyBwb3MrKykge1xuICAgIGlmIChwb3MgPiBzdHIubGVuZ3RoKSByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6IFwiVW5leHBlY3RlZCBlbmQgb2YgcXVlcnlcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICAgIGNhc2UgdG9rZW46IHtcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwic3RyX2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pLCBwb3MrKztcbiAgICAgICAgYnJlYWsgc3RyO1xuICAgICAgfVxuICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwic3RyX3BhdXNlXCIsIHBvc2l0aW9uOiBwb3MgfSksIHN0cltwb3MgKyAxXSA9PT0gXCJ1XCIgPyBzdHJbcG9zICsgMl0gPT09IFwie1wiID8gKG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4XCIsIHBvc2l0aW9uOiBwb3MgKyAzIH0pLCBwb3MgPSBzdHIuaW5kZXhPZihcIn1cIiwgcG9zICsgMyksIG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pKSA6IChtYXJrcy5wdXNoKHsgbmFtZTogXCJ1bmljb2RlX2hleFwiLCBwb3NpdGlvbjogcG9zICsgMiB9KSwgbWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhfZW5kXCIsIHBvc2l0aW9uOiBwb3MgKyA2IH0pLCBwb3MgKz0gNSkgOiAobWFya3MucHVzaCh7IG5hbWU6IFwic2luZ2xlX2VzY2FwZVwiLCBwb3NpdGlvbjogcG9zICsgMSB9KSwgcG9zICs9IDEpLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJzdHJfc3RhcnRcIiwgcG9zaXRpb246IHBvcyArIDEgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXJrcywgcG9zaXRpb246IHBvcyB9O1xufVxuZnVuY3Rpb24gc2tpcFdTKHN0ciwgcG9zKSB7XG4gIHJldHVybiBwb3MgKyBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBXUyk7XG59XG5mdW5jdGlvbiBwYXJzZVJlZ2V4KHN0ciwgcG9zLCByZSkge1xuICBsZXQgbSA9IHJlLmV4ZWMoc3RyLnNsaWNlKHBvcykpO1xuICByZXR1cm4gbSA/IG1bMF0ubGVuZ3RoIDogMDtcbn1cbmZ1bmN0aW9uIHBhcnNlUmVnZXhTdHIoc3RyLCBwb3MsIHJlKSB7XG4gIGxldCBtID0gcmUuZXhlYyhzdHIuc2xpY2UocG9zKSk7XG4gIHJldHVybiBtID8gbVswXSA6IG51bGw7XG59XG5mdW5jdGlvbiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oc3RyLCBzdGFydFBvcykge1xuICBsZXQgcG9zID0gc3RhcnRQb3MsIG1hcmtzID0gW10sIG5hbWVzcGFjZSA9IFwiXCIsIG5hbWUgPSBcIlwiO1xuICBpZiAoc3RyLnN1YnN0cmluZyhwb3MsIHBvcyArIDIpICE9PSBcImZuXCIpXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgcG9zaXRpb246IHBvcyxcbiAgICAgIG1hcmtzXG4gICAgfTtcbiAgbWFya3MucHVzaCh7IG5hbWU6IFwiZnVuY19kZWNsXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMik7XG4gIGxldCBpZGVudFN0YXJ0ID0gcG9zO1xuICBpZiAobmFtZXNwYWNlID0gcGFyc2VSZWdleFN0cihzdHIsIHBvcywgSURFTlQpLCAhbmFtZXNwYWNlKVxuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogXCJFeHBlY3RlZCBmdW5jdGlvbiBuYW1lXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgaWYgKG1hcmtzLnB1c2goXG4gICAgeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBpZGVudFN0YXJ0IH0sXG4gICAgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zICsgbmFtZXNwYWNlLmxlbmd0aCB9XG4gICksIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIG5hbWVzcGFjZS5sZW5ndGgpLCBzdHIuc3Vic3RyaW5nKHBvcywgcG9zICsgMikgIT09IFwiOjpcIilcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6ICdFeHBlY3RlZCBcIjo6XCIgYWZ0ZXIgbmFtZXNwYWNlJywgcG9zaXRpb246IHBvcyB9O1xuICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMiksIG5hbWUgPSBwYXJzZVJlZ2V4U3RyKHN0ciwgcG9zLCBJREVOVCksICFuYW1lKVxuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogXCJFeHBlY3RlZCBmdW5jdGlvbiBuYW1lXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgaWYgKG1hcmtzLnB1c2goeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBwb3MgfSwgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zICsgbmFtZS5sZW5ndGggfSksIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIG5hbWUubGVuZ3RoKSwgc3RyW3Bvc10gIT09IFwiKFwiKVxuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogJ0V4cGVjdGVkIFwiKFwiJywgcG9zaXRpb246IHBvcyB9O1xuICBmb3IgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpOyBwb3MgPCBzdHIubGVuZ3RoICYmIHN0cltwb3NdICE9PSBcIilcIjsgKSB7XG4gICAgaWYgKHN0cltwb3NdICE9PSBcIiRcIilcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogJ1BhcmFtZXRlciBzaG91bGQgc3RhcnQgd2l0aCBcIiRcIicsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICBjb25zdCBzdGFydFBvczIgPSBwb3M7XG4gICAgcG9zKys7XG4gICAgY29uc3QgcGFyYW1OYW1lID0gcGFyc2VSZWdleFN0cihzdHIsIHBvcywgSURFTlQpO1xuICAgIGlmICghcGFyYW1OYW1lKVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBtZXNzYWdlOiBcIkV4cGVjdGVkIGZ1bmN0aW9uIG5hbWVcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgIGlmIChwb3MgKz0gcGFyYW1OYW1lLmxlbmd0aCwgbWFya3MucHVzaChcbiAgICAgIHsgbmFtZTogXCJwYXJhbVwiLCBwb3NpdGlvbjogc3RhcnRQb3MyIH0sXG4gICAgICB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zMiArIDEgfSxcbiAgICAgIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgKSwgcG9zID0gc2tpcFdTKHN0ciwgcG9zKSwgc3RyW3Bvc10gPT09IFwiLFwiKVxuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgZWxzZSBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBtZXNzYWdlOiAnRXhwZWN0ZWQgXCIsXCIgb3IgXCIpXCInLCBwb3NpdGlvbjogcG9zIH07XG4gIH1cbiAgaWYgKHN0cltwb3NdICE9PSBcIilcIilcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6ICdFeHBlY3RlZCBcIilcIicsIHBvc2l0aW9uOiBwb3MgfTtcbiAgaWYgKG1hcmtzLnB1c2goeyBuYW1lOiBcImZ1bmNfcGFyYW1zX2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKSwgc3RyW3Bvc10gIT09IFwiPVwiKVxuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgbWVzc2FnZTogJ0V4cGVjdGVkIFwiPVwiJywgcG9zaXRpb246IHBvcyB9O1xuICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgbGV0IGJvZHlSZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICByZXR1cm4gYm9keVJlc3VsdC50eXBlID09PSBcImVycm9yXCIgPyBib2R5UmVzdWx0IDogKG1hcmtzID0gbWFya3MuY29uY2F0KGJvZHlSZXN1bHQubWFya3MpLCBwb3MgPSBza2lwV1Moc3RyLCBib2R5UmVzdWx0LnBvc2l0aW9uKSwgc3RyW3Bvc10gIT09IFwiO1wiID8geyB0eXBlOiBcImVycm9yXCIsIG1lc3NhZ2U6ICdFeHBlY3RlZCBcIjtcIiBhZnRlciBmdW5jdGlvbiBkZWNsYXJhdGlvbicsIHBvc2l0aW9uOiBwb3MgfSA6IChwb3MrKywge1xuICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgbWFya3MsXG4gICAgbmFtZXNwYWNlLFxuICAgIG5hbWVcbiAgfSkpO1xufVxuZnVuY3Rpb24gam9pbihhLCBiKSB7XG4gIHJldHVybiAoYmFzZSkgPT4gYihhKGJhc2UpKTtcbn1cbmZ1bmN0aW9uIG1hcChpbm5lcikge1xuICByZXR1cm4gKGJhc2UpID0+ICh7IHR5cGU6IFwiTWFwXCIsIGJhc2UsIGV4cHI6IGlubmVyKHsgdHlwZTogXCJUaGlzXCIgfSkgfSk7XG59XG5mdW5jdGlvbiBmbGF0TWFwKGlubmVyKSB7XG4gIHJldHVybiAoYmFzZSkgPT4gKHsgdHlwZTogXCJGbGF0TWFwXCIsIGJhc2UsIGV4cHI6IGlubmVyKHsgdHlwZTogXCJUaGlzXCIgfSkgfSk7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZUFycmF5KGJ1aWxkLCByaWdodCkge1xuICBpZiAoIXJpZ2h0KVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgYnVpbGRcbiAgICB9O1xuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICBjYXNlIFwiYS1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIG1hcChyaWdodC5idWlsZCkpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCBmbGF0TWFwKHJpZ2h0LmJ1aWxkKSlcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlOiAke3JpZ2h0LnR5cGV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlUGxhaW4obWFwcGVyLCByaWdodCkge1xuICBpZiAoIXJpZ2h0KVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgYnVpbGQ6IG1hcHBlclxuICAgIH07XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlOiAke3JpZ2h0LnR5cGV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlRWxlbWVudChtYXBwZXIsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICBidWlsZDogbWFwcGVyXG4gICAgfTtcbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGU6ICR7cmlnaHQudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VQcm9qZWN0aW9uKG1hcHBlciwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodClcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICB9O1xuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICBjYXNlIFwiYS1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXAobWFwcGVyKSwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcChtYXBwZXIpLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImItYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlOiAke3JpZ2h0LnR5cGV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhbGtWYWxpZGF0ZUN1c3RvbUZ1bmN0aW9uKG5vZGUsIGxldmVsID0gMCkge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJQcm9qZWN0aW9uXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5ub2RlLFxuICAgICAgICBiYXNlOiB3YWxrVmFsaWRhdGVDdXN0b21GdW5jdGlvbihub2RlLmJhc2UsIGxldmVsKSxcbiAgICAgICAgZXhwcjogd2Fsa1ZhbGlkYXRlQ3VzdG9tRnVuY3Rpb24obm9kZS5leHByLCBsZXZlbCArIDEpXG4gICAgICB9O1xuICAgIGNhc2UgXCJGaWx0ZXJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm5vZGUsXG4gICAgICAgIGJhc2U6IHdhbGtWYWxpZGF0ZUN1c3RvbUZ1bmN0aW9uKG5vZGUuYmFzZSwgbGV2ZWwpLFxuICAgICAgICBleHByOiB3YWxrVmFsaWRhdGVDdXN0b21GdW5jdGlvbihub2RlLmV4cHIsIGxldmVsICsgMSlcbiAgICAgIH07XG4gICAgY2FzZSBcIlBhcmVudFwiOiB7XG4gICAgICBpZiAobGV2ZWwgLSBub2RlLm4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgdXNlIG9mIHBhcmVudCBvcGVyYXRvciAoXikuIE5vIHBhcmVudCBuICR7bm9kZS5ufSBhdCBsZXZlbCAke2xldmVsfS5gXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgY2FzZSBcIlBhcmFtZXRlclwiOlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRnVuY3Rpb24gcGFyYW1ldGVycyBhcmUgbm90IGFsbG93ZWQgb3V0c2lkZSBmdW5jdGlvbiBkZWNsYXJhdGlvbnM6ICR7bm9kZS5uYW1lfWBcbiAgICAgICk7XG4gICAgY2FzZSBcIkFycmF5XCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5ub2RlLFxuICAgICAgICBlbGVtZW50czogbm9kZS5lbGVtZW50cy5tYXAoKGVsKSA9PiAoe1xuICAgICAgICAgIC4uLmVsLFxuICAgICAgICAgIHZhbHVlOiB3YWxrVmFsaWRhdGVDdXN0b21GdW5jdGlvbihlbC52YWx1ZSwgbGV2ZWwpXG4gICAgICAgIH0pKVxuICAgICAgfTtcbiAgICBjYXNlIFwiUGlwZUZ1bmNDYWxsXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5ub2RlLFxuICAgICAgICBiYXNlOiB3YWxrVmFsaWRhdGVDdXN0b21GdW5jdGlvbihub2RlLmJhc2UsIGxldmVsKSxcbiAgICAgICAgYXJnczogbm9kZS5hcmdzLm1hcCgoYXJnKSA9PiB3YWxrVmFsaWRhdGVDdXN0b21GdW5jdGlvbihhcmcsIGxldmVsKSlcbiAgICAgIH07XG4gICAgY2FzZSBcIk9iamVjdFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgYXR0cmlidXRlczogbm9kZS5hdHRyaWJ1dGVzLm1hcCgoYXR0cikgPT4ge1xuICAgICAgICAgIHN3aXRjaCAoYXR0ci50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiT2JqZWN0QXR0cmlidXRlVmFsdWVcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5hdHRyLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB3YWxrVmFsaWRhdGVDdXN0b21GdW5jdGlvbihhdHRyLnZhbHVlLCBsZXZlbClcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJPYmplY3RDb25kaXRpb25hbFNwbGF0XCI6XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uYXR0cixcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IHdhbGtWYWxpZGF0ZUN1c3RvbUZ1bmN0aW9uKGF0dHIuY29uZGl0aW9uLCBsZXZlbCksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHdhbGtWYWxpZGF0ZUN1c3RvbUZ1bmN0aW9uKGF0dHIudmFsdWUsIGxldmVsKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcIk9iamVjdFNwbGF0XCI6XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uYXR0cixcbiAgICAgICAgICAgICAgICB2YWx1ZTogd2Fsa1ZhbGlkYXRlQ3VzdG9tRnVuY3Rpb24oYXR0ci52YWx1ZSwgbGV2ZWwpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIGNhc2UgXCJGbGF0TWFwXCI6XG4gICAgY2FzZSBcIk1hcFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgZXhwcjogd2Fsa1ZhbGlkYXRlQ3VzdG9tRnVuY3Rpb24obm9kZS5leHByLCBsZXZlbCksXG4gICAgICAgIGJhc2U6IHdhbGtWYWxpZGF0ZUN1c3RvbUZ1bmN0aW9uKG5vZGUuYmFzZSwgbGV2ZWwpXG4gICAgICB9O1xuICAgIGNhc2UgXCJGdW5jQ2FsbFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgYXJnczogbm9kZS5hcmdzLm1hcCgoYXJnKSA9PiB3YWxrVmFsaWRhdGVDdXN0b21GdW5jdGlvbihhcmcsIGxldmVsKSlcbiAgICAgIH07XG4gICAgY2FzZSBcIlR1cGxlXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5ub2RlLFxuICAgICAgICBtZW1iZXJzOiBub2RlLm1lbWJlcnMubWFwKChtZW1iZXIpID0+IHdhbGtWYWxpZGF0ZUN1c3RvbUZ1bmN0aW9uKG1lbWJlciwgbGV2ZWwpKVxuICAgICAgfTtcbiAgICBjYXNlIFwiU2VsZWN0XCI6IHtcbiAgICAgIGNvbnN0IGFsdGVybmF0aXZlcyA9IG5vZGUuYWx0ZXJuYXRpdmVzLm1hcCgoYWx0KSA9PiAoe1xuICAgICAgICAuLi5hbHQsXG4gICAgICAgIGNvbmRpdGlvbjogd2Fsa1ZhbGlkYXRlQ3VzdG9tRnVuY3Rpb24oYWx0LmNvbmRpdGlvbiwgbGV2ZWwpLFxuICAgICAgICB2YWx1ZTogd2Fsa1ZhbGlkYXRlQ3VzdG9tRnVuY3Rpb24oYWx0LnZhbHVlLCBsZXZlbClcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBub2RlLmZhbGxiYWNrID8ge1xuICAgICAgICAuLi5ub2RlLFxuICAgICAgICBhbHRlcm5hdGl2ZXMsXG4gICAgICAgIGZhbGxiYWNrOiB3YWxrVmFsaWRhdGVDdXN0b21GdW5jdGlvbihub2RlLmZhbGxiYWNrLCBsZXZlbClcbiAgICAgIH0gOiB7XG4gICAgICAgIC4uLm5vZGUsXG4gICAgICAgIGFsdGVybmF0aXZlc1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcIlNlbGVjdG9yTmVzdGVkXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5ub2RlLFxuICAgICAgICBiYXNlOiB3YWxrVmFsaWRhdGVDdXN0b21GdW5jdGlvbihub2RlLmJhc2UsIGxldmVsKSxcbiAgICAgICAgbmVzdGVkOiB3YWxrVmFsaWRhdGVDdXN0b21GdW5jdGlvbihub2RlLm5lc3RlZCwgbGV2ZWwpXG4gICAgICB9O1xuICAgIGNhc2UgXCJTZWxlY3RvckZ1bmNDYWxsXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5ub2RlLFxuICAgICAgICBhcmc6IHdhbGtWYWxpZGF0ZUN1c3RvbUZ1bmN0aW9uKG5vZGUuYXJnLCBsZXZlbClcbiAgICAgIH07XG4gICAgY2FzZSBcIkFjY2Vzc0F0dHJpYnV0ZVwiOlxuICAgIGNhc2UgXCJBY2Nlc3NFbGVtZW50XCI6XG4gICAgY2FzZSBcIkFycmF5Q29lcmNlXCI6XG4gICAgY2FzZSBcIkFzY1wiOlxuICAgIGNhc2UgXCJEZXNjXCI6XG4gICAgY2FzZSBcIkRlcmVmXCI6XG4gICAgY2FzZSBcIkdyb3VwXCI6XG4gICAgY2FzZSBcIk5lZ1wiOlxuICAgIGNhc2UgXCJOb3RcIjpcbiAgICBjYXNlIFwiU2xpY2VcIjpcbiAgICBjYXNlIFwiUG9zXCI6XG4gICAgICByZXR1cm4gbm9kZS5iYXNlID8ge1xuICAgICAgICAuLi5ub2RlLFxuICAgICAgICBiYXNlOiB3YWxrVmFsaWRhdGVDdXN0b21GdW5jdGlvbihub2RlLmJhc2UsIGxldmVsKVxuICAgICAgfSA6IG5vZGU7XG4gICAgY2FzZSBcIkluUmFuZ2VcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm5vZGUsXG4gICAgICAgIGJhc2U6IHdhbGtWYWxpZGF0ZUN1c3RvbUZ1bmN0aW9uKG5vZGUuYmFzZSwgbGV2ZWwpLFxuICAgICAgICBsZWZ0OiB3YWxrVmFsaWRhdGVDdXN0b21GdW5jdGlvbihub2RlLmxlZnQsIGxldmVsKSxcbiAgICAgICAgcmlnaHQ6IHdhbGtWYWxpZGF0ZUN1c3RvbUZ1bmN0aW9uKG5vZGUucmlnaHQsIGxldmVsKVxuICAgICAgfTtcbiAgICBjYXNlIFwiT3BDYWxsXCI6XG4gICAgY2FzZSBcIkFuZFwiOlxuICAgIGNhc2UgXCJPclwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgbGVmdDogd2Fsa1ZhbGlkYXRlQ3VzdG9tRnVuY3Rpb24obm9kZS5sZWZ0LCBsZXZlbCksXG4gICAgICAgIHJpZ2h0OiB3YWxrVmFsaWRhdGVDdXN0b21GdW5jdGlvbihub2RlLnJpZ2h0LCBsZXZlbClcbiAgICAgIH07XG4gICAgY2FzZSBcIkV2ZXJ5dGhpbmdcIjpcbiAgICBjYXNlIFwiVGhpc1wiOlxuICAgIGNhc2UgXCJWYWx1ZVwiOlxuICAgIGNhc2UgXCJDb250ZXh0XCI6XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIYW5kbGUgYWxsIGNhc2VzOiAke25vZGUudHlwZX1gKTtcbiAgfVxufVxuY29uc3QgRVNDQVBFX1NFUVVFTkNFID0ge1xuICBcIidcIjogXCInXCIsXG4gICdcIic6ICdcIicsXG4gIFwiXFxcXFwiOiBcIlxcXFxcIixcbiAgXCIvXCI6IFwiL1wiLFxuICBiOiBcIlxcYlwiLFxuICBmOiBcIlxcZlwiLFxuICBuOiBgXG5gLFxuICByOiBcIlxcclwiLFxuICB0OiBcIlx0XCJcbn07XG5mdW5jdGlvbiBleHBhbmRIZXgoc3RyKSB7XG4gIGNvbnN0IGNoYXJDb2RlID0gcGFyc2VJbnQoc3RyLCAxNik7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbn1cbmNsYXNzIEdyb3FRdWVyeUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBuYW1lID0gXCJHcm9xUXVlcnlFcnJvclwiO1xufVxuZnVuY3Rpb24gY3JlYXRlRXhwcmVzc2lvbkJ1aWxkZXIocmVjdXJzaW9uID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkge1xuICBjb25zdCBleHByQnVpbGRlciA9IHtcbiAgICBncm91cChwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIkdyb3VwXCIsXG4gICAgICAgIGJhc2U6IHAucHJvY2VzcyhleHByQnVpbGRlcilcbiAgICAgIH07XG4gICAgfSxcbiAgICBldmVyeXRoaW5nKCkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJFdmVyeXRoaW5nXCIgfTtcbiAgICB9LFxuICAgIHRoaXMoKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIlRoaXNcIiB9O1xuICAgIH0sXG4gICAgcGFyZW50KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJQYXJlbnRcIixcbiAgICAgICAgbjogMVxuICAgICAgfTtcbiAgICB9LFxuICAgIGRibHBhcmVudChwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIlBhcmVudFwiLFxuICAgICAgICBuOiBwLnByb2Nlc3MoZXhwckJ1aWxkZXIpLm4gKyAxXG4gICAgICB9O1xuICAgIH0sXG4gICAgdHJhdmVyc2UocCkge1xuICAgICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhleHByQnVpbGRlciksIHRyYXZlcnNhbExpc3QgPSBbXTtcbiAgICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcInRyYXZlcnNhbF9lbmRcIjsgKVxuICAgICAgICB0cmF2ZXJzYWxMaXN0LnB1c2gocC5wcm9jZXNzKFRSQVZFUlNFX0JVSUxERVIpKTtcbiAgICAgIHAuc2hpZnQoKTtcbiAgICAgIGxldCB0cmF2ZXJzYWwgPSBudWxsO1xuICAgICAgZm9yIChsZXQgaSA9IHRyYXZlcnNhbExpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHRyYXZlcnNhbCA9IHRyYXZlcnNhbExpc3RbaV0odHJhdmVyc2FsKTtcbiAgICAgIGlmICgoYmFzZS50eXBlID09PSBcIkV2ZXJ5dGhpbmdcIiB8fCBiYXNlLnR5cGUgPT09IFwiQXJyYXlcIiB8fCBiYXNlLnR5cGUgPT09IFwiUGlwZUZ1bmNDYWxsXCIpICYmICh0cmF2ZXJzYWwgPSB0cmF2ZXJzZUFycmF5KCh2YWwpID0+IHZhbCwgdHJhdmVyc2FsKSksIHRyYXZlcnNhbCA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiQlVHOiB1bmV4cGVjdGVkIGVtcHR5IHRyYXZlcnNhbFwiKTtcbiAgICAgIHJldHVybiB0cmF2ZXJzYWwuYnVpbGQoYmFzZSk7XG4gICAgfSxcbiAgICB0aGlzX2F0dHIocCkge1xuICAgICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgICAgcmV0dXJuIG5hbWUgPT09IFwibnVsbFwiID8geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlOiBudWxsIH0gOiBuYW1lID09PSBcInRydWVcIiA/IHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZTogITAgfSA6IG5hbWUgPT09IFwiZmFsc2VcIiA/IHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZTogITEgfSA6IHtcbiAgICAgICAgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIixcbiAgICAgICAgbmFtZVxuICAgICAgfTtcbiAgICB9LFxuICAgIG5lZyhwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIk5lZ1wiLFxuICAgICAgICBiYXNlOiBwLnByb2Nlc3MoZXhwckJ1aWxkZXIpXG4gICAgICB9O1xuICAgIH0sXG4gICAgcG9zKHApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiUG9zXCIsXG4gICAgICAgIGJhc2U6IHAucHJvY2VzcyhleHByQnVpbGRlcilcbiAgICAgIH07XG4gICAgfSxcbiAgICBhZGQocCkge1xuICAgICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhleHByQnVpbGRlciksIHJpZ2h0ID0gcC5wcm9jZXNzKGV4cHJCdWlsZGVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICAgIG9wOiBcIitcIixcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHRcbiAgICAgIH07XG4gICAgfSxcbiAgICBzdWIocCkge1xuICAgICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhleHByQnVpbGRlciksIHJpZ2h0ID0gcC5wcm9jZXNzKGV4cHJCdWlsZGVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICAgIG9wOiBcIi1cIixcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHRcbiAgICAgIH07XG4gICAgfSxcbiAgICBtdWwocCkge1xuICAgICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhleHByQnVpbGRlciksIHJpZ2h0ID0gcC5wcm9jZXNzKGV4cHJCdWlsZGVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICAgIG9wOiBcIipcIixcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHRcbiAgICAgIH07XG4gICAgfSxcbiAgICBkaXYocCkge1xuICAgICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhleHByQnVpbGRlciksIHJpZ2h0ID0gcC5wcm9jZXNzKGV4cHJCdWlsZGVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICAgIG9wOiBcIi9cIixcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHRcbiAgICAgIH07XG4gICAgfSxcbiAgICBtb2QocCkge1xuICAgICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhleHByQnVpbGRlciksIHJpZ2h0ID0gcC5wcm9jZXNzKGV4cHJCdWlsZGVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICAgIG9wOiBcIiVcIixcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHRcbiAgICAgIH07XG4gICAgfSxcbiAgICBwb3cocCkge1xuICAgICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhleHByQnVpbGRlciksIHJpZ2h0ID0gcC5wcm9jZXNzKGV4cHJCdWlsZGVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICAgIG9wOiBcIioqXCIsXG4gICAgICAgIGxlZnQsXG4gICAgICAgIHJpZ2h0XG4gICAgICB9O1xuICAgIH0sXG4gICAgY29tcChwKSB7XG4gICAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKGV4cHJCdWlsZGVyKSwgb3AgPSBwLnByb2Nlc3NTdHJpbmcoKSwgcmlnaHQgPSBwLnByb2Nlc3MoZXhwckJ1aWxkZXIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgICAgb3AsXG4gICAgICAgIGxlZnQsXG4gICAgICAgIHJpZ2h0XG4gICAgICB9O1xuICAgIH0sXG4gICAgaW5fcmFuZ2UocCkge1xuICAgICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhleHByQnVpbGRlciksIGlzSW5jbHVzaXZlID0gcC5nZXRNYXJrKCkubmFtZSA9PT0gXCJpbmNfcmFuZ2VcIjtcbiAgICAgIHAuc2hpZnQoKTtcbiAgICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoZXhwckJ1aWxkZXIpLCByaWdodCA9IHAucHJvY2VzcyhleHByQnVpbGRlcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIkluUmFuZ2VcIixcbiAgICAgICAgYmFzZSxcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHQsXG4gICAgICAgIGlzSW5jbHVzaXZlXG4gICAgICB9O1xuICAgIH0sXG4gICAgc3RyKHApIHtcbiAgICAgIGxldCB2YWx1ZSA9IFwiXCI7XG4gICAgICBsb29wOiBmb3IgKDsgcC5oYXNNYXJrKCk7ICkge1xuICAgICAgICBjb25zdCBtYXJrID0gcC5nZXRNYXJrKCk7XG4gICAgICAgIHN3aXRjaCAobWFyay5uYW1lKSB7XG4gICAgICAgICAgY2FzZSBcInN0cl9lbmRcIjpcbiAgICAgICAgICAgIHZhbHVlICs9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBjYXNlIFwic3RyX3BhdXNlXCI6XG4gICAgICAgICAgICB2YWx1ZSArPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzdHJfc3RhcnRcIjpcbiAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzaW5nbGVfZXNjYXBlXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBwLnNsaWNlKDEpO1xuICAgICAgICAgICAgcC5zaGlmdCgpLCB2YWx1ZSArPSBFU0NBUEVfU0VRVUVOQ0VbY2hhcl07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInVuaWNvZGVfaGV4XCI6XG4gICAgICAgICAgICBwLnNoaWZ0KCksIHZhbHVlICs9IGV4cGFuZEhleChwLnByb2Nlc3NTdHJpbmdFbmQoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIG1hcms6ICR7bWFyay5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlIH07XG4gICAgfSxcbiAgICBpbnRlZ2VyKHApIHtcbiAgICAgIGNvbnN0IHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgICB9O1xuICAgIH0sXG4gICAgZmxvYXQocCkge1xuICAgICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICAgIH07XG4gICAgfSxcbiAgICBzY2kocCkge1xuICAgICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICAgIH07XG4gICAgfSxcbiAgICBvYmplY3QocCkge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IFtdO1xuICAgICAgZm9yICg7IHAuZ2V0TWFyaygpLm5hbWUgIT09IFwib2JqZWN0X2VuZFwiOyApXG4gICAgICAgIGF0dHJpYnV0ZXMucHVzaChwLnByb2Nlc3MoT0JKRUNUX0JVSUxERVIpKTtcbiAgICAgIHJldHVybiBwLnNoaWZ0KCksIHtcbiAgICAgICAgdHlwZTogXCJPYmplY3RcIixcbiAgICAgICAgYXR0cmlidXRlc1xuICAgICAgfTtcbiAgICB9LFxuICAgIGFycmF5KHApIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgICBmb3IgKDsgcC5nZXRNYXJrKCkubmFtZSAhPT0gXCJhcnJheV9lbmRcIjsgKSB7XG4gICAgICAgIGxldCBpc1NwbGF0ID0gITE7XG4gICAgICAgIHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiYXJyYXlfc3BsYXRcIiAmJiAoaXNTcGxhdCA9ICEwLCBwLnNoaWZ0KCkpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhleHByQnVpbGRlcik7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwiQXJyYXlFbGVtZW50XCIsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgaXNTcGxhdFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwLnNoaWZ0KCksIHtcbiAgICAgICAgdHlwZTogXCJBcnJheVwiLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfTtcbiAgICB9LFxuICAgIHR1cGxlKHApIHtcbiAgICAgIGNvbnN0IG1lbWJlcnMgPSBbXTtcbiAgICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcInR1cGxlX2VuZFwiOyApXG4gICAgICAgIG1lbWJlcnMucHVzaChwLnByb2Nlc3MoZXhwckJ1aWxkZXIpKTtcbiAgICAgIHJldHVybiBwLnNoaWZ0KCksIHtcbiAgICAgICAgdHlwZTogXCJUdXBsZVwiLFxuICAgICAgICBtZW1iZXJzXG4gICAgICB9O1xuICAgIH0sXG4gICAgZnVuY19jYWxsKHApIHtcbiAgICAgIGxldCBuYW1lc3BhY2UgPSBcImdsb2JhbFwiO1xuICAgICAgcC5nZXRNYXJrKCkubmFtZSA9PT0gXCJuYW1lc3BhY2VcIiAmJiAocC5zaGlmdCgpLCBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKSk7XG4gICAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIG5hbWUgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgIHR5cGU6IFwiU2VsZWN0XCIsXG4gICAgICAgICAgYWx0ZXJuYXRpdmVzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKDsgcC5nZXRNYXJrKCkubmFtZSAhPT0gXCJmdW5jX2FyZ3NfZW5kXCI7IClcbiAgICAgICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJwYWlyXCIpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZmFsbGJhY2spIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXJndW1lbnQgdG8gc2VsZWN0KClcIik7XG4gICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCBjb25kaXRpb24gPSBwLnByb2Nlc3MoZXhwckJ1aWxkZXIpLCB2YWx1ZSA9IHAucHJvY2VzcyhleHByQnVpbGRlcik7XG4gICAgICAgICAgICByZXN1bHQuYWx0ZXJuYXRpdmVzLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcIlNlbGVjdEFsdGVybmF0aXZlXCIsXG4gICAgICAgICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmZhbGxiYWNrKSB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGFyZ3VtZW50IHRvIHNlbGVjdCgpXCIpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoZXhwckJ1aWxkZXIpO1xuICAgICAgICAgICAgcmVzdWx0LmZhbGxiYWNrID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gcC5zaGlmdCgpLCByZXN1bHQ7XG4gICAgICB9XG4gICAgICBjb25zdCBhcmdzID0gW107XG4gICAgICBmb3IgKDsgcC5nZXRNYXJrKCkubmFtZSAhPT0gXCJmdW5jX2FyZ3NfZW5kXCI7IClcbiAgICAgICAgYXJndW1lbnRTaG91bGRCZVNlbGVjdG9yKG5hbWVzcGFjZSwgbmFtZSwgYXJncy5sZW5ndGgpID8gYXJncy5wdXNoKHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKSkgOiBhcmdzLnB1c2gocC5wcm9jZXNzKGV4cHJCdWlsZGVyKSk7XG4gICAgICBpZiAocC5zaGlmdCgpLCBuYW1lc3BhY2UgPT09IFwiZ2xvYmFsXCIgJiYgKG5hbWUgPT09IFwiYmVmb3JlXCIgfHwgbmFtZSA9PT0gXCJhZnRlclwiKSAmJiBwLnBhcnNlT3B0aW9ucy5tb2RlID09PSBcImRlbHRhXCIpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJDb250ZXh0XCIsXG4gICAgICAgICAga2V5OiBuYW1lXG4gICAgICAgIH07XG4gICAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIG5hbWUgPT09IFwiYm9vc3RcIiAmJiAhcC5hbGxvd0Jvb3N0KVxuICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGJvb3N0XCIpO1xuICAgICAgY29uc3QgY3VzdG9tRnVuY3Rpb24gPSBwLmN1c3RvbUZ1bmN0aW9uc1tgJHtuYW1lc3BhY2V9Ojoke25hbWV9YF07XG4gICAgICBpZiAoY3VzdG9tRnVuY3Rpb24gIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBGVU5DVElPTl9ERUNMX0JVSUxERVIgPSBjcmVhdGVGdW5jdGlvbkRlY2xhcmF0aW9uQnVpbGRlcihyZWN1cnNpb24pLCBmdW5jRGVjbCA9IG5ldyBNYXJrUHJvY2Vzc29yKHAuc3RyaW5nLCBjdXN0b21GdW5jdGlvbi5tYXJrcywgcC5jdXN0b21GdW5jdGlvbnMsIHt9KS5wcm9jZXNzKEZVTkNUSU9OX0RFQ0xfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUFyaXR5KG5hbWUsIGZ1bmNEZWNsLnBhcmFtcy5sZW5ndGgsIGFyZ3MubGVuZ3RoKSwgbWFwQ3VzdG9tRnVuY3Rpb24oXG4gICAgICAgICAgZnVuY0RlY2wuYm9keSxcbiAgICAgICAgICAoYm9keSkgPT4gd2Fsa1ZhbGlkYXRlQ3VzdG9tRnVuY3Rpb24oYm9keSksXG4gICAgICAgICAgKHBhcmFtZXRlck5vZGUpID0+IHJlc29sdmVGdW5jdGlvblBhcmFtZXRlcihwYXJhbWV0ZXJOb2RlLCBmdW5jRGVjbC5wYXJhbXMsIGFyZ3MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBmdW5jcyA9IG5hbWVzcGFjZXNbbmFtZXNwYWNlXTtcbiAgICAgIGlmICghZnVuY3MpXG4gICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIG5hbWVzcGFjZTogJHtuYW1lc3BhY2V9YCk7XG4gICAgICBjb25zdCBmdW5jID0gZnVuY3NbbmFtZV07XG4gICAgICBpZiAoIWZ1bmMpXG4gICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIGZ1bmN0aW9uOiAke25hbWV9YCk7XG4gICAgICBpZiAoZnVuYy5hcml0eSAhPT0gdm9pZCAwICYmIHZhbGlkYXRlQXJpdHkobmFtZSwgZnVuYy5hcml0eSwgYXJncy5sZW5ndGgpLCBmdW5jLm1vZGUgIT09IHZvaWQgMCAmJiBmdW5jLm1vZGUgIT09IHAucGFyc2VPcHRpb25zLm1vZGUpXG4gICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIGZ1bmN0aW9uOiAke25hbWV9YCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIkZ1bmNDYWxsXCIsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgYXJncyxcbiAgICAgICAgZnVuY1xuICAgICAgfTtcbiAgICB9LFxuICAgIHBpcGVjYWxsKHApIHtcbiAgICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoZXhwckJ1aWxkZXIpO1xuICAgICAgcC5zaGlmdCgpO1xuICAgICAgbGV0IG5hbWVzcGFjZSA9IFwiZ2xvYmFsXCI7XG4gICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJuYW1lc3BhY2VcIiAmJiAocC5zaGlmdCgpLCBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKSksIG5hbWVzcGFjZSAhPT0gXCJnbG9iYWxcIilcbiAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgbmFtZXNwYWNlOiAke25hbWVzcGFjZX1gKTtcbiAgICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKSwgYXJncyA9IFtdLCBvbGRBbGxvd0Jvb3N0ID0gcC5hbGxvd0Jvb3N0O1xuICAgICAgZm9yIChuYW1lID09PSBcInNjb3JlXCIgJiYgKHAuYWxsb3dCb29zdCA9ICEwKTsgOyApIHtcbiAgICAgICAgY29uc3QgbWFya05hbWUgPSBwLmdldE1hcmsoKS5uYW1lO1xuICAgICAgICBpZiAobWFya05hbWUgPT09IFwiZnVuY19hcmdzX2VuZFwiKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobmFtZSA9PT0gXCJvcmRlclwiKSB7XG4gICAgICAgICAgaWYgKG1hcmtOYW1lID09PSBcImFzY1wiKSB7XG4gICAgICAgICAgICBwLnNoaWZ0KCksIGFyZ3MucHVzaCh7IHR5cGU6IFwiQXNjXCIsIGJhc2U6IHAucHJvY2VzcyhleHByQnVpbGRlcikgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1hcmtOYW1lID09PSBcImRlc2NcIikge1xuICAgICAgICAgICAgcC5zaGlmdCgpLCBhcmdzLnB1c2goeyB0eXBlOiBcIkRlc2NcIiwgYmFzZTogcC5wcm9jZXNzKGV4cHJCdWlsZGVyKSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhcmdzLnB1c2gocC5wcm9jZXNzKGV4cHJCdWlsZGVyKSk7XG4gICAgICB9XG4gICAgICBwLnNoaWZ0KCksIHAuYWxsb3dCb29zdCA9IG9sZEFsbG93Qm9vc3Q7XG4gICAgICBjb25zdCBmdW5jID0gcGlwZUZ1bmN0aW9uc1tuYW1lXTtcbiAgICAgIGlmICghZnVuYylcbiAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgcGlwZSBmdW5jdGlvbjogJHtuYW1lfWApO1xuICAgICAgcmV0dXJuIGZ1bmMuYXJpdHkgJiYgdmFsaWRhdGVBcml0eShuYW1lLCBmdW5jLmFyaXR5LCBhcmdzLmxlbmd0aCksIHtcbiAgICAgICAgdHlwZTogXCJQaXBlRnVuY0NhbGxcIixcbiAgICAgICAgZnVuYyxcbiAgICAgICAgYmFzZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgYXJnc1xuICAgICAgfTtcbiAgICB9LFxuICAgIHBhaXIoKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkID0+XCIpO1xuICAgIH0sXG4gICAgYW5kKHApIHtcbiAgICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoZXhwckJ1aWxkZXIpLCByaWdodCA9IHAucHJvY2VzcyhleHByQnVpbGRlcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIkFuZFwiLFxuICAgICAgICBsZWZ0LFxuICAgICAgICByaWdodFxuICAgICAgfTtcbiAgICB9LFxuICAgIG9yKHApIHtcbiAgICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoZXhwckJ1aWxkZXIpLCByaWdodCA9IHAucHJvY2VzcyhleHByQnVpbGRlcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIk9yXCIsXG4gICAgICAgIGxlZnQsXG4gICAgICAgIHJpZ2h0XG4gICAgICB9O1xuICAgIH0sXG4gICAgbm90KHApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiTm90XCIsXG4gICAgICAgIGJhc2U6IHAucHJvY2VzcyhleHByQnVpbGRlcilcbiAgICAgIH07XG4gICAgfSxcbiAgICBhc2MoKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGFzY1wiKTtcbiAgICB9LFxuICAgIGRlc2MoKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGRlc2NcIik7XG4gICAgfSxcbiAgICBwYXJhbShwKSB7XG4gICAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgICByZXR1cm4gcC5wYXJzZU9wdGlvbnMucGFyYW1zICYmIHAucGFyc2VPcHRpb25zLnBhcmFtcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHtcbiAgICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgICB2YWx1ZTogcC5wYXJzZU9wdGlvbnMucGFyYW1zW25hbWVdXG4gICAgICB9IDoge1xuICAgICAgICB0eXBlOiBcIlBhcmFtZXRlclwiLFxuICAgICAgICBuYW1lXG4gICAgICB9O1xuICAgIH1cbiAgfSwgT0JKRUNUX0JVSUxERVIgPSB7XG4gICAgb2JqZWN0X2V4cHIocCkge1xuICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwicGFpclwiKSB7XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgY29uc3QgY29uZGl0aW9uID0gcC5wcm9jZXNzKGV4cHJCdWlsZGVyKSwgdmFsdWUyID0gcC5wcm9jZXNzKGV4cHJCdWlsZGVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcIk9iamVjdENvbmRpdGlvbmFsU3BsYXRcIixcbiAgICAgICAgICBjb25kaXRpb24sXG4gICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoZXhwckJ1aWxkZXIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiLFxuICAgICAgICBuYW1lOiBleHRyYWN0UHJvcGVydHlLZXkodmFsdWUpLFxuICAgICAgICB2YWx1ZVxuICAgICAgfTtcbiAgICB9LFxuICAgIG9iamVjdF9wYWlyKHApIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3MoZXhwckJ1aWxkZXIpO1xuICAgICAgaWYgKG5hbWUudHlwZSAhPT0gXCJWYWx1ZVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJuYW1lIG11c3QgYmUgc3RyaW5nXCIpO1xuICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoZXhwckJ1aWxkZXIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiLFxuICAgICAgICBuYW1lOiBuYW1lLnZhbHVlLFxuICAgICAgICB2YWx1ZVxuICAgICAgfTtcbiAgICB9LFxuICAgIG9iamVjdF9zcGxhdChwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIk9iamVjdFNwbGF0XCIsXG4gICAgICAgIHZhbHVlOiBwLnByb2Nlc3MoZXhwckJ1aWxkZXIpXG4gICAgICB9O1xuICAgIH0sXG4gICAgb2JqZWN0X3NwbGF0X3RoaXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIk9iamVjdFNwbGF0XCIsXG4gICAgICAgIHZhbHVlOiB7IHR5cGU6IFwiVGhpc1wiIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCBUUkFWRVJTRV9CVUlMREVSID0ge1xuICAgIHNxdWFyZV9icmFja2V0KHApIHtcbiAgICAgIGNvbnN0IGV4cHIgPSBwLnByb2Nlc3MoZXhwckJ1aWxkZXIpLCB2YWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUoZXhwcik7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gXCJudW1iZXJcIiA/IChyaWdodCkgPT4gdHJhdmVyc2VFbGVtZW50KChiYXNlKSA9PiAoeyB0eXBlOiBcIkFjY2Vzc0VsZW1lbnRcIiwgYmFzZSwgaW5kZXg6IHZhbHVlLmRhdGEgfSksIHJpZ2h0KSA6IHZhbHVlICYmIHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIgPyAocmlnaHQpID0+IHRyYXZlcnNlUGxhaW4oKGJhc2UpID0+ICh7IHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsIGJhc2UsIG5hbWU6IHZhbHVlLmRhdGEgfSksIHJpZ2h0KSA6IChyaWdodCkgPT4gdHJhdmVyc2VBcnJheShcbiAgICAgICAgKGJhc2UpID0+ICh7XG4gICAgICAgICAgdHlwZTogXCJGaWx0ZXJcIixcbiAgICAgICAgICBiYXNlLFxuICAgICAgICAgIGV4cHJcbiAgICAgICAgfSksXG4gICAgICAgIHJpZ2h0XG4gICAgICApO1xuICAgIH0sXG4gICAgc2xpY2UocCkge1xuICAgICAgY29uc3QgaXNJbmNsdXNpdmUgPSBwLmdldE1hcmsoKS5uYW1lID09PSBcImluY19yYW5nZVwiO1xuICAgICAgcC5zaGlmdCgpO1xuICAgICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhleHByQnVpbGRlciksIHJpZ2h0ID0gcC5wcm9jZXNzKGV4cHJCdWlsZGVyKSwgbGVmdFZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShsZWZ0KSwgcmlnaHRWYWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUocmlnaHQpO1xuICAgICAgaWYgKCFsZWZ0VmFsdWUgfHwgIXJpZ2h0VmFsdWUgfHwgbGVmdFZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIgfHwgcmlnaHRWYWx1ZS50eXBlICE9PSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJzbGljaW5nIG11c3QgdXNlIGNvbnN0YW50IG51bWJlcnNcIik7XG4gICAgICByZXR1cm4gKHJocykgPT4gdHJhdmVyc2VBcnJheShcbiAgICAgICAgKGJhc2UpID0+ICh7XG4gICAgICAgICAgdHlwZTogXCJTbGljZVwiLFxuICAgICAgICAgIGJhc2UsXG4gICAgICAgICAgbGVmdDogbGVmdFZhbHVlLmRhdGEsXG4gICAgICAgICAgcmlnaHQ6IHJpZ2h0VmFsdWUuZGF0YSxcbiAgICAgICAgICBpc0luY2x1c2l2ZVxuICAgICAgICB9KSxcbiAgICAgICAgcmhzXG4gICAgICApO1xuICAgIH0sXG4gICAgcHJvamVjdGlvbihwKSB7XG4gICAgICBjb25zdCBvYmogPSBwLnByb2Nlc3MoZXhwckJ1aWxkZXIpO1xuICAgICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VQcm9qZWN0aW9uKChiYXNlKSA9PiAoeyB0eXBlOiBcIlByb2plY3Rpb25cIiwgYmFzZSwgZXhwcjogb2JqIH0pLCByaWdodCk7XG4gICAgfSxcbiAgICBhdHRyX2FjY2VzcyhwKSB7XG4gICAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZVBsYWluKChiYXNlKSA9PiAoeyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBiYXNlLCBuYW1lIH0pLCByaWdodCk7XG4gICAgfSxcbiAgICBkZXJlZihwKSB7XG4gICAgICBsZXQgYXR0ciA9IG51bGw7XG4gICAgICBwLmdldE1hcmsoKS5uYW1lID09PSBcImRlcmVmX2F0dHJcIiAmJiAocC5zaGlmdCgpLCBhdHRyID0gcC5wcm9jZXNzU3RyaW5nKCkpO1xuICAgICAgY29uc3Qgd3JhcCA9IChiYXNlKSA9PiBhdHRyID8geyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBiYXNlLCBuYW1lOiBhdHRyIH0gOiBiYXNlO1xuICAgICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VQbGFpbihcbiAgICAgICAgKGJhc2UpID0+IHdyYXAoe1xuICAgICAgICAgIHR5cGU6IFwiRGVyZWZcIixcbiAgICAgICAgICBiYXNlXG4gICAgICAgIH0pLFxuICAgICAgICByaWdodFxuICAgICAgKTtcbiAgICB9LFxuICAgIGFycmF5X3Bvc3RmaXgoKSB7XG4gICAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZUFycmF5KChiYXNlKSA9PiAoeyB0eXBlOiBcIkFycmF5Q29lcmNlXCIsIGJhc2UgfSksIHJpZ2h0KTtcbiAgICB9XG4gIH0sIFNFTEVDVE9SX0JVSUxERVIgPSB7XG4gICAgZ3JvdXAocCkge1xuICAgICAgcmV0dXJuIHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKTtcbiAgICB9LFxuICAgIGV2ZXJ5dGhpbmcoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgICB9LFxuICAgIHRoaXMoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgICB9LFxuICAgIHBhcmVudCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICAgIH0sXG4gICAgZGJscGFyZW50KCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gICAgfSxcbiAgICB0cmF2ZXJzZShwKSB7XG4gICAgICBsZXQgbm9kZSA9IHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKTtcbiAgICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcInRyYXZlcnNhbF9lbmRcIjsgKVxuICAgICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJhcnJheV9wb3N0Zml4XCIpXG4gICAgICAgICAgcC5zaGlmdCgpLCBub2RlID0geyB0eXBlOiBcIkFycmF5Q29lcmNlXCIsIGJhc2U6IG5vZGUgfTtcbiAgICAgICAgZWxzZSBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJzcXVhcmVfYnJhY2tldFwiKSB7XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIGNvbnN0IGV4cHIgPSBwLnByb2Nlc3MoZXhwckJ1aWxkZXIpLCB2YWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUoZXhwcik7XG4gICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFycmF5IGFjY2VzcyBleHByZXNzaW9uXCIpO1xuICAgICAgICAgIHZhbHVlICYmIHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIgPyBub2RlID0geyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBiYXNlOiBub2RlLCBuYW1lOiB2YWx1ZS5kYXRhIH0gOiBub2RlID0geyB0eXBlOiBcIkZpbHRlclwiLCBiYXNlOiBub2RlLCBleHByIH07XG4gICAgICAgIH0gZWxzZSBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJhdHRyX2FjY2Vzc1wiKSB7XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICAgICAgICBub2RlID0geyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBiYXNlOiBub2RlLCBuYW1lIH07XG4gICAgICAgIH0gZWxzZSBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJ0dXBsZVwiIHx8IHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gcC5wcm9jZXNzKFNFTEVDVE9SX0JVSUxERVIpO1xuICAgICAgICAgIGlmICghaXNTZWxlY3Rvck5lc3RlZChzZWxlY3RvcikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgcmVzdWx0IHBhcnNpbmcgbmVzdGVkIHNlbGVjdG9yOiAke3NlbGVjdG9yLnR5cGV9YCk7XG4gICAgICAgICAgbm9kZSA9IHsgdHlwZTogXCJTZWxlY3Rvck5lc3RlZFwiLCBiYXNlOiBub2RlLCBuZXN0ZWQ6IHNlbGVjdG9yIH07XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICAgICAgcmV0dXJuIHAuc2hpZnQoKSwgbm9kZTtcbiAgICB9LFxuICAgIHRoaXNfYXR0cihwKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBuYW1lOiBwLnByb2Nlc3NTdHJpbmcoKSB9O1xuICAgIH0sXG4gICAgYXR0cl9hY2Nlc3MoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgICB9LFxuICAgIG5lZygpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICAgIH0sXG4gICAgcG9zKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gICAgfSxcbiAgICBhZGQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgICB9LFxuICAgIHN1YigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICAgIH0sXG4gICAgbXVsKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gICAgfSxcbiAgICBkaXYoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgICB9LFxuICAgIG1vZCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICAgIH0sXG4gICAgcG93KCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gICAgfSxcbiAgICBjb21wKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gICAgfSxcbiAgICBpbl9yYW5nZSgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICAgIH0sXG4gICAgc3RyKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gICAgfSxcbiAgICBpbnRlZ2VyKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gICAgfSxcbiAgICBmbG9hdCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICAgIH0sXG4gICAgc2NpKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gICAgfSxcbiAgICBvYmplY3QoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgICB9LFxuICAgIGFycmF5KCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gICAgfSxcbiAgICB0dXBsZShwKSB7XG4gICAgICBjb25zdCBzZWxlY3RvcnMgPSBbXTtcbiAgICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcInR1cGxlX2VuZFwiOyApXG4gICAgICAgIHNlbGVjdG9ycy5wdXNoKHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKSk7XG4gICAgICByZXR1cm4gcC5zaGlmdCgpLCB7IHR5cGU6IFwiVHVwbGVcIiwgbWVtYmVyczogc2VsZWN0b3JzIH07XG4gICAgfSxcbiAgICBmdW5jX2NhbGwocCwgbWFyaykge1xuICAgICAgY29uc3QgZnVuYyA9IGV4cHJCdWlsZGVyLmZ1bmNfY2FsbChwLCBtYXJrKTtcbiAgICAgIGlmIChmdW5jLm5hbWUgPT09IFwiYW55d2hlcmVcIiAmJiBmdW5jLmFyZ3MubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiU2VsZWN0b3JGdW5jQ2FsbFwiLFxuICAgICAgICAgIG5hbWU6IFwiYW55d2hlcmVcIixcbiAgICAgICAgICBhcmc6IGZ1bmMuYXJnc1swXVxuICAgICAgICB9O1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gICAgfSxcbiAgICBwaXBlY2FsbCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICAgIH0sXG4gICAgcGFpcigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICAgIH0sXG4gICAgYW5kKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gICAgfSxcbiAgICBvcigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICAgIH0sXG4gICAgbm90KCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gICAgfSxcbiAgICBhc2MoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgICB9LFxuICAgIGRlc2MoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgICB9LFxuICAgIHBhcmFtKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZXhwckJ1aWxkZXI7XG59XG5mdW5jdGlvbiBleHRyYWN0UHJvcGVydHlLZXkobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSBcIkFjY2Vzc0F0dHJpYnV0ZVwiICYmICFub2RlLmJhc2UpXG4gICAgcmV0dXJuIG5vZGUubmFtZTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJQaXBlRnVuY0NhbGxcIiB8fCBub2RlLnR5cGUgPT09IFwiRGVyZWZcIiB8fCBub2RlLnR5cGUgPT09IFwiTWFwXCIgfHwgbm9kZS50eXBlID09PSBcIlByb2plY3Rpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiU2xpY2VcIiB8fCBub2RlLnR5cGUgPT09IFwiRmlsdGVyXCIgfHwgbm9kZS50eXBlID09PSBcIkFjY2Vzc0VsZW1lbnRcIiB8fCBub2RlLnR5cGUgPT09IFwiQXJyYXlDb2VyY2VcIiB8fCBub2RlLnR5cGUgPT09IFwiR3JvdXBcIilcbiAgICByZXR1cm4gZXh0cmFjdFByb3BlcnR5S2V5KG5vZGUuYmFzZSk7XG4gIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgQ2Fubm90IGRldGVybWluZSBwcm9wZXJ0eSBrZXkgZm9yIHR5cGU6ICR7bm9kZS50eXBlfWApO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBcml0eShuYW1lLCBhcml0eSwgY291bnQpIHtcbiAgaWYgKHR5cGVvZiBhcml0eSA9PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKGNvdW50ICE9PSBhcml0eSlcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcbiAgICAgICAgYEluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uICR7bmFtZX0oKS4gRXhwZWN0ZWQgJHthcml0eX0sIGdvdCAke2NvdW50fS5gXG4gICAgICApO1xuICB9IGVsc2UgaWYgKGFyaXR5ICYmICFhcml0eShjb3VudCkpXG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBJbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiAke25hbWV9KCkuYCk7XG59XG5mdW5jdGlvbiByZXNvbHZlRnVuY3Rpb25QYXJhbWV0ZXIocGFyYW1ldGVyLCBwYXJhbXMsIGFyZ3MpIHtcbiAgaWYgKHBhcmFtZXRlci50eXBlICE9PSBcIlBhcmFtZXRlclwiKVxuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgRXhwZWN0ZWQgcGFyYW1ldGVyIG5vZGUsIGdvdCAke3BhcmFtZXRlci50eXBlfWApO1xuICBjb25zdCBpbmRleCA9IHBhcmFtcy5maW5kSW5kZXgoKHApID0+IHAubmFtZSA9PT0gcGFyYW1ldGVyLm5hbWUpO1xuICBpZiAoaW5kZXggPT09IC0xKVxuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgTWlzc2luZyBhcmd1bWVudCBmb3IgcGFyYW1ldGVyICR7cGFyYW1ldGVyLm5hbWV9IGluIGZ1bmN0aW9uIGNhbGxgKTtcbiAgcmV0dXJuIGFyZ3NbaW5kZXhdO1xufVxuZnVuY3Rpb24gbWFwQ3VzdG9tRnVuY3Rpb24oYm9keSwgYm9keU1hcHBlciwgcGFyYW1ldGVyTWFwcGVyID0gKG4pID0+IG4pIHtcbiAgaWYgKGJvZHkudHlwZSA9PT0gXCJQcm9qZWN0aW9uXCIpIHtcbiAgICBpZiAoYm9keS5iYXNlLnR5cGUgPT09IFwiUGFyYW1ldGVyXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIlByb2plY3Rpb25cIixcbiAgICAgICAgYmFzZTogcGFyYW1ldGVyTWFwcGVyKGJvZHkuYmFzZSksXG4gICAgICAgIGV4cHI6IGJvZHlNYXBwZXIoYm9keS5leHByKVxuICAgICAgfTtcbiAgICBpZiAoYm9keS5iYXNlLnR5cGUgPT09IFwiRGVyZWZcIiAmJiBib2R5LmJhc2UuYmFzZS50eXBlID09PSBcIlBhcmFtZXRlclwiKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJQcm9qZWN0aW9uXCIsXG4gICAgICAgIGJhc2U6IHtcbiAgICAgICAgICB0eXBlOiBcIkRlcmVmXCIsXG4gICAgICAgICAgYmFzZTogcGFyYW1ldGVyTWFwcGVyKGJvZHkuYmFzZS5iYXNlKVxuICAgICAgICB9LFxuICAgICAgICBleHByOiBib2R5TWFwcGVyKGJvZHkuZXhwcilcbiAgICAgIH07XG4gIH1cbiAgaWYgKGJvZHkudHlwZSA9PT0gXCJNYXBcIiAmJiBib2R5LmJhc2UudHlwZSA9PT0gXCJBcnJheUNvZXJjZVwiICYmIGJvZHkuYmFzZS5iYXNlLnR5cGUgPT09IFwiUGFyYW1ldGVyXCIpXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTWFwXCIsXG4gICAgICBiYXNlOiB7XG4gICAgICAgIHR5cGU6IFwiQXJyYXlDb2VyY2VcIixcbiAgICAgICAgYmFzZTogcGFyYW1ldGVyTWFwcGVyKGJvZHkuYmFzZS5iYXNlKVxuICAgICAgfSxcbiAgICAgIGV4cHI6IGJvZHlNYXBwZXIoYm9keS5leHByKVxuICAgIH07XG4gIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5leHBlY3RlZCBmdW5jdGlvbiBib2R5LCBtdXN0IGJlIGEgcHJvamVjdGlvbi4gR290IFwiJHtib2R5LnR5cGV9XCJgKTtcbn1cbmZ1bmN0aW9uIGFyZ3VtZW50U2hvdWxkQmVTZWxlY3RvcihuYW1lc3BhY2UsIGZ1bmN0aW9uTmFtZSwgYXJnQ291bnQpIHtcbiAgY29uc3QgZnVuY3Rpb25zUmVxdWlyaW5nU2VsZWN0b3JzID0gW1wiY2hhbmdlZEFueVwiLCBcImNoYW5nZWRPbmx5XCJdO1xuICByZXR1cm4gbmFtZXNwYWNlID09IFwiZGlmZlwiICYmIGFyZ0NvdW50ID09IDIgJiYgZnVuY3Rpb25zUmVxdWlyaW5nU2VsZWN0b3JzLmluY2x1ZGVzKGZ1bmN0aW9uTmFtZSk7XG59XG5jbGFzcyBHcm9xU3ludGF4RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHBvc2l0aW9uO1xuICBuYW1lID0gXCJHcm9xU3ludGF4RXJyb3JcIjtcbiAgY29uc3RydWN0b3IocG9zaXRpb24sIGRldGFpbCkge1xuICAgIHN1cGVyKGBTeW50YXggZXJyb3IgaW4gR1JPUSBxdWVyeSBhdCBwb3NpdGlvbiAke3Bvc2l0aW9ufSR7ZGV0YWlsID8gYDogJHtkZXRhaWx9YCA6IFwiXCJ9YCksIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCByZXN1bHQgPSBwYXJzZSQxKGlucHV0KTtcbiAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgdGhyb3cgbmV3IEdyb3FTeW50YXhFcnJvcihyZXN1bHQucG9zaXRpb24sIHJlc3VsdC5tZXNzYWdlKTtcbiAgdmFsaWRhdGVDdXN0b21GdW5jdGlvbnMoaW5wdXQsIHJlc3VsdC5jdXN0b21GdW5jdGlvbnMpO1xuICBjb25zdCBwcm9jZXNzb3IgPSBuZXcgTWFya1Byb2Nlc3NvcihpbnB1dCwgcmVzdWx0Lm1hcmtzLCByZXN1bHQuY3VzdG9tRnVuY3Rpb25zLCBvcHRpb25zKSwgZXhwckJ1aWxkZXIgPSBjcmVhdGVFeHByZXNzaW9uQnVpbGRlcigpO1xuICByZXR1cm4gcHJvY2Vzc29yLnByb2Nlc3MoZXhwckJ1aWxkZXIpO1xufVxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25EZWNsYXJhdGlvbkJ1aWxkZXIocmVjdXJzaW9uID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkge1xuICByZXR1cm4ge1xuICAgIGZ1bmNfZGVjbChwKSB7XG4gICAgICBjb25zdCBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKSwgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpLCBmdW5jdGlvbklkID0gYCR7bmFtZXNwYWNlfTo6JHtuYW1lfWA7XG4gICAgICBpZiAocmVjdXJzaW9uLmhhcyhmdW5jdGlvbklkKSlcbiAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBSZWN1cnNpdmUgZnVuY3Rpb24gZGVmaW5pdGlvbiBkZXRlY3RlZCBmb3IgJHtmdW5jdGlvbklkfWApO1xuICAgICAgY29uc3QgZXhwckJ1aWxkZXIgPSBjcmVhdGVFeHByZXNzaW9uQnVpbGRlcigvKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4ucmVjdXJzaW9uLCBmdW5jdGlvbklkXSkpLCBwYXJhbXMgPSBbXTtcbiAgICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcImZ1bmNfcGFyYW1zX2VuZFwiOyApIHtcbiAgICAgICAgY29uc3QgcGFyYW0gPSBwLnByb2Nlc3MoZXhwckJ1aWxkZXIpO1xuICAgICAgICBpZiAocGFyYW0udHlwZSAhPT0gXCJQYXJhbWV0ZXJcIikgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgcGFyYW1ldGVyXCIpO1xuICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiQ3VzdG9tIGZ1bmN0aW9ucyBjYW4gb25seSBoYXZlIG9uZSBwYXJhbWV0ZXJcIik7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBjb25zdCBib2R5ID0gcC5wcm9jZXNzKGV4cHJCdWlsZGVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiRnVuY0RlY2xhcmF0aW9uXCIsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBib2R5XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQ3VzdG9tRnVuY3Rpb25zKHF1ZXJ5LCBjdXN0b21GdW5jdGlvbnMpIHtcbiAgZm9yIChjb25zdCBmdW5jdGlvbklkIGluIGN1c3RvbUZ1bmN0aW9ucykge1xuICAgIGlmICghY3VzdG9tRnVuY3Rpb25zLmhhc093blByb3BlcnR5KGZ1bmN0aW9uSWQpKSBjb250aW51ZTtcbiAgICBjb25zdCBjdXN0b21GdW5jdGlvbiA9IGN1c3RvbUZ1bmN0aW9uc1tmdW5jdGlvbklkXSwgcHJvY2Vzc29yID0gbmV3IE1hcmtQcm9jZXNzb3IocXVlcnksIGN1c3RvbUZ1bmN0aW9uLm1hcmtzLCBjdXN0b21GdW5jdGlvbnMsIHt9KSwgRlVOQ1RJT05fREVDTF9CVUlMREVSID0gY3JlYXRlRnVuY3Rpb25EZWNsYXJhdGlvbkJ1aWxkZXIoKSwgZnVuY0RlY2wgPSBwcm9jZXNzb3IucHJvY2VzcyhGVU5DVElPTl9ERUNMX0JVSUxERVIpO1xuICAgIG1hcEN1c3RvbUZ1bmN0aW9uKGZ1bmNEZWNsLmJvZHksIChib2R5KSA9PiB3YWxrVmFsaWRhdGVDdXN0b21GdW5jdGlvbihib2R5KSk7XG4gIH1cbn1cbmNvbnN0IHsgY29tcGFyZSB9ID0gbmV3IEludGwuQ29sbGF0b3IoXCJlblwiKTtcbmZ1bmN0aW9uIHR5cGVOb2Rlc1NvcnRlcihhLCBiKSB7XG4gIHJldHVybiBhLnR5cGUgPT09IFwibnVsbFwiID8gMSA6IGNvbXBhcmUoaGFzaEZpZWxkKGEpLCBoYXNoRmllbGQoYikpO1xufVxuY29uc3QgaGFzaENhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBoYXNoRmllbGQoZmllbGQpIHtcbiAgaWYgKGhhc2hDYWNoZS5oYXMoZmllbGQpKVxuICAgIHJldHVybiBoYXNoQ2FjaGUuZ2V0KGZpZWxkKTtcbiAgY29uc3QgaGFzaCA9IGNhbGN1bGF0ZUZpZWxkSGFzaChmaWVsZCk7XG4gIHJldHVybiBoYXNoQ2FjaGUuc2V0KGZpZWxkLCBoYXNoKSwgaGFzaDtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUZpZWxkSGFzaChmaWVsZCkge1xuICBzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gZmllbGQudmFsdWUgIT09IHZvaWQgMCA/IGAke2ZpZWxkLnR5cGV9KCR7ZmllbGQudmFsdWV9KWAgOiBgJHtmaWVsZC50eXBlfWA7XG4gICAgY2FzZSBcIm51bGxcIjpcbiAgICBjYXNlIFwidW5rbm93blwiOlxuICAgICAgcmV0dXJuIGZpZWxkLnR5cGU7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICByZXR1cm4gYCR7ZmllbGQudHlwZX0oJHtoYXNoRmllbGQoZmllbGQub2YpfSlgO1xuICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5lbnRyaWVzKGZpZWxkLmF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMuc29ydCgoW2FdLCBbYl0pID0+IGNvbXBhcmUoYSwgYikpLCBgJHtmaWVsZC50eXBlfTooJHthdHRyaWJ1dGVzLm1hcChcbiAgICAgICAgKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fToke2hhc2hGaWVsZCh2YWx1ZS52YWx1ZSl9KCR7dmFsdWUub3B0aW9uYWwgPyBcIm9wdGlvbmFsXCIgOiBcIm5vbi1vcHRpb25hbFwifSlgXG4gICAgICApLmpvaW4oXCIsXCIpfSk6cmVmLSR7ZmllbGQuZGVyZWZlcmVuY2VzVG99OiR7ZmllbGQucmVzdCA/IGhhc2hGaWVsZChmaWVsZC5yZXN0KSA6IFwibm8tcmVzdFwifWA7XG4gICAgfVxuICAgIGNhc2UgXCJ1bmlvblwiOiB7XG4gICAgICBjb25zdCBzb3J0ZWQgPSBbLi4uZmllbGQub2ZdO1xuICAgICAgcmV0dXJuIHNvcnRlZC5zb3J0KHR5cGVOb2Rlc1NvcnRlciksIGAke2ZpZWxkLnR5cGV9KCR7c29ydGVkLm1hcChoYXNoRmllbGQpLmpvaW4oXCIsXCIpfSlgO1xuICAgIH1cbiAgICBjYXNlIFwiaW5saW5lXCI6XG4gICAgICByZXR1cm4gYCR7ZmllbGQudHlwZX0oJHtmaWVsZC5uYW1lfSlgO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmllbGQudHlwZTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlVHlwZU5vZGVzKHR5cGVOb2Rlcykge1xuICBjb25zdCBzZWVuVHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBuZXdUeXBlTm9kZXMgPSBbXSwgc29ydGVkVHlwZU5vZGVzID0gWy4uLnR5cGVOb2Rlc107XG4gIHNvcnRlZFR5cGVOb2Rlcy5zb3J0KHR5cGVOb2Rlc1NvcnRlcik7XG4gIGZvciAoY29uc3QgdHlwZU5vZGUgb2Ygc29ydGVkVHlwZU5vZGVzKSB7XG4gICAgY29uc3QgaGFzaCA9IGhhc2hGaWVsZCh0eXBlTm9kZSk7XG4gICAgaWYgKGhhc2ggPT09IG51bGwpIHtcbiAgICAgIG5ld1R5cGVOb2Rlcy5wdXNoKHR5cGVOb2RlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBzZWVuVHlwZXMuaGFzKGhhc2gpIHx8IChzZWVuVHlwZXMuYWRkKGhhc2gpLCBuZXdUeXBlTm9kZXMucHVzaCh0eXBlTm9kZSkpO1xuICB9XG4gIHJldHVybiBuZXdUeXBlTm9kZXM7XG59XG5mdW5jdGlvbiBvcHRpbWl6ZVVuaW9ucyhmaWVsZCkge1xuICBpZiAoZmllbGQudHlwZSA9PT0gXCJ1bmlvblwiKSB7XG4gICAgaWYgKGZpZWxkLm9mLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBmaWVsZDtcbiAgICBpZiAoZmllbGQub2YgPSByZW1vdmVEdXBsaWNhdGVUeXBlTm9kZXMoZmllbGQub2YpLCBmaWVsZC5vZi5sZW5ndGggPT09IDEpXG4gICAgICByZXR1cm4gb3B0aW1pemVVbmlvbnMoZmllbGQub2ZbMF0pO1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGZpZWxkLm9mLmxlbmd0aCA+IGlkeDsgaWR4KyspIHtcbiAgICAgIGNvbnN0IHN1YkZpZWxkID0gZmllbGQub2ZbaWR4XTtcbiAgICAgIGlmIChzdWJGaWVsZC50eXBlID09PSBcInVuaW9uXCIpIHtcbiAgICAgICAgZmllbGQub2Yuc3BsaWNlKGlkeCwgMSwgLi4uc3ViRmllbGQub2YpLCBpZHgtLTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmaWVsZC5vZltpZHhdID0gb3B0aW1pemVVbmlvbnMoc3ViRmllbGQpO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGQub2Yuc29ydCgoYSwgYikgPT4gYS50eXBlID09PSBcIm51bGxcIiA/IDEgOiBjb21wYXJlKGhhc2hGaWVsZChhKSwgaGFzaEZpZWxkKGIpKSksIGZpZWxkO1xuICB9XG4gIGlmIChmaWVsZC50eXBlID09PSBcImFycmF5XCIpXG4gICAgcmV0dXJuIGZpZWxkLm9mID0gb3B0aW1pemVVbmlvbnMoZmllbGQub2YpLCBmaWVsZDtcbiAgaWYgKGZpZWxkLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICBmb3IgKGNvbnN0IGlkeCBpbiBmaWVsZC5hdHRyaWJ1dGVzKVxuICAgICAgT2JqZWN0Lmhhc093bihmaWVsZC5hdHRyaWJ1dGVzLCBpZHgpICYmIChmaWVsZC5hdHRyaWJ1dGVzW2lkeF0udmFsdWUgPSBvcHRpbWl6ZVVuaW9ucyhmaWVsZC5hdHRyaWJ1dGVzW2lkeF0udmFsdWUpKTtcbiAgICByZXR1cm4gZmllbGQ7XG4gIH1cbiAgcmV0dXJuIGZpZWxkO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVmZXJlbmNlVHlwZU5vZGUobmFtZSwgaW5BcnJheSA9ICExKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB7XG4gICAgX3JlZjoge1xuICAgICAgdHlwZTogXCJvYmplY3RBdHRyaWJ1dGVcIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIF90eXBlOiB7XG4gICAgICB0eXBlOiBcIm9iamVjdEF0dHJpYnV0ZVwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgdmFsdWU6IFwicmVmZXJlbmNlXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIF93ZWFrOiB7XG4gICAgICB0eXBlOiBcIm9iamVjdEF0dHJpYnV0ZVwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogXCJib29sZWFuXCJcbiAgICAgIH0sXG4gICAgICBvcHRpb25hbDogITBcbiAgICB9XG4gIH07XG4gIHJldHVybiBpbkFycmF5ICYmIChhdHRyaWJ1dGVzLl9rZXkgPSB7XG4gICAgdHlwZTogXCJvYmplY3RBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgIH1cbiAgfSksIHtcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIGF0dHJpYnV0ZXMsXG4gICAgZGVyZWZlcmVuY2VzVG86IG5hbWVcbiAgfTtcbn1cbmZ1bmN0aW9uIG51bGxVbmlvbihub2RlKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFwidW5pb25cIiA/IHVuaW9uT2YoLi4ubm9kZS5vZiwgeyB0eXBlOiBcIm51bGxcIiB9KSA6IHVuaW9uT2Yobm9kZSwgeyB0eXBlOiBcIm51bGxcIiB9KTtcbn1cbmZ1bmN0aW9uIHVuaW9uT2YoLi4ubm9kZXMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgb2Y6IG5vZGVzXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlSW5saW5lKG5vZGUsIHNjb3BlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiaW5saW5lXCIpIHtcbiAgICBjb25zdCByZXNvbHZlZElubGluZSA9IHNjb3BlLmNvbnRleHQubG9va3VwVHlwZURlY2xhcmF0aW9uKG5vZGUpO1xuICAgIHJldHVybiByZXNvbHZlSW5saW5lKHJlc29sdmVkSW5saW5lLCBzY29wZSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBtYXBOb2RlKG5vZGUsIHNjb3BlLCBtYXBwZXIsIG1lcmdlVW5pb25zID0gKG5vZGVzKSA9PiBvcHRpbWl6ZVVuaW9ucyh7IHR5cGU6IFwidW5pb25cIiwgb2Y6IG5vZGVzIH0pKSB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICBjYXNlIFwibnVsbFwiOlxuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJ1bmtub3duXCI6XG4gICAgICByZXR1cm4gbWFwcGVyKG5vZGUpO1xuICAgIGNhc2UgXCJ1bmlvblwiOlxuICAgICAgcmV0dXJuIG1lcmdlVW5pb25zKG5vZGUub2YubWFwKChpbm5lcikgPT4gbWFwTm9kZShpbm5lciwgc2NvcGUsIG1hcHBlciksIG1lcmdlVW5pb25zKSk7XG4gICAgY2FzZSBcImlubGluZVwiOiB7XG4gICAgICBjb25zdCByZXNvbHZlZElubGluZSA9IHJlc29sdmVJbmxpbmUobm9kZSwgc2NvcGUpO1xuICAgICAgcmV0dXJuIG1hcE5vZGUocmVzb2x2ZWRJbmxpbmUsIHNjb3BlLCBtYXBwZXIsIG1lcmdlVW5pb25zKTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0eXBlOiAke25vZGUudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNGdW5jQ2FsbChub2RlLCBuYW1lKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFwiR3JvdXBcIiA/IGlzRnVuY0NhbGwobm9kZS5iYXNlLCBuYW1lKSA6IG5vZGUudHlwZSA9PT0gXCJGdW5jQ2FsbFwiICYmIGAke25vZGUubmFtZXNwYWNlfTo6JHtub2RlLm5hbWV9YCA9PT0gbmFtZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdlb0pzb24odHlwZSA9IFwiUG9pbnRcIikge1xuICBsZXQgY29vcmRpbmF0ZUF0dHJpYnV0ZSA9IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgb2Y6IHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgICB9XG4gIH07XG4gIHJldHVybiB0eXBlID09PSBcIkxpbmVTdHJpbmdcIiAmJiAoY29vcmRpbmF0ZUF0dHJpYnV0ZSA9IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgb2Y6IHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIG9mOiB7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgICAgIH1cbiAgICB9XG4gIH0pLCB0eXBlID09PSBcIlBvbHlnb25cIiAmJiAoY29vcmRpbmF0ZUF0dHJpYnV0ZSA9IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgb2Y6IHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIG9mOiB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgb2Y6IHtcbiAgICAgICAgICB0eXBlOiBcIm51bWJlclwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pLCB7XG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICB0eXBlOiB7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0QXR0cmlidXRlXCIsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY29vcmRpbmF0ZXM6IHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RBdHRyaWJ1dGVcIixcbiAgICAgICAgdmFsdWU6IGNvb3JkaW5hdGVBdHRyaWJ1dGVcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBib29sZWFuVmFsdWUobm9kZSwgc2NvcGUpIHtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwidW5rbm93blwiOlxuICAgICAgcmV0dXJuIHsgY2FuQmVUcnVlOiAhMCwgY2FuQmVGYWxzZTogITAsIGNhbkJlTnVsbDogITAgfTtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIG5vZGUudmFsdWUgPT09ICEwID8geyBjYW5CZVRydWU6ICEwLCBjYW5CZUZhbHNlOiAhMSwgY2FuQmVOdWxsOiAhMSB9IDogbm9kZS52YWx1ZSA9PT0gITEgPyB7IGNhbkJlVHJ1ZTogITEsIGNhbkJlRmFsc2U6ICEwLCBjYW5CZU51bGw6ICExIH0gOiB7IGNhbkJlVHJ1ZTogITAsIGNhbkJlRmFsc2U6ICEwLCBjYW5CZU51bGw6ICExIH07XG4gICAgY2FzZSBcInVuaW9uXCI6IHtcbiAgICAgIGNvbnN0IHZhbHVlID0geyBjYW5CZVRydWU6ICExLCBjYW5CZUZhbHNlOiAhMSwgY2FuQmVOdWxsOiAhMSB9O1xuICAgICAgZm9yIChjb25zdCBzdWIgb2Ygbm9kZS5vZikge1xuICAgICAgICBjb25zdCBtYXRjaDIgPSBib29sZWFuVmFsdWUoc3ViLCBzY29wZSk7XG4gICAgICAgIG1hdGNoMi5jYW5CZU51bGwgJiYgKHZhbHVlLmNhbkJlTnVsbCA9ICEwKSwgbWF0Y2gyLmNhbkJlVHJ1ZSAmJiAodmFsdWUuY2FuQmVUcnVlID0gITApLCBtYXRjaDIuY2FuQmVGYWxzZSAmJiAodmFsdWUuY2FuQmVGYWxzZSA9ICEwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY2FzZSBcImlubGluZVwiOiB7XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVJbmxpbmUobm9kZSwgc2NvcGUpO1xuICAgICAgcmV0dXJuIGJvb2xlYW5WYWx1ZShyZXNvbHZlZCwgc2NvcGUpO1xuICAgIH1cbiAgICBjYXNlIFwibnVsbFwiOlxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgcmV0dXJuIHsgY2FuQmVUcnVlOiAhMSwgY2FuQmVGYWxzZTogITEsIGNhbkJlTnVsbDogITAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIG5vZGUgdHlwZSAke25vZGUudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gYm9vbGVhbk9yKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBsZWZ0LmNhbkJlVHJ1ZSAmJiAhbGVmdC5jYW5CZUZhbHNlICYmICFsZWZ0LmNhbkJlTnVsbCA/IGxlZnQgOiByaWdodC5jYW5CZVRydWUgJiYgIXJpZ2h0LmNhbkJlRmFsc2UgJiYgIXJpZ2h0LmNhbkJlTnVsbCA/IHJpZ2h0IDoge1xuICAgIC8vIEVpdGhlciBzaWRlIGNhbiBiZSB0cnVlIGZvciB0aGUgZXhwcmVzc2lvbiB0byBiZSB0cnVlXG4gICAgY2FuQmVUcnVlOiBsZWZ0LmNhbkJlVHJ1ZSB8fCByaWdodC5jYW5CZVRydWUsXG4gICAgLy8gQm90aCBzaWRlcyBtdXN0IGJlIGZhbHNlIGZvciB0aGUgZXhwcmVzc2lvbiB0byBiZSBmYWxzZVxuICAgIGNhbkJlRmFsc2U6IGxlZnQuY2FuQmVGYWxzZSAmJiByaWdodC5jYW5CZUZhbHNlLFxuICAgIC8vIGlmIGVpdGhlciBzaWRlIGNhbiBiZSBudWxsLCB0aGUgZXhwcmVzc2lvbiBjYW4gYmUgbnVsbCBpZiB0aGUgb3RoZXIgc2lkZSBjYW4ndCBvbmx5IGJlIHRydWVcbiAgICBjYW5CZU51bGw6IGxlZnQuY2FuQmVOdWxsIHx8IHJpZ2h0LmNhbkJlTnVsbFxuICB9O1xufVxuZnVuY3Rpb24gYm9vbGVhbkFuZChsZWZ0LCByaWdodCkge1xuICByZXR1cm4gbGVmdC5jYW5CZUZhbHNlICYmICFsZWZ0LmNhbkJlVHJ1ZSAmJiAhbGVmdC5jYW5CZU51bGwgPyBsZWZ0IDogcmlnaHQuY2FuQmVGYWxzZSAmJiAhcmlnaHQuY2FuQmVUcnVlICYmICFyaWdodC5jYW5CZU51bGwgPyByaWdodCA6IHtcbiAgICAvLyBCb3RoIHNpZGVzIG11c3QgYmUgdHJ1ZSBmb3IgdGhlIGV4cHJlc3Npb24gdG8gYmUgdHJ1ZVxuICAgIGNhbkJlVHJ1ZTogbGVmdC5jYW5CZVRydWUgJiYgcmlnaHQuY2FuQmVUcnVlLFxuICAgIC8vIGlmIGVpdGhlciBzaWRlIGNhbiBiZSBmYWxzZSwgdGhlIGV4cHJlc3Npb24gY2FuIGJlIGZhbHNlXG4gICAgY2FuQmVGYWxzZTogbGVmdC5jYW5CZUZhbHNlIHx8IHJpZ2h0LmNhbkJlRmFsc2UsXG4gICAgLy8gaWYgZWl0aGVyIHNpZGUgY2FuIGJlIG51bGwsIHRoZSBleHByZXNzaW9uIGNhbiBiZSBudWxsXG4gICAgY2FuQmVOdWxsOiBsZWZ0LmNhbkJlTnVsbCB8fCByaWdodC5jYW5CZU51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIGJvb2xlYW5JbnRlcnByZXRhdGlvblRvVHlwZU5vZGUoYm9vbCkge1xuICByZXR1cm4gYm9vbC5jYW5CZVRydWUgPyBib29sLmNhbkJlRmFsc2UgPyBib29sLmNhbkJlTnVsbCA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiIH0pIDogeyB0eXBlOiBcImJvb2xlYW5cIiB9IDogYm9vbC5jYW5CZU51bGwgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiwgdmFsdWU6ICEwIH0pIDogeyB0eXBlOiBcImJvb2xlYW5cIiwgdmFsdWU6ICEwIH0gOiBib29sLmNhbkJlRmFsc2UgPyBib29sLmNhbkJlTnVsbCA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiLCB2YWx1ZTogITEgfSkgOiB7IHR5cGU6IFwiYm9vbGVhblwiLCB2YWx1ZTogITEgfSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbn1cbmNvbnN0IFNUUklOR19UWVBFX0RBVEVUSU1FID0gU3ltYm9sKFwiZ3JvcS1qcy50eXBlLnN0cmluZ19kYXRldGltZVwiKTtcbmZ1bmN0aW9uIHVuaW9uV2l0aG91dE51bGwodW5pb25UeXBlTm9kZSkge1xuICByZXR1cm4gdW5pb25UeXBlTm9kZS50eXBlID09PSBcInVuaW9uXCIgPyB7XG4gICAgdHlwZTogXCJ1bmlvblwiLFxuICAgIG9mOiB1bmlvblR5cGVOb2RlLm9mLmZpbHRlcigodHlwZSkgPT4gdHlwZS50eXBlICE9PSBcIm51bGxcIilcbiAgfSA6IHVuaW9uVHlwZU5vZGU7XG59XG5mdW5jdGlvbiBoYW5kbGVGdW5jQ2FsbE5vZGUobm9kZSwgc2NvcGUpIHtcbiAgc3dpdGNoIChgJHtub2RlLm5hbWVzcGFjZX0uJHtub2RlLm5hbWV9YCkge1xuICAgIGNhc2UgXCJhcnJheS5jb21wYWN0XCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IHtcbiAgICAgICAgaWYgKGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICAgICAgcmV0dXJuIG51bGxVbmlvbih7IHR5cGU6IFwiYXJyYXlcIiwgb2Y6IHsgdHlwZTogXCJ1bmtub3duXCIgfSB9KTtcbiAgICAgICAgaWYgKGFyZzIudHlwZSAhPT0gXCJhcnJheVwiKVxuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwibnVsbFwiIH07XG4gICAgICAgIGNvbnN0IG9mID0gbWFwTm9kZShhcmcyLm9mLCBzY29wZSwgKG9mMikgPT4gb2YyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgb2Y6IHVuaW9uV2l0aG91dE51bGwob2YpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgY2FzZSBcImFycmF5LmpvaW5cIjoge1xuICAgICAgY29uc3QgYXJyYXlBcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KSwgc2VwQXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1sxXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShcbiAgICAgICAgYXJyYXlBcmcsXG4gICAgICAgIHNjb3BlLFxuICAgICAgICAoYXJyYXlBcmcyKSA9PiBtYXBOb2RlKHNlcEFyZywgc2NvcGUsIChzZXBBcmcyKSA9PiBhcnJheUFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgc2VwQXJnMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBhcnJheUFyZzIudHlwZSAhPT0gXCJhcnJheVwiIHx8IHNlcEFyZzIudHlwZSAhPT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IG1hcE5vZGUoYXJyYXlBcmcyLm9mLCBzY29wZSwgKG9mKSA9PiBvZi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBvZi50eXBlICE9PSBcInN0cmluZ1wiICYmIG9mLnR5cGUgIT09IFwibnVtYmVyXCIgJiYgb2YudHlwZSAhPT0gXCJib29sZWFuXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7IHR5cGU6IFwic3RyaW5nXCIgfSkpXG4gICAgICApO1xuICAgIH1cbiAgICBjYXNlIFwiYXJyYXkudW5pcXVlXCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImFycmF5XCIsIG9mOiB7IHR5cGU6IFwidW5rbm93blwiIH0gfSkgOiBhcmcyLnR5cGUgIT09IFwiYXJyYXlcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IGFyZzIpO1xuICAgIH1cbiAgICBjYXNlIFwiYXJyYXkuaW50ZXJzZWN0c1wiOiB7XG4gICAgICBjb25zdCBhcmcxID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSksIGFyZzIgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzFdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKFxuICAgICAgICBhcmcxLFxuICAgICAgICBzY29wZSxcbiAgICAgICAgKGFyZzEyKSA9PiBtYXBOb2RlKGFyZzIsIHNjb3BlLCAoYXJnMjIpID0+IGFyZzEyLnR5cGUgIT09IFwiYXJyYXlcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IGFyZzIyLnR5cGUgIT09IFwiYXJyYXlcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHsgdHlwZTogXCJib29sZWFuXCIgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGNhc2UgXCJnbG9iYWwubG93ZXJcIjoge1xuICAgICAgY29uc3QgYXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShhcmcsIHNjb3BlLCAoYXJnMikgPT4gYXJnMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBhcmcyLnR5cGUgIT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBhcmcyLnZhbHVlICE9PSB2b2lkIDAgPyB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIHZhbHVlOiBhcmcyLnZhbHVlLnRvTG93ZXJDYXNlKClcbiAgICAgIH0gOiB7IHR5cGU6IFwic3RyaW5nXCIgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJnbG9iYWwudXBwZXJcIjoge1xuICAgICAgY29uc3QgYXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShhcmcsIHNjb3BlLCAoYXJnMikgPT4gYXJnMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBhcmcyLnR5cGUgIT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBhcmcyLnZhbHVlICE9PSB2b2lkIDAgPyB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIHZhbHVlOiBhcmcyLnZhbHVlLnRvVXBwZXJDYXNlKClcbiAgICAgIH0gOiB7IHR5cGU6IFwic3RyaW5nXCIgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJkYXRlVGltZS5ub3dcIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwic3RyaW5nXCIsIFtTVFJJTkdfVFlQRV9EQVRFVElNRV06ICEwIH07XG4gICAgY2FzZSBcImdsb2JhbC5ub3dcIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwic3RyaW5nXCIsIFtTVFJJTkdfVFlQRV9EQVRFVElNRV06ICEwIH07XG4gICAgY2FzZSBcImdsb2JhbC5kZWZpbmVkXCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKG5vZGUyKSA9PiBub2RlMi50eXBlID09PSBcInVua25vd25cIiA/IHsgdHlwZTogXCJib29sZWFuXCIgfSA6IHsgdHlwZTogXCJib29sZWFuXCIsIHZhbHVlOiBub2RlMi50eXBlICE9PSBcIm51bGxcIiB9KTtcbiAgICB9XG4gICAgY2FzZSBcImdsb2JhbC5wYXRoXCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiIH0pIDogYXJnMi50eXBlID09PSBcInN0cmluZ1wiID8geyB0eXBlOiBcInN0cmluZ1wiIH0gOiB7IHR5cGU6IFwibnVsbFwiIH0pO1xuICAgIH1cbiAgICBjYXNlIFwiZ2xvYmFsLmNvYWxlc2NlXCI6IHtcbiAgICAgIGlmIChub2RlLmFyZ3MubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgY29uc3QgdHlwZU5vZGVzID0gW107XG4gICAgICBsZXQgY2FuQmVOdWxsID0gITA7XG4gICAgICBmb3IgKGNvbnN0IGFyZyBvZiBub2RlLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgYXJnTm9kZSA9IG9wdGltaXplVW5pb25zKHdhbGsoeyBub2RlOiBhcmcsIHNjb3BlIH0pKSwgYWxsTnVsbCA9IGFyZ05vZGUudHlwZSA9PT0gXCJudWxsXCIgfHwgYXJnTm9kZS50eXBlID09PSBcInVuaW9uXCIgJiYgYXJnTm9kZS5vZi5ldmVyeSgodCkgPT4gdC50eXBlID09PSBcIm51bGxcIik7XG4gICAgICAgIGlmIChjYW5CZU51bGwgPSBhbGxOdWxsIHx8IGFyZ05vZGUudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgYXJnTm9kZS50eXBlID09PSBcInVuaW9uXCIgJiYgYXJnTm9kZS5vZi5zb21lKCh0KSA9PiB0LnR5cGUgPT09IFwibnVsbFwiIHx8IHQudHlwZSA9PT0gXCJ1bmtub3duXCIpLCBhbGxOdWxsIHx8IHR5cGVOb2Rlcy5wdXNoKHVuaW9uV2l0aG91dE51bGwoYXJnTm9kZSkpLCAhY2FuQmVOdWxsKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbkJlTnVsbCAmJiB0eXBlTm9kZXMucHVzaCh7IHR5cGU6IFwibnVsbFwiIH0pLCB7XG4gICAgICAgIHR5cGU6IFwidW5pb25cIixcbiAgICAgICAgb2Y6IHR5cGVOb2Rlc1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcImdsb2JhbC5jb3VudFwiOiB7XG4gICAgICBjb25zdCBhcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKGFyZywgc2NvcGUsIChhcmcyKSA9PiBhcmcyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJzdHJpbmdcIiB9KSA6IGFyZzIudHlwZSA9PT0gXCJhcnJheVwiID8geyB0eXBlOiBcIm51bWJlclwiIH0gOiB7IHR5cGU6IFwibnVsbFwiIH0pO1xuICAgIH1cbiAgICBjYXNlIFwiZ2xvYmFsLmRhdGVUaW1lXCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiLCBbU1RSSU5HX1RZUEVfREFURVRJTUVdOiAhMCB9KSA6IGFyZzIudHlwZSA9PT0gXCJzdHJpbmdcIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIsIFtTVFJJTkdfVFlQRV9EQVRFVElNRV06ICEwIH0pIDogeyB0eXBlOiBcIm51bGxcIiB9KTtcbiAgICB9XG4gICAgY2FzZSBcImdsb2JhbC5sZW5ndGhcIjoge1xuICAgICAgY29uc3QgYXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShhcmcsIHNjb3BlLCAoYXJnMikgPT4gYXJnMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBhcmcyLnR5cGUgPT09IFwiYXJyYXlcIiB8fCBhcmcyLnR5cGUgPT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVtYmVyXCIgfSA6IHsgdHlwZTogXCJudWxsXCIgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJnbG9iYWwucmVmZXJlbmNlc1wiOlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJib29sZWFuXCIgfTtcbiAgICBjYXNlIFwiZ2xvYmFsLnJvdW5kXCI6IHtcbiAgICAgIGNvbnN0IG51bU5vZGUgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKG51bU5vZGUsIHNjb3BlLCAobnVtKSA9PiB7XG4gICAgICAgIGlmIChudW0udHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICAgICAgcmV0dXJuIG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSk7XG4gICAgICAgIGlmIChudW0udHlwZSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgICBpZiAobm9kZS5hcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGNvbnN0IHByZWNpc2lvbk5vZGUgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzFdLCBzY29wZSB9KTtcbiAgICAgICAgICByZXR1cm4gbWFwTm9kZShwcmVjaXNpb25Ob2RlLCBzY29wZSwgKHByZWNpc2lvbikgPT4gcHJlY2lzaW9uLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IHByZWNpc2lvbi50eXBlICE9PSBcIm51bWJlclwiID8geyB0eXBlOiBcIm51bGxcIiB9IDogeyB0eXBlOiBcIm51bWJlclwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibnVtYmVyXCIgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjYXNlIFwiZ2xvYmFsLnN0cmluZ1wiOiB7XG4gICAgICBjb25zdCBhcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKGFyZywgc2NvcGUsIChub2RlMikgPT4gbm9kZTIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiIH0pIDogbm9kZTIudHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBub2RlMi50eXBlID09PSBcIm51bWJlclwiIHx8IG5vZGUyLnR5cGUgPT09IFwiYm9vbGVhblwiID8gbm9kZTIudmFsdWUgPyB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIHZhbHVlOiBub2RlMi52YWx1ZS50b1N0cmluZygpXG4gICAgICB9IDoge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9IDogeyB0eXBlOiBcIm51bGxcIiB9KTtcbiAgICB9XG4gICAgY2FzZSBcIm1hdGguc3VtXCI6IHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUodmFsdWVzLCBzY29wZSwgKG5vZGUyKSA9PiBub2RlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBub2RlMi50eXBlICE9PSBcImFycmF5XCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBtYXBOb2RlKG5vZGUyLm9mLCBzY29wZSwgKG5vZGUzKSA9PiBub2RlMy50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBub2RlMy50eXBlID09PSBcIm51bWJlclwiIHx8IG5vZGUzLnR5cGUgPT09IFwibnVsbFwiID8geyB0eXBlOiBcIm51bWJlclwiIH0gOiB7IHR5cGU6IFwibnVsbFwiIH0pKTtcbiAgICB9XG4gICAgY2FzZSBcIm1hdGguYXZnXCI6IHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUodmFsdWVzLCBzY29wZSwgKG5vZGUyKSA9PiBub2RlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBub2RlMi50eXBlICE9PSBcImFycmF5XCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBtYXBOb2RlKG5vZGUyLm9mLCBzY29wZSwgKG5vZGUzKSA9PiBub2RlMy50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBub2RlMy50eXBlID09PSBcIm51bWJlclwiID8geyB0eXBlOiBcIm51bWJlclwiIH0gOiB7IHR5cGU6IFwibnVsbFwiIH0pKTtcbiAgICB9XG4gICAgY2FzZSBcIm1hdGgubWF4XCI6XG4gICAgY2FzZSBcIm1hdGgubWluXCI6IHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUodmFsdWVzLCBzY29wZSwgKG5vZGUyKSA9PiBub2RlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBub2RlMi50eXBlICE9PSBcImFycmF5XCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBtYXBOb2RlKG5vZGUyLm9mLCBzY29wZSwgKG5vZGUzKSA9PiBub2RlMy50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBub2RlMy50eXBlID09PSBcIm51bWJlclwiID8gbm9kZTMgOiB7IHR5cGU6IFwibnVsbFwiIH0pKTtcbiAgICB9XG4gICAgY2FzZSBcInB0LnRleHRcIjpcbiAgICAgIHJldHVybiBub2RlLmFyZ3MubGVuZ3RoID09PSAwID8geyB0eXBlOiBcIm51bGxcIiB9IDoge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9O1xuICAgIGNhc2UgXCJzdHJpbmcuc3RhcnRzV2l0aFwiOiB7XG4gICAgICBjb25zdCBzdHJUeXBlTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pLCBwcmVmaXhUeXBlTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMV0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoc3RyVHlwZU5vZGUsIHNjb3BlLCAoc3RyTm9kZSkgPT4gbWFwTm9kZShwcmVmaXhUeXBlTm9kZSwgc2NvcGUsIChwcmVmaXhOb2RlKSA9PiBzdHJOb2RlLnR5cGUgPT09IFwidW5rbm93blwiIHx8IHByZWZpeE5vZGUudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiB9KSA6IHN0ck5vZGUudHlwZSAhPT0gXCJzdHJpbmdcIiB8fCBwcmVmaXhOb2RlLnR5cGUgIT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0pKTtcbiAgICB9XG4gICAgY2FzZSBcInN0cmluZy5zcGxpdFwiOiB7XG4gICAgICBjb25zdCBzdHJUeXBlTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pLCBzZXBUeXBlTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMV0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoc3RyVHlwZU5vZGUsIHNjb3BlLCAoc3RyTm9kZSkgPT4gbWFwTm9kZShzZXBUeXBlTm9kZSwgc2NvcGUsIChzZXBOb2RlKSA9PiBzdHJOb2RlLnR5cGUgPT09IFwidW5rbm93blwiIHx8IHNlcE5vZGUudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImFycmF5XCIsIG9mOiB7IHR5cGU6IFwic3RyaW5nXCIgfSB9KSA6IHN0ck5vZGUudHlwZSAhPT0gXCJzdHJpbmdcIiB8fCBzZXBOb2RlLnR5cGUgIT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7IHR5cGU6IFwiYXJyYXlcIiwgb2Y6IHsgdHlwZTogXCJzdHJpbmdcIiB9IH0pKTtcbiAgICB9XG4gICAgY2FzZSBcImdlby5sYXRMbmdcIjoge1xuICAgICAgY29uc3QgbGF0VHlwZU5vZGUgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KSwgbG5nVHlwZU5vZGUgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzFdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKGxhdFR5cGVOb2RlLCBzY29wZSwgKGxhdE5vZGUpID0+IG1hcE5vZGUobG5nVHlwZU5vZGUsIHNjb3BlLCAobG5nTm9kZSkgPT4gbGF0Tm9kZS50eXBlID09IFwidW5rbm93blwiIHx8IGxuZ05vZGUudHlwZSA9PSBcInVua25vd25cIiA/IG51bGxVbmlvbihjcmVhdGVHZW9Kc29uKCkpIDogbGF0Tm9kZS50eXBlICE9PSBcIm51bWJlclwiIHx8IGxuZ05vZGUudHlwZSAhPT0gXCJudW1iZXJcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IG51bGxVbmlvbihjcmVhdGVHZW9Kc29uKCkpKSk7XG4gICAgfVxuICAgIGNhc2UgXCJnZW8uY29udGFpbnNcIjpcbiAgICAgIHJldHVybiBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiB9KTtcbiAgICBjYXNlIFwiZ2VvLmludGVyc2VjdHNcIjpcbiAgICAgIHJldHVybiBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiB9KTtcbiAgICBjYXNlIFwiZ2VvLmRpc3RhbmNlXCI6XG4gICAgICByZXR1cm4gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KTtcbiAgICBjYXNlIFwic2FuaXR5LnZlcnNpb25PZlwiOiB7XG4gICAgICBjb25zdCB0eXBlTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUodHlwZU5vZGUsIHNjb3BlLCAodHlwZU5vZGUyKSA9PiB0eXBlTm9kZTIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiB9KSA6IHR5cGVOb2RlMi50eXBlICE9PSBcInN0cmluZ1wiID8geyB0eXBlOiBcIm51bGxcIiB9IDogeyB0eXBlOiBcImJvb2xlYW5cIiB9KTtcbiAgICB9XG4gICAgY2FzZSBcInNhbml0eS5wYXJ0T2ZSZWxlYXNlXCI6IHtcbiAgICAgIGNvbnN0IHR5cGVOb2RlID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZSh0eXBlTm9kZSwgc2NvcGUsICh0eXBlTm9kZTIpID0+IHR5cGVOb2RlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiIH0pIDogdHlwZU5vZGUyLnR5cGUgIT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0pO1xuICAgIH1cbiAgICBjYXNlIFwiZG9jdW1lbnRzLmdldFwiOiB7XG4gICAgICBjb25zdCB0eXBlTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUodHlwZU5vZGUsIHNjb3BlLCAodHlwZU5vZGUyKSA9PiB0eXBlTm9kZTIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyB0eXBlTm9kZTIgOiB0eXBlTm9kZTIudHlwZSAhPT0gXCJvYmplY3RcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHsgdHlwZTogXCJ1bmtub3duXCIgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJkb2N1bWVudHMuaW5jb21pbmdSZWZDb3VudFwiOlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJudW1iZXJcIiB9O1xuICAgIGNhc2UgXCJkb2N1bWVudHMuaW5jb21pbmdHbG9iYWxEb2N1bWVudFJlZmVyZW5jZUNvdW50XCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm51bWJlclwiIH07XG4gICAgY2FzZSBcIm1lZGlhLmFzcGVjdFwiOlxuICAgICAgcmV0dXJuIG1hcE5vZGUod2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSksIHNjb3BlLCAoZmllbGROb2RlKSA9PiBmaWVsZE5vZGUudHlwZSA9PT0gXCJudWxsXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBtYXBOb2RlKHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMV0sIHNjb3BlIH0pLCBzY29wZSwgKGFzcGVjdE5vZGUpID0+IGFzcGVjdE5vZGUudHlwZSAhPT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHsgdHlwZTogXCJ1bmtub3duXCIgfSkpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICB9XG59XG5mdW5jdGlvbiBtYXRjaChsZWZ0LCByaWdodCkge1xuICBsZXQgdG9rZW5zID0gW10sIHBhdHRlcm5zID0gW107XG4gIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAobGVmdC52YWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQobWF0Y2hUb2tlbml6ZShsZWZ0LnZhbHVlKSk7XG4gIH1cbiAgaWYgKGxlZnQudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgaWYgKGxlZnQub2YudHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGxlZnQub2YudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGxlZnQub2YudmFsdWUgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChtYXRjaFRva2VuaXplKGxlZnQub2YudmFsdWUpKTtcbiAgICB9XG4gICAgaWYgKGxlZnQub2YudHlwZSA9PT0gXCJ1bmlvblwiKVxuICAgICAgZm9yIChjb25zdCBub2RlIG9mIGxlZnQub2Yub2YpXG4gICAgICAgIG5vZGUudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBub2RlLnZhbHVlICE9PSB2b2lkIDAgJiYgKHRva2VucyA9IHRva2Vucy5jb25jYXQobWF0Y2hUb2tlbml6ZShub2RlLnZhbHVlKSkpO1xuICB9XG4gIGlmIChyaWdodC50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKHJpZ2h0LnZhbHVlID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgcGF0dGVybnMgPSBwYXR0ZXJucy5jb25jYXQobWF0Y2hBbmFseXplUGF0dGVybihyaWdodC52YWx1ZSkpO1xuICB9XG4gIGlmIChyaWdodC50eXBlID09PSBcImFycmF5XCIpIHtcbiAgICBpZiAocmlnaHQub2YudHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHJpZ2h0Lm9mLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChyaWdodC5vZi52YWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBwYXR0ZXJucyA9IHBhdHRlcm5zLmNvbmNhdChtYXRjaEFuYWx5emVQYXR0ZXJuKHJpZ2h0Lm9mLnZhbHVlKSk7XG4gICAgfVxuICAgIGlmIChyaWdodC5vZi50eXBlID09PSBcInVuaW9uXCIpXG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgcmlnaHQub2Yub2YpIHtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmIChub2RlLnZhbHVlID09PSB2b2lkIDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgcGF0dGVybnMgPSBwYXR0ZXJucy5jb25jYXQobWF0Y2hBbmFseXplUGF0dGVybihub2RlLnZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoVGV4dCh0b2tlbnMsIHBhdHRlcm5zKTtcbn1cbmNvbnN0ICR0cmFjZSQxID0gZGVidWcoXCJ0eXBlRXZhbHVhdG9yOnNjb3BlOnRyYWNlXCIpO1xuJHRyYWNlJDEubG9nID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbmNsYXNzIENvbnRleHQge1xuICBzY2hlbWE7XG4gIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICB9XG4gIGxvb2t1cFJlZihyZWZUbykge1xuICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuc2NoZW1hKVxuICAgICAgaWYgKHZhbC50eXBlID09PSBcImRvY3VtZW50XCIgJiYgdmFsLm5hbWUgPT09IHJlZlRvKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgYXR0cmlidXRlczogdmFsLmF0dHJpYnV0ZXNcbiAgICAgICAgfTtcbiAgICByZXR1cm4geyB0eXBlOiBcIm51bGxcIiB9O1xuICB9XG4gIGxvb2t1cFR5cGVEZWNsYXJhdGlvbihhbGlhcykge1xuICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuc2NoZW1hKVxuICAgICAgaWYgKHZhbC50eXBlID09PSBcInR5cGVcIiAmJiB2YWwubmFtZSA9PT0gYWxpYXMubmFtZSlcbiAgICAgICAgcmV0dXJuIHZhbC52YWx1ZTtcbiAgICByZXR1cm4geyB0eXBlOiBcIm51bGxcIiB9O1xuICB9XG59XG5jbGFzcyBTY29wZTIge1xuICB2YWx1ZTtcbiAgcGFyZW50O1xuICBjb250ZXh0O1xuICBpc0hpZGRlbjtcbiAgY29uc3RydWN0b3IodmFsdWUsIHBhcmVudCwgY29udGV4dCkge1xuICAgIHRoaXMudmFsdWUgPSB7IHR5cGU6IFwidW5pb25cIiwgb2Y6IHZhbHVlIH0sIHRoaXMucGFyZW50ID0gcGFyZW50LCB0aGlzLmNvbnRleHQgPSBjb250ZXh0IHx8IHBhcmVudD8uY29udGV4dCB8fCBuZXcgQ29udGV4dChbXSksIHRoaXMuaXNIaWRkZW4gPSAhMTtcbiAgfVxuICBjcmVhdGVOZXN0ZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5pc0hpZGRlbiA/IG5ldyBTY29wZTIodmFsdWUsIHRoaXMucGFyZW50LCB0aGlzLmNvbnRleHQpIDogbmV3IFNjb3BlMih2YWx1ZSwgdGhpcywgdGhpcy5jb250ZXh0KTtcbiAgfVxuICBjcmVhdGVIaWRkZW4odmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdC5pc0hpZGRlbiA9ICEwLCByZXN1bHQ7XG4gIH1cbn1cbmNvbnN0ICR0cmFjZSA9IGRlYnVnKFwidHlwZUV2YWx1YXRvcjpldmFsdWF0ZTp0cmFjZVwiKTtcbiR0cmFjZS5sb2cgPSBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuY29uc3QgJGRlYnVnID0gZGVidWcoXCJ0eXBlRXZhbHVhdG9yOmV2YWx1YXRlOmRlYnVnXCIpO1xuJGRlYnVnLmxvZyA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG5jb25zdCAkd2FybiA9IGRlYnVnKFwidHlwZUV2YWx1YXRvcjpldmFsdWF0ZTp3YXJuXCIpO1xuZnVuY3Rpb24gdHlwZUV2YWx1YXRlKGFzdCwgc2NoZW1hKSB7XG4gICRkZWJ1ZyhcImV2YWx1YXRlUXVlcnlUeXBlLmFzdCAlT1wiLCBhc3QpLCAkZGVidWcoXCJldmFsdWF0ZVF1ZXJ5VHlwZS5zY2hlbWEgJU9cIiwgc2NoZW1hKTtcbiAgY29uc3QgcGFyc2VkID0gd2Fsayh7XG4gICAgbm9kZTogYXN0LFxuICAgIHNjb3BlOiBuZXcgU2NvcGUyKFtdLCB2b2lkIDAsIG5ldyBDb250ZXh0KHNjaGVtYSkpXG4gIH0pO1xuICAkdHJhY2UoXCJldmFsdWF0ZVF1ZXJ5VHlwZS5wYXJzZWQgJU9cIiwgcGFyc2VkKTtcbiAgY29uc3Qgb3B0aW1pemVkID0gb3B0aW1pemVVbmlvbnMocGFyc2VkKTtcbiAgcmV0dXJuICRkZWJ1ZyhcImV2YWx1YXRlUXVlcnlUeXBlLm9wdGltaXplZCAlT1wiLCBvcHRpbWl6ZWQpLCBvcHRpbWl6ZWQ7XG59XG5mdW5jdGlvbiBtYXBEZXJlZihub2RlLCBzY29wZSkge1xuICByZXR1cm4gbWFwTm9kZShub2RlLCBzY29wZSwgKGJhc2UpID0+IHtcbiAgICBpZiAoYmFzZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIG9mOiBtYXBEZXJlZihiYXNlLm9mLCBzY29wZSlcbiAgICAgIH07XG4gICAgaWYgKGJhc2UudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKGJhc2UuZGVyZWZlcmVuY2VzVG8gIT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuIHNjb3BlLmNvbnRleHQubG9va3VwUmVmKGJhc2UuZGVyZWZlcmVuY2VzVG8pO1xuICAgICAgaWYgKGJhc2UucmVzdCAhPT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gbWFwRGVyZWYocmVzb2x2ZUlubGluZShiYXNlLnJlc3QsIHNjb3BlKSwgc2NvcGUpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcIm51bGxcIiB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZURlcmVmTm9kZShub2RlLCBzY29wZSkge1xuICAkdHJhY2UoXCJkZXJlZi5ub2RlICVPXCIsIG5vZGUpO1xuICBjb25zdCBkZXJlZmVkTm9kZSA9IG1hcERlcmVmKHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pLCBzY29wZSk7XG4gIHJldHVybiAkdHJhY2UoXCJkZXJlZi5kZXJlZmVkTm9kZSAlT1wiLCBkZXJlZmVkTm9kZSksIGRlcmVmZWROb2RlO1xufVxuZnVuY3Rpb24gaGFuZGxlT2JqZWN0U3BsYXROb2RlKGF0dHIsIHNjb3BlKSB7XG4gIGNvbnN0IHZhbHVlID0gd2Fsayh7IG5vZGU6IGF0dHIudmFsdWUsIHNjb3BlIH0pO1xuICByZXR1cm4gJHRyYWNlKFwib2JqZWN0LnNwbGF0LnZhbHVlICVPXCIsIHZhbHVlKSwgbWFwTm9kZSh2YWx1ZSwgc2NvcGUsIChub2RlKSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICAgIGlmIChub2RlLnR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4geyB0eXBlOiBcIm9iamVjdFwiLCBhdHRyaWJ1dGVzOiB7fSB9O1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbm9kZS5hdHRyaWJ1dGVzKVxuICAgICAgbm9kZS5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIChhdHRyaWJ1dGVzW25hbWVdID0gbm9kZS5hdHRyaWJ1dGVzW25hbWVdKTtcbiAgICBpZiAobm9kZS5yZXN0ICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHJlc29sdmVkUmVzdCA9IHJlc29sdmVJbmxpbmUobm9kZS5yZXN0LCBzY29wZSk7XG4gICAgICBpZiAocmVzb2x2ZWRSZXN0LnR5cGUgPT09IFwidW5rbm93blwiKVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICAgICAgaWYgKHJlc29sdmVkUmVzdC50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHJlc29sdmVkUmVzdC5hdHRyaWJ1dGVzKVxuICAgICAgICByZXNvbHZlZFJlc3QuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAoYXR0cmlidXRlc1tuYW1lXSA9IHJlc29sdmVkUmVzdC5hdHRyaWJ1dGVzW25hbWVdKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJvYmplY3RcIiwgYXR0cmlidXRlcyB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU9iamVjdE5vZGUobm9kZSwgc2NvcGUpIHtcbiAgaWYgKCR0cmFjZShcIm9iamVjdC5ub2RlICVPXCIsIG5vZGUpLCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgYXR0cmlidXRlczoge31cbiAgICB9O1xuICBjb25zdCBvYmplY3RBdHRyaWJ1dGVzID0gW10sIHNwbGF0VmFyaWFudHMgPSBbXSwgY29uZGl0aW9uYWxWYXJpYW50cyA9IFtdO1xuICBmb3IgKGNvbnN0IFtpZHgsIGF0dHJdIG9mIG5vZGUuYXR0cmlidXRlcy5lbnRyaWVzKCkpIHtcbiAgICBpZiAoYXR0ci50eXBlID09PSBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCIpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZU5vZGUgPSB3YWxrKHsgbm9kZTogYXR0ci52YWx1ZSwgc2NvcGUgfSk7XG4gICAgICBvYmplY3RBdHRyaWJ1dGVzLnB1c2goW1xuICAgICAgICBpZHgsXG4gICAgICAgIGF0dHIubmFtZSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwib2JqZWN0QXR0cmlidXRlXCIsXG4gICAgICAgICAgdmFsdWU6IGF0dHJpYnV0ZU5vZGVcbiAgICAgICAgfVxuICAgICAgXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGF0dHIudHlwZSA9PT0gXCJPYmplY3RTcGxhdFwiKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVOb2RlID0gaGFuZGxlT2JqZWN0U3BsYXROb2RlKGF0dHIsIHNjb3BlKTtcbiAgICAgIHN3aXRjaCAoJHRyYWNlKFwib2JqZWN0LnNwbGF0LnJlc3VsdCAlT1wiLCBhdHRyaWJ1dGVOb2RlKSwgYXR0cmlidXRlTm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgIHNwbGF0VmFyaWFudHMucHVzaChbaWR4LCBhdHRyaWJ1dGVOb2RlXSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInVuaW9uXCI6IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUyIG9mIGF0dHJpYnV0ZU5vZGUub2YpXG4gICAgICAgICAgICBpZiAobm9kZTIudHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICAgICAgICAgIHJldHVybiBub2RlMjtcbiAgICAgICAgICBzcGxhdFZhcmlhbnRzLnB1c2goW2lkeCwgYXR0cmlidXRlTm9kZV0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0dHIudHlwZSA9PT0gXCJPYmplY3RDb25kaXRpb25hbFNwbGF0XCIpIHtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IGJvb2xlYW5WYWx1ZSh3YWxrKHsgbm9kZTogYXR0ci5jb25kaXRpb24sIHNjb3BlIH0pLCBzY29wZSk7XG4gICAgICBpZiAoJHRyYWNlKFwib2JqZWN0LmNvbmRpdGlvbmFsLnNwbGF0LmNvbmRpdGlvbiAlT1wiLCBjb25kaXRpb24pLCBjb25kaXRpb24uY2FuQmVUcnVlID09PSAhMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVOb2RlID0gaGFuZGxlT2JqZWN0U3BsYXROb2RlKGF0dHIsIHNjb3BlKTtcbiAgICAgIGlmICgkdHJhY2UoXCJvYmplY3QuY29uZGl0aW9uYWwuc3BsYXQucmVzdWx0ICVPXCIsIGF0dHJpYnV0ZU5vZGUpLCBjb25kaXRpb24uY2FuQmVGYWxzZSA9PT0gITEgJiYgY29uZGl0aW9uLmNhbkJlTnVsbCA9PT0gITEpXG4gICAgICAgIHN3aXRjaCAoYXR0cmlidXRlTm9kZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICBzcGxhdFZhcmlhbnRzLnB1c2goW2lkeCwgYXR0cmlidXRlTm9kZV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ1bmlvblwiOiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUyIG9mIGF0dHJpYnV0ZU5vZGUub2YpXG4gICAgICAgICAgICAgIGlmIChub2RlMi50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwidW5rbm93blwiIH07XG4gICAgICAgICAgICBzcGxhdFZhcmlhbnRzLnB1c2goW2lkeCwgYXR0cmlidXRlTm9kZV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICAgICAgICB9XG4gICAgICBjb25zdCB2YXJpYW50ID0gbWFwTm9kZShhdHRyaWJ1dGVOb2RlLCBzY29wZSwgKGF0dHJpYnV0ZU5vZGUyKSA9PiAoJHRyYWNlKFwib2JqZWN0LmNvbmRpdGlvbmFsLnNwbGF0LnJlc3VsdC5jb25jcmV0ZSAlT1wiLCBhdHRyaWJ1dGVOb2RlMiksIGF0dHJpYnV0ZU5vZGUyLnR5cGUgIT09IFwib2JqZWN0XCIgPyB7IHR5cGU6IFwidW5rbm93blwiIH0gOiB7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZU5vZGUyLmF0dHJpYnV0ZXNcbiAgICAgIH0pKTtcbiAgICAgIGlmICh2YXJpYW50LnR5cGUgPT09IFwidW5pb25cIikge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUyIG9mIHZhcmlhbnQub2YpXG4gICAgICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICAgICAgICB2YXJpYW50Lm9mLnB1c2goeyB0eXBlOiBcIm9iamVjdFwiLCBhdHRyaWJ1dGVzOiB7fSB9KSwgY29uZGl0aW9uYWxWYXJpYW50cy5wdXNoKFtpZHgsIHZhcmlhbnRdKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodmFyaWFudC50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICAgICAgY29uZGl0aW9uYWxWYXJpYW50cy5wdXNoKFtcbiAgICAgICAgaWR4LFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgICAgIG9mOiBbeyB0eXBlOiBcIm9iamVjdFwiLCBhdHRyaWJ1dGVzOiB7fSB9LCB2YXJpYW50XVxuICAgICAgICB9XG4gICAgICBdKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gb2JqZWN0IGF0dHJpYnV0ZSB0eXBlOiAke2F0dHIudHlwZX1gKTtcbiAgfVxuICBjb25zdCBndWFyYW50ZWVkQXR0cmlidXRlcyA9IFtdO1xuICBndWFyYW50ZWVkQXR0cmlidXRlcy5wdXNoKC4uLm9iamVjdEF0dHJpYnV0ZXMpO1xuICBmb3IgKGNvbnN0IFtpZHgsIHNwbGF0Tm9kZV0gb2Ygc3BsYXRWYXJpYW50cykge1xuICAgIGlmIChzcGxhdE5vZGUudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHNwbGF0Tm9kZS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmICghc3BsYXROb2RlLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkobmFtZSkpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IHNwbGF0Tm9kZS5hdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBndWFyYW50ZWVkQXR0cmlidXRlcy5wdXNoKFtpZHgsIG5hbWUsIGF0dHJpYnV0ZV0pO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbmRpdGlvbmFsVmFyaWFudHMucHVzaChbaWR4LCBzcGxhdE5vZGVdKTtcbiAgfVxuICBpZiAoZ3VhcmFudGVlZEF0dHJpYnV0ZXMuc29ydCgoW2FdLCBbYl0pID0+IGEgLSBiKSwgY29uZGl0aW9uYWxWYXJpYW50cy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBhdHRyaWJ1dGVzOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIGd1YXJhbnRlZWRBdHRyaWJ1dGVzLm1hcCgoWywgbmFtZSwgYXR0cmlidXRlXSkgPT4gW25hbWUsIGF0dHJpYnV0ZV0pXG4gICAgICApXG4gICAgfTtcbiAgY29uc3QgbWF0cml4ID0gW107XG4gIGZvciAoY29uc3QgW3VuaW9uSWR4LCB1bmlvbl0gb2YgY29uZGl0aW9uYWxWYXJpYW50cykge1xuICAgIGNvbnN0IHVuaW9uR3VhcmFudGVlZEJlZm9yZSA9IFtdLCB1bmlvbkd1YXJhbnRlZWRBZnRlciA9IFtdO1xuICAgIGZvciAoY29uc3QgW2d1YXJhbnRlZWRJbmRleCwgbmFtZSwgYXR0cmlidXRlXSBvZiBndWFyYW50ZWVkQXR0cmlidXRlcylcbiAgICAgIGd1YXJhbnRlZWRJbmRleCA8IHVuaW9uSWR4ICYmIHVuaW9uR3VhcmFudGVlZEJlZm9yZS5wdXNoKFtndWFyYW50ZWVkSW5kZXgsIG5hbWUsIGF0dHJpYnV0ZV0pLCBndWFyYW50ZWVkSW5kZXggPiB1bmlvbklkeCAmJiB1bmlvbkd1YXJhbnRlZWRBZnRlci5wdXNoKFtndWFyYW50ZWVkSW5kZXgsIG5hbWUsIGF0dHJpYnV0ZV0pO1xuICAgIGNvbnN0IGFsbFZhcmlhbnRzQXR0cmlidXRlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2NvbmRpdGlvbmFsVmFyaWFudElkeCwgb3RoZXJVbmlvbl0gb2YgY29uZGl0aW9uYWxWYXJpYW50cykge1xuICAgICAgY29uc3QgdmFyaWFudEF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgbm9kZTIgb2Ygb3RoZXJVbmlvbi5vZilcbiAgICAgICAgdmFyaWFudEF0dHJpYnV0ZXMucHVzaChub2RlMi5hdHRyaWJ1dGVzKTtcbiAgICAgIGFsbFZhcmlhbnRzQXR0cmlidXRlcy5wdXNoKFtjb25kaXRpb25hbFZhcmlhbnRJZHgsIHZhcmlhbnRBdHRyaWJ1dGVzXSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgbm9kZTIgb2YgdW5pb24ub2YpIHtcbiAgICAgIG1hdHJpeC5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgIHVuaW9uR3VhcmFudGVlZEJlZm9yZS5tYXAoKFssIG5hbWUsIGF0dHJpYnV0ZV0pID0+IFtuYW1lLCBhdHRyaWJ1dGVdKVxuICAgICAgICAgICksXG4gICAgICAgICAgLi4ubm9kZTIuYXR0cmlidXRlcyxcbiAgICAgICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICB1bmlvbkd1YXJhbnRlZWRBZnRlci5tYXAoKFssIG5hbWUsIGF0dHJpYnV0ZV0pID0+IFtuYW1lLCBhdHRyaWJ1dGVdKVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBmb3IgKGNvbnN0IFtvdXRlcklkeCwgb3V0ZXJBdHRyaWJ1dGVzXSBvZiBhbGxWYXJpYW50c0F0dHJpYnV0ZXMpXG4gICAgICAgIGZvciAoY29uc3Qgb3V0ZXIgb2Ygb3V0ZXJBdHRyaWJ1dGVzKVxuICAgICAgICAgIGZvciAoY29uc3QgW2lubmVySWR4LCBpbm5lckF0dHJpYnV0ZXNdIG9mIGFsbFZhcmlhbnRzQXR0cmlidXRlcylcbiAgICAgICAgICAgIGlmIChvdXRlcklkeCAhPT0gaW5uZXJJZHgpXG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaW5uZXIgb2YgaW5uZXJBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2JlZm9yZSA9IFsuLi51bmlvbkd1YXJhbnRlZWRCZWZvcmVdLCBfYWZ0ZXIgPSBbLi4udW5pb25HdWFyYW50ZWVkQWZ0ZXJdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBvdXRlcilcbiAgICAgICAgICAgICAgICAgIG91dGVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIG91dGVySWR4ICE9PSB1bmlvbklkeCAmJiAob3V0ZXJJZHggPCB1bmlvbklkeCAmJiBfYmVmb3JlLnB1c2goW291dGVySWR4LCBuYW1lLCBvdXRlcltuYW1lXV0pLCBvdXRlcklkeCA+IHVuaW9uSWR4ICYmIF9hZnRlci5wdXNoKFtvdXRlcklkeCwgbmFtZSwgb3V0ZXJbbmFtZV1dKSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGlubmVyKVxuICAgICAgICAgICAgICAgICAgaW5uZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgb3V0ZXJJZHggIT09IHVuaW9uSWR4ICYmIChpbm5lcklkeCA8IHVuaW9uSWR4ICYmIF9iZWZvcmUucHVzaChbaW5uZXJJZHgsIG5hbWUsIGlubmVyW25hbWVdXSksIGlubmVySWR4ID4gdW5pb25JZHggJiYgX2FmdGVyLnB1c2goW2lubmVySWR4LCBuYW1lLCBpbm5lcltuYW1lXV0pKTtcbiAgICAgICAgICAgICAgICBfYmVmb3JlLnNvcnQoKFthXSwgW2JdKSA9PiBhIC0gYiksIF9hZnRlci5zb3J0KChbYV0sIFtiXSkgPT4gYSAtIGIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZSA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgICAgICAgIF9iZWZvcmUubWFwKChbLCBuYW1lLCBhdHRyaWJ1dGVdKSA9PiBbbmFtZSwgYXR0cmlidXRlXSlcbiAgICAgICAgICAgICAgICApLCBhZnRlciA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgICAgICAgIF9hZnRlci5tYXAoKFssIG5hbWUsIGF0dHJpYnV0ZV0pID0+IFtuYW1lLCBhdHRyaWJ1dGVdKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbWF0cml4LnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYmVmb3JlLFxuICAgICAgICAgICAgICAgICAgICAuLi5ub2RlMi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAuLi5hZnRlclxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpbWl6ZVVuaW9ucyh7XG4gICAgdHlwZTogXCJ1bmlvblwiLFxuICAgIG9mOiBtYXRyaXhcbiAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVPcENhbGxOb2RlKG5vZGUsIHNjb3BlKSB7XG4gICR0cmFjZShcIm9wY2FsbC5ub2RlICVPXCIsIG5vZGUpO1xuICBjb25zdCBsaHMgPSB3YWxrKHsgbm9kZTogbm9kZS5sZWZ0LCBzY29wZSB9KSwgcmhzID0gd2Fsayh7IG5vZGU6IG5vZGUucmlnaHQsIHNjb3BlIH0pO1xuICByZXR1cm4gbWFwTm9kZShcbiAgICBsaHMsXG4gICAgc2NvcGUsXG4gICAgKGxlZnQpID0+IChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50c1xuICAgICAgbWFwTm9kZShyaHMsIHNjb3BlLCAocmlnaHQpID0+IHtcbiAgICAgICAgc3dpdGNoICgkdHJhY2UoJ29wY2FsbC5ub2RlLmNvbmNyZXRlIFwiJXNcIiAlTycsIG5vZGUub3AsIHsgbGVmdCwgcmlnaHQgfSksIG5vZGUub3ApIHtcbiAgICAgICAgICBjYXNlIFwiPT1cIjpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiID8geyB0eXBlOiBcImJvb2xlYW5cIiB9IDogbGVmdC50eXBlICE9PSByaWdodC50eXBlID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgdmFsdWU6ICExXG4gICAgICAgICAgICB9IDogbGVmdC50eXBlID09PSBcIm51bGxcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgfSA6ICFpc1ByaW1pdGl2ZVR5cGVOb2RlKGxlZnQpIHx8ICFpc1ByaW1pdGl2ZVR5cGVOb2RlKHJpZ2h0KSA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiAhMVxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBldmFsdWF0ZUNvbXBhcmlzb24obm9kZS5vcCwgbGVmdCwgcmlnaHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgXCIhPVwiOiB7XG4gICAgICAgICAgICBpZiAobGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIilcbiAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJib29sZWFuXCIgfTtcbiAgICAgICAgICAgIGlmIChsZWZ0LnR5cGUgIT09IHJpZ2h0LnR5cGUpXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAobGVmdC50eXBlID09PSBcIm51bGxcIilcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogITFcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghaXNQcmltaXRpdmVUeXBlTm9kZShsZWZ0KSB8fCAhaXNQcmltaXRpdmVUeXBlTm9kZShyaWdodCkpXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBldmFsdWF0ZUNvbXBhcmlzb24oXCI9PVwiLCBsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZvaWQgMCAmJiAodmFsdWUgPSAhdmFsdWUpLCB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICBjYXNlIFwiPj1cIjpcbiAgICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgIGNhc2UgXCI8PVwiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiB9KSA6IGxlZnQudHlwZSAhPT0gcmlnaHQudHlwZSA/IHsgdHlwZTogXCJudWxsXCIgfSA6ICFpc1ByaW1pdGl2ZVR5cGVOb2RlKGxlZnQpIHx8ICFpc1ByaW1pdGl2ZVR5cGVOb2RlKHJpZ2h0KSA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBldmFsdWF0ZUNvbXBhcmlzb24obm9kZS5vcCwgbGVmdCwgcmlnaHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgXCJpblwiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiB9KSA6IHJpZ2h0LnR5cGUgIT09IFwiYXJyYXlcIiA/IGlzRnVuY0NhbGwobm9kZS5yaWdodCwgXCJnbG9iYWw6OnBhdGhcIikgPyB7IHR5cGU6IFwiYm9vbGVhblwiIH0gOiB7IHR5cGU6IFwibnVsbFwiIH0gOiAhaXNQcmltaXRpdmVUeXBlTm9kZShsZWZ0KSAmJiBsZWZ0LnR5cGUgIT09IFwibnVsbFwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgdmFsdWU6ICExXG4gICAgICAgICAgICB9IDogbWFwTm9kZShyaWdodC5vZiwgc2NvcGUsIChhcnJheVR5cGVOb2RlKSA9PiBhcnJheVR5cGVOb2RlLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJib29sZWFuXCIgfSkgOiBsZWZ0LnR5cGUgPT09IFwibnVsbFwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGFycmF5VHlwZU5vZGUudHlwZSA9PT0gXCJudWxsXCJcbiAgICAgICAgICAgIH0gOiBsZWZ0LnZhbHVlID09PSB2b2lkIDAgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiXG4gICAgICAgICAgICB9IDogaXNQcmltaXRpdmVUeXBlTm9kZShhcnJheVR5cGVOb2RlKSA/IGFycmF5VHlwZU5vZGUudmFsdWUgPT09IHZvaWQgMCA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCJcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogbGVmdC52YWx1ZSA9PT0gYXJyYXlUeXBlTm9kZS52YWx1ZVxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiAhMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY2FzZSBcIm1hdGNoXCI6XG4gICAgICAgICAgICByZXR1cm4gbGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIiA/IHsgdHlwZTogXCJib29sZWFuXCIgfSA6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBtYXRjaChsZWZ0LCByaWdodClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiID8geyB0eXBlOiBcInVua25vd25cIiB9IDogbGVmdC50eXBlID09PSBcInN0cmluZ1wiICYmIHJpZ2h0LnR5cGUgPT09IFwic3RyaW5nXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBsZWZ0LnZhbHVlICE9PSB2b2lkIDAgJiYgcmlnaHQudmFsdWUgIT09IHZvaWQgMCA/IGxlZnQudmFsdWUgKyByaWdodC52YWx1ZSA6IHZvaWQgMFxuICAgICAgICAgICAgfSA6IGxlZnQudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBsZWZ0W1NUUklOR19UWVBFX0RBVEVUSU1FXSAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8geyB0eXBlOiBcInN0cmluZ1wiLCBbU1RSSU5HX1RZUEVfREFURVRJTUVdOiAhMCB9IDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwic3RyaW5nXCIgJiYgcmlnaHRbU1RSSU5HX1RZUEVfREFURVRJTUVdID8geyB0eXBlOiBcInN0cmluZ1wiLCBbU1RSSU5HX1RZUEVfREFURVRJTUVdOiAhMCB9IDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBsZWZ0LnZhbHVlICE9PSB2b2lkIDAgJiYgcmlnaHQudmFsdWUgIT09IHZvaWQgMCA/IGxlZnQudmFsdWUgKyByaWdodC52YWx1ZSA6IHZvaWQgMFxuICAgICAgICAgICAgfSA6IGxlZnQudHlwZSA9PT0gXCJhcnJheVwiICYmIHJpZ2h0LnR5cGUgPT09IFwiYXJyYXlcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICBvZjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5pb25cIixcbiAgICAgICAgICAgICAgICBvZjogW2xlZnQub2YsIHJpZ2h0Lm9mXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IDogbGVmdC50eXBlID09PSBcIm9iamVjdFwiICYmIHJpZ2h0LnR5cGUgPT09IFwib2JqZWN0XCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHsgLi4ubGVmdC5hdHRyaWJ1dGVzLCAuLi5yaWdodC5hdHRyaWJ1dGVzIH1cbiAgICAgICAgICAgIH0gOiB7IHR5cGU6IFwibnVsbFwiIH07XG4gICAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IGxlZnQudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBsZWZ0W1NUUklOR19UWVBFX0RBVEVUSU1FXSAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8geyB0eXBlOiBcInN0cmluZ1wiLCBbU1RSSU5HX1RZUEVfREFURVRJTUVdOiAhMCB9IDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBsZWZ0LnZhbHVlICE9PSB2b2lkIDAgJiYgcmlnaHQudmFsdWUgIT09IHZvaWQgMCA/IGxlZnQudmFsdWUgLSByaWdodC52YWx1ZSA6IHZvaWQgMFxuICAgICAgICAgICAgfSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbiAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBsZWZ0LnZhbHVlICE9PSB2b2lkIDAgJiYgcmlnaHQudmFsdWUgIT09IHZvaWQgMCA/IGxlZnQudmFsdWUgKiByaWdodC52YWx1ZSA6IHZvaWQgMFxuICAgICAgICAgICAgfSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbiAgICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBsZWZ0LnZhbHVlICE9PSB2b2lkIDAgJiYgcmlnaHQudmFsdWUgIT09IHZvaWQgMCA/IGxlZnQudmFsdWUgLyByaWdodC52YWx1ZSA6IHZvaWQgMFxuICAgICAgICAgICAgfSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbiAgICAgICAgICBjYXNlIFwiKipcIjpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogbGVmdC52YWx1ZSAhPT0gdm9pZCAwICYmIHJpZ2h0LnZhbHVlICE9PSB2b2lkIDAgPyBsZWZ0LnZhbHVlICoqIHJpZ2h0LnZhbHVlIDogdm9pZCAwXG4gICAgICAgICAgICB9IDogeyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgICAgICByZXR1cm4gbGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGxlZnQudmFsdWUgIT09IHZvaWQgMCAmJiByaWdodC52YWx1ZSAhPT0gdm9pZCAwID8gbGVmdC52YWx1ZSAlIHJpZ2h0LnZhbHVlIDogdm9pZCAwXG4gICAgICAgICAgICB9IDogeyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBcInVua25vd25cIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBoYW5kbGVTZWxlY3ROb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IHZhbHVlcyA9IFtdO1xuICBsZXQgZ3VhcmFudGVlZCA9ICExO1xuICBmb3IgKGNvbnN0IGFsdGVybmF0aXZlIG9mIG5vZGUuYWx0ZXJuYXRpdmVzKSB7XG4gICAgY29uc3QgY29uZGl0aW9uVmFsdWUgPSB3YWxrKHsgbm9kZTogYWx0ZXJuYXRpdmUuY29uZGl0aW9uLCBzY29wZSB9KSwgY29uZGl0aW9uU2NvcGUgPSByZXNvbHZlRmlsdGVyKGFsdGVybmF0aXZlLmNvbmRpdGlvbiwgc2NvcGUpO1xuICAgIGNvbmRpdGlvblNjb3BlLnR5cGUgPT09IFwidW5pb25cIiAmJiBjb25kaXRpb25TY29wZS5vZi5sZW5ndGggPiAwICYmIHZhbHVlcy5wdXNoKHdhbGsoeyBub2RlOiBhbHRlcm5hdGl2ZS52YWx1ZSwgc2NvcGU6IHNjb3BlLmNyZWF0ZUhpZGRlbihjb25kaXRpb25TY29wZS5vZikgfSkpLCBjb25kaXRpb25WYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBjb25kaXRpb25WYWx1ZS52YWx1ZSA9PT0gITAgJiYgKGd1YXJhbnRlZWQgPSAhMCk7XG4gIH1cbiAgcmV0dXJuIG5vZGUuZmFsbGJhY2sgJiYgIWd1YXJhbnRlZWQgJiYgdmFsdWVzLnB1c2god2Fsayh7IG5vZGU6IG5vZGUuZmFsbGJhY2ssIHNjb3BlIH0pKSwgdmFsdWVzLmxlbmd0aCA9PT0gMCA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHtcbiAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgb2Y6IHZhbHVlc1xuICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlQXJyYXlDb2VyY2VOb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IGJhc2UgPSB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KTtcbiAgcmV0dXJuICR0cmFjZShcImFycmF5Q29lcmNlLmJhc2UgJU9cIiwgYmFzZSksIG1hcEFycmF5KGJhc2UsIHNjb3BlLCAoYmFzZTIpID0+IGJhc2UyKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUZsYXRNYXAobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gbWFwQXJyYXkoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4ge1xuICAgIGNvbnN0IGlubmVyID0gd2Fsayh7IG5vZGU6IG5vZGUuZXhwciwgc2NvcGU6IHNjb3BlLmNyZWF0ZUhpZGRlbihbYmFzZTIub2ZdKSB9KTtcbiAgICByZXR1cm4gbWFwTm9kZShcbiAgICAgIGlubmVyLFxuICAgICAgc2NvcGUsXG4gICAgICAoaW5uZXIyKSA9PiBpbm5lcjIudHlwZSA9PT0gXCJhcnJheVwiID8gaW5uZXIyIDogeyB0eXBlOiBcImFycmF5XCIsIG9mOiBpbm5lcjIgfSxcbiAgICAgIChub2RlcykgPT4ge1xuICAgICAgICBjb25zdCBpbm5lcjIgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlMiBvZiBub2Rlcykge1xuICAgICAgICAgIGlmIChub2RlMi50eXBlID09PSBcInVua25vd25cIikgcmV0dXJuIHsgdHlwZTogXCJhcnJheVwiLCBvZjogbm9kZTIgfTtcbiAgICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJhcnJheVwiKSB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdHlwZTogJHtub2RlMi50eXBlfWApO1xuICAgICAgICAgIGlubmVyMi5wdXNoKG5vZGUyLm9mKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICBvZjogb3B0aW1pemVVbmlvbnMoeyB0eXBlOiBcInVuaW9uXCIsIG9mOiBpbm5lcjIgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU1hcChub2RlLCBzY29wZSkge1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIHJldHVybiAkdHJhY2UoXCJtYXAuYmFzZSAlT1wiLCBiYXNlKSwgbWFwQXJyYXkoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4gKHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgb2Y6IHdhbGsoeyBub2RlOiBub2RlLmV4cHIsIHNjb3BlOiBzY29wZS5jcmVhdGVIaWRkZW4oW2Jhc2UyLm9mXSkgfSlcbiAgfSkpO1xufVxuZnVuY3Rpb24gaGFuZGxlUHJvamVjdGlvbk5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gJHRyYWNlKFwicHJvamVjdGlvbi5iYXNlICVPXCIsIGJhc2UpLCBtYXBPYmplY3QoXG4gICAgYmFzZSxcbiAgICBzY29wZSxcbiAgICAoYmFzZTIpID0+IHdhbGsoeyBub2RlOiBub2RlLmV4cHIsIHNjb3BlOiBzY29wZS5jcmVhdGVOZXN0ZWQoW2Jhc2UyXSkgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpbHRlclNjb3BlKGJhc2UsIHNjb3BlKSB7XG4gIHJldHVybiBiYXNlLnR5cGUgPT09IFwiYXJyYXlcIiA/IGJhc2Uub2YudHlwZSA9PT0gXCJ1bmlvblwiID8gc2NvcGUuY3JlYXRlTmVzdGVkKGJhc2Uub2Yub2YpIDogc2NvcGUuY3JlYXRlTmVzdGVkKFtiYXNlLm9mXSkgOiBzY29wZS5jcmVhdGVOZXN0ZWQoW2Jhc2VdKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUZpbHRlck5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gJHRyYWNlKFwiZmlsdGVyLmJhc2UgJU9cIiwgYmFzZSksIG1hcE5vZGUoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4ge1xuICAgIGlmICgkdHJhY2UoXCJmaWx0ZXIucmVzb2x2aW5nICVPXCIsIGJhc2UyKSwgYmFzZTIudHlwZSA9PT0gXCJudWxsXCIpXG4gICAgICByZXR1cm4gYmFzZTI7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlRmlsdGVyKG5vZGUuZXhwciwgY3JlYXRlRmlsdGVyU2NvcGUoYmFzZTIsIHNjb3BlKSk7XG4gICAgcmV0dXJuICR0cmFjZShcImZpbHRlci5yZXNvbHZlZCAlT1wiLCByZXNvbHZlZCksIHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIG9mOiByZXNvbHZlZFxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlQWNjZXNzQXR0cmlidXRlTm9kZShub2RlLCBzY29wZSkge1xuICBsZXQgYXR0cmlidXRlQmFzZSA9IHNjb3BlLnZhbHVlO1xuICByZXR1cm4gbm9kZS5iYXNlICYmIChhdHRyaWJ1dGVCYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSkpLCAkdHJhY2UoXCJhY2Nlc3NBdHRyaWJ1dGUuYmFzZSAlcyAlT1wiLCBub2RlLm5hbWUsIGF0dHJpYnV0ZUJhc2UpLCBoYW5kbGVBY2Nlc3NBdHRyaWJ1dGVCYXNlKGF0dHJpYnV0ZUJhc2UsIG5vZGUubmFtZSwgc2NvcGUpO1xufVxuZnVuY3Rpb24gaGFuZGxlQWNjZXNzQXR0cmlidXRlQmFzZShiYXNlLCBuYW1lLCBzY29wZSkge1xuICByZXR1cm4gbWFwT2JqZWN0KGJhc2UsIHNjb3BlLCAoYmFzZTIpID0+IHtcbiAgICAkdHJhY2UoJ0xvb2tpbmcgZm9yIGF0dHJpYnV0ZSBcIiVzXCIgaW4gb2JqZWN0ICVPJywgbmFtZSwgYmFzZTIpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGJhc2UyLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgcmV0dXJuIGF0dHJpYnV0ZSAhPT0gdm9pZCAwID8gKCRkZWJ1ZyhgYWNjZXNzQXR0cmlidXRlLmF0dHJpYnV0ZSBmb3VuZCAke25hbWV9ICVPYCwgYXR0cmlidXRlKSwgYXR0cmlidXRlLm9wdGlvbmFsID8gbnVsbFVuaW9uKGF0dHJpYnV0ZS52YWx1ZSkgOiBhdHRyaWJ1dGUudmFsdWUpIDogYmFzZTIucmVzdCA/IGhhbmRsZUFjY2Vzc0F0dHJpYnV0ZUJhc2UoYmFzZTIucmVzdCwgbmFtZSwgc2NvcGUpIDogKCR3YXJuKGBhdHRyaWJ1dGUgXCIke25hbWV9XCIgbm90IGZvdW5kIGluIG9iamVjdGApLCB7IHR5cGU6IFwibnVsbFwiIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFjY2Vzc0VsZW1lbnROb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IGJhc2UgPSB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KTtcbiAgcmV0dXJuICR0cmFjZShcImFjY2Vzc0VsZW1lbnQuYmFzZSAlT1wiLCBiYXNlKSwgbWFwQXJyYXkoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4gbnVsbFVuaW9uKGJhc2UyLm9mKSk7XG59XG5mdW5jdGlvbiBoYW5kbGVBcnJheU5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3Qgb2YgPSBbXTtcbiAgZm9yIChjb25zdCBlbCBvZiBub2RlLmVsZW1lbnRzKSB7XG4gICAgY29uc3Qgbm9kZTIgPSB3YWxrKHsgbm9kZTogZWwudmFsdWUsIHNjb3BlIH0pO1xuICAgIGlmIChlbC5pc1NwbGF0KSB7XG4gICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJhcnJheVwiKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIG9mLnB1c2gobm9kZTIub2YpO1xuICAgIH0gZWxzZVxuICAgICAgb2YucHVzaChub2RlMik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgb2Y6IHtcbiAgICAgIHR5cGU6IFwidW5pb25cIixcbiAgICAgIG9mXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlVmFsdWVOb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGlmIChub2RlLnZhbHVlID09PSBudWxsKVxuICAgIHJldHVybiB7IHR5cGU6IFwibnVsbFwiIH07XG4gIHN3aXRjaCAodHlwZW9mIG5vZGUudmFsdWUpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICB2YWx1ZTogbm9kZS52YWx1ZVxuICAgICAgfTtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICB2YWx1ZTogbm9kZS52YWx1ZVxuICAgICAgfTtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgIHZhbHVlOiBub2RlLnZhbHVlXG4gICAgICB9O1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHJldHVybiBub2RlLnZhbHVlID09PSBudWxsID8geyB0eXBlOiBcIm51bGxcIiB9IDogQXJyYXkuaXNBcnJheShub2RlLnZhbHVlKSA/IHtcbiAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICBvZjoge1xuICAgICAgICAgIHR5cGU6IFwidW5pb25cIixcbiAgICAgICAgICBvZjogbm9kZS52YWx1ZS5tYXAoKHZhbHVlKSA9PiB3YWxrKHsgbm9kZTogeyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlIH0sIHNjb3BlIH0pKVxuICAgICAgICB9XG4gICAgICB9IDoge1xuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMobm9kZS52YWx1ZSkubWFwKChba2V5LCB2YWx1ZV0pID0+IFtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RBdHRyaWJ1dGVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IHdhbGsoeyBub2RlOiB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWUgfSwgc2NvcGUgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdKVxuICAgICAgICApXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVTbGljZShub2RlLCBzY29wZSkge1xuICAkdHJhY2UoXCJzbGljZS5ub2RlICVPXCIsIG5vZGUpO1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIHJldHVybiBtYXBBcnJheShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiBiYXNlMik7XG59XG5mdW5jdGlvbiBoYW5kbGVQYXJlbnROb2RlKHsgbiB9LCBzY29wZSkge1xuICAkdHJhY2UoXCJoYW5kbGUucGFyZW50LmN1cnJlbnRTY29wZSAlZCAlT1wiLCBuLCBzY29wZSk7XG4gIGxldCBjdXJyZW50ID0gc2NvcGU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgZm9yICg7IGN1cnJlbnQ/LmlzSGlkZGVuOyApXG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgY3VycmVudCA9IGN1cnJlbnQ/LnBhcmVudDtcbiAgfVxuICByZXR1cm4gJHRyYWNlKFwiaGFuZGxlLnBhcmVudC5uZXdTY29wZSAlZCAlT1wiLCBuLCBjdXJyZW50KSwgY3VycmVudCA/IGN1cnJlbnQudmFsdWUub2YubGVuZ3RoID09PSAwID8geyB0eXBlOiBcIm51bGxcIiB9IDogY3VycmVudC52YWx1ZSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5vdE5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gbWFwTm9kZShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiBiYXNlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiIH0pIDogYmFzZTIudHlwZSA9PT0gXCJib29sZWFuXCIgPyBiYXNlMi52YWx1ZSAhPT0gdm9pZCAwID8geyB0eXBlOiBcImJvb2xlYW5cIiwgdmFsdWU6IGJhc2UyLnZhbHVlID09PSAhMSB9IDogeyB0eXBlOiBcImJvb2xlYW5cIiB9IDogeyB0eXBlOiBcIm51bGxcIiB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5lZ05vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gbWFwTm9kZShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiBiYXNlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBiYXNlMi50eXBlICE9PSBcIm51bWJlclwiID8geyB0eXBlOiBcIm51bGxcIiB9IDogYmFzZTIudmFsdWUgIT09IHZvaWQgMCA/IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsdWU6IC1iYXNlMi52YWx1ZSB9IDogYmFzZTIpO1xufVxuZnVuY3Rpb24gaGFuZGxlUG9zTm9kZShub2RlLCBzY29wZSkge1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIHJldHVybiBtYXBOb2RlKGJhc2UsIHNjb3BlLCAoYmFzZTIpID0+IGJhc2UyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IGJhc2UyLnR5cGUgIT09IFwibnVtYmVyXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBiYXNlMik7XG59XG5mdW5jdGlvbiBoYW5kbGVFdmVyeXRoaW5nTm9kZShfLCBzY29wZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBvZjoge1xuICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgb2Y6IHNjb3BlLmNvbnRleHQuc2NoZW1hLmZpbHRlcigob2JqKSA9PiBvYmoudHlwZSA9PT0gXCJkb2N1bWVudFwiKS5tYXAoKGRvYykgPT4gKHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgYXR0cmlidXRlczogZG9jLmF0dHJpYnV0ZXNcbiAgICAgIH0pKVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFuZE5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgbGVmdCA9IHdhbGsoeyBub2RlOiBub2RlLmxlZnQsIHNjb3BlIH0pLCByaWdodCA9IHdhbGsoeyBub2RlOiBub2RlLnJpZ2h0LCBzY29wZSB9KTtcbiAgcmV0dXJuIG1hcE5vZGUoXG4gICAgbGVmdCxcbiAgICBzY29wZSxcbiAgICAobGhzKSA9PiBtYXBOb2RlKHJpZ2h0LCBzY29wZSwgKHJocykgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBib29sZWFuQW5kKGJvb2xlYW5WYWx1ZShsaHMsIHNjb3BlKSwgYm9vbGVhblZhbHVlKHJocywgc2NvcGUpKTtcbiAgICAgIHJldHVybiBib29sZWFuSW50ZXJwcmV0YXRpb25Ub1R5cGVOb2RlKHZhbHVlKTtcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gaGFuZGxlT3JOb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IGxlZnQgPSB3YWxrKHsgbm9kZTogbm9kZS5sZWZ0LCBzY29wZSB9KSwgcmlnaHQgPSB3YWxrKHsgbm9kZTogbm9kZS5yaWdodCwgc2NvcGUgfSk7XG4gIHJldHVybiBtYXBOb2RlKFxuICAgIGxlZnQsXG4gICAgc2NvcGUsXG4gICAgKGxocykgPT4gbWFwTm9kZShyaWdodCwgc2NvcGUsIChyaHMpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYm9vbGVhbk9yKGJvb2xlYW5WYWx1ZShsaHMsIHNjb3BlKSwgYm9vbGVhblZhbHVlKHJocywgc2NvcGUpKTtcbiAgICAgIHJldHVybiBib29sZWFuSW50ZXJwcmV0YXRpb25Ub1R5cGVOb2RlKHZhbHVlKTtcbiAgICB9KVxuICApO1xufVxuY29uc3QgT1ZFUlJJREVfVFlQRV9TWU1CT0wgPSBTeW1ib2woXCJncm9xLWpzLnR5cGVcIik7XG5mdW5jdGlvbiB3YWxrKHsgbm9kZSwgc2NvcGUgfSkge1xuICBpZiAoT1ZFUlJJREVfVFlQRV9TWU1CT0wgaW4gbm9kZSlcbiAgICByZXR1cm4gbm9kZVtPVkVSUklERV9UWVBFX1NZTUJPTF07XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgLy8gRmlsdGVyaW5nLCB0cmF2ZXJzYWwgJiBwcm9qZWN0aW9uc1xuICAgIGNhc2UgXCJNYXBcIjpcbiAgICAgIHJldHVybiBoYW5kbGVNYXAobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJQcm9qZWN0aW9uXCI6XG4gICAgICByZXR1cm4gaGFuZGxlUHJvamVjdGlvbk5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJGaWx0ZXJcIjpcbiAgICAgIHJldHVybiBoYW5kbGVGaWx0ZXJOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiQWNjZXNzQXR0cmlidXRlXCI6XG4gICAgICByZXR1cm4gb3B0aW1pemVVbmlvbnMoaGFuZGxlQWNjZXNzQXR0cmlidXRlTm9kZShub2RlLCBzY29wZSkpO1xuICAgIGNhc2UgXCJBY2Nlc3NFbGVtZW50XCI6XG4gICAgICByZXR1cm4gaGFuZGxlQWNjZXNzRWxlbWVudE5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJBcnJheUNvZXJjZVwiOlxuICAgICAgcmV0dXJuIGhhbmRsZUFycmF5Q29lcmNlTm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIkZsYXRNYXBcIjpcbiAgICAgIHJldHVybiBoYW5kbGVGbGF0TWFwKG5vZGUsIHNjb3BlKTtcbiAgICAvLyBPcGVyYXRpb25zXG4gICAgY2FzZSBcIk9wQ2FsbFwiOlxuICAgICAgcmV0dXJuIGhhbmRsZU9wQ2FsbE5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJBbmRcIjpcbiAgICAgIHJldHVybiBoYW5kbGVBbmROb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiT3JcIjpcbiAgICAgIHJldHVybiBoYW5kbGVPck5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJTZWxlY3RcIjpcbiAgICAgIHJldHVybiBoYW5kbGVTZWxlY3ROb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiUGlwZUZ1bmNDYWxsXCI6XG4gICAgICByZXR1cm4gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gICAgLy8gVmFsdWVzXG4gICAgY2FzZSBcIkRlcmVmXCI6XG4gICAgICByZXR1cm4gaGFuZGxlRGVyZWZOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiT2JqZWN0XCI6XG4gICAgICByZXR1cm4gaGFuZGxlT2JqZWN0Tm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIlZhbHVlXCI6XG4gICAgICByZXR1cm4gaGFuZGxlVmFsdWVOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgIHJldHVybiBoYW5kbGVBcnJheU5vZGUobm9kZSwgc2NvcGUpO1xuICAgIC8vIFNwZWNpYWwgY2FzZXNcbiAgICBjYXNlIFwiRXZlcnl0aGluZ1wiOlxuICAgICAgcmV0dXJuIGhhbmRsZUV2ZXJ5dGhpbmdOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiVGhpc1wiOlxuICAgICAgcmV0dXJuICR0cmFjZShcInRoaXMgJU9cIiwgc2NvcGUudmFsdWUpLCBzY29wZS52YWx1ZTtcbiAgICBjYXNlIFwiUGFyZW50XCI6XG4gICAgICByZXR1cm4gaGFuZGxlUGFyZW50Tm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIkZ1bmNDYWxsXCI6XG4gICAgICByZXR1cm4gaGFuZGxlRnVuY0NhbGxOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiR3JvdXBcIjpcbiAgICAgIHJldHVybiB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KTtcbiAgICBjYXNlIFwiTm90XCI6XG4gICAgICByZXR1cm4gaGFuZGxlTm90Tm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIlBhcmFtZXRlclwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ1bmtub3duXCJcbiAgICAgIH07XG4gICAgY2FzZSBcIlNsaWNlXCI6XG4gICAgICByZXR1cm4gaGFuZGxlU2xpY2Uobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJOZWdcIjpcbiAgICAgIHJldHVybiBoYW5kbGVOZWdOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiUG9zXCI6XG4gICAgICByZXR1cm4gaGFuZGxlUG9zTm9kZShub2RlLCBzY29wZSk7XG4gICAgLy8gZXZlcnl0aGluZyBlbHNlXG4gICAgY2FzZSBcIkFzY1wiOlxuICAgIGNhc2UgXCJEZXNjXCI6XG4gICAgY2FzZSBcIkNvbnRleHRcIjpcbiAgICBjYXNlIFwiVHVwbGVcIjpcbiAgICBjYXNlIFwiU2VsZWN0b3JGdW5jQ2FsbFwiOlxuICAgIGNhc2UgXCJTZWxlY3Rvck5lc3RlZFwiOlxuICAgIGNhc2UgXCJJblJhbmdlXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gbm9kZSB0eXBlICR7bm9kZS50eXBlfWApO1xuICB9XG59XG5mdW5jdGlvbiBpc1ByaW1pdGl2ZVR5cGVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBub2RlLnR5cGUgPT09IFwibnVtYmVyXCIgfHwgbm9kZS50eXBlID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlQ29tcGFyaXNvbihvcGNhbGwsIGxlZnQsIHJpZ2h0KSB7XG4gIGlmICghKGxlZnQudmFsdWUgPT09IHZvaWQgMCB8fCByaWdodC52YWx1ZSA9PT0gdm9pZCAwKSlcbiAgICBzd2l0Y2ggKG9wY2FsbCkge1xuICAgICAgY2FzZSBcIj09XCI6XG4gICAgICAgIHJldHVybiBsZWZ0LnZhbHVlID09PSByaWdodC52YWx1ZTtcbiAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgIHJldHVybiBsZWZ0LnZhbHVlIDwgcmlnaHQudmFsdWU7XG4gICAgICBjYXNlIFwiPD1cIjpcbiAgICAgICAgcmV0dXJuIGxlZnQudmFsdWUgPD0gcmlnaHQudmFsdWU7XG4gICAgICBjYXNlIFwiPlwiOlxuICAgICAgICByZXR1cm4gbGVmdC52YWx1ZSA+IHJpZ2h0LnZhbHVlO1xuICAgICAgY2FzZSBcIj49XCI6XG4gICAgICAgIHJldHVybiBsZWZ0LnZhbHVlID49IHJpZ2h0LnZhbHVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIGNvbXBhcmlzb24gb3BlcmF0b3IgJHtvcGNhbGx9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlcihleHByLCBzY29wZSkge1xuICAkdHJhY2UoXCJyZXNvbHZlRmlsdGVyLmV4cHIgJU9cIiwgZXhwcik7XG4gIGNvbnN0IGZpbHRlcmVkID0gc2NvcGUudmFsdWUub2YuZmlsdGVyKChub2RlKSA9PiB7XG4gICAgY29uc3Qgc3ViU2NvcGUgPSBzY29wZS5jcmVhdGVIaWRkZW4oW25vZGVdKSwgY29uZCA9IHdhbGsoeyBub2RlOiBleHByLCBzY29wZTogc3ViU2NvcGUgfSk7XG4gICAgcmV0dXJuIGJvb2xlYW5WYWx1ZShjb25kLCBzdWJTY29wZSkuY2FuQmVUcnVlO1xuICB9KTtcbiAgcmV0dXJuICR0cmFjZShcbiAgICBgcmVzb2x2ZUZpbHRlciAke2V4cHIudHlwZSA9PT0gXCJPcENhbGxcIiA/IGAke2V4cHIudHlwZX0vJHtleHByLm9wfWAgOiBleHByLnR5cGV9ICVPYCxcbiAgICBmaWx0ZXJlZFxuICApLCB7IHR5cGU6IFwidW5pb25cIiwgb2Y6IGZpbHRlcmVkIH07XG59XG5mdW5jdGlvbiBtYXBBcnJheShub2RlLCBzY29wZSwgbWFwcGVyKSB7XG4gIHJldHVybiBtYXBOb2RlKG5vZGUsIHNjb3BlLCAoYmFzZSkgPT4gYmFzZS50eXBlID09PSBcInVua25vd25cIiA/IGJhc2UgOiBiYXNlLnR5cGUgPT09IFwiYXJyYXlcIiA/IG1hcHBlcihiYXNlKSA6IHsgdHlwZTogXCJudWxsXCIgfSk7XG59XG5mdW5jdGlvbiBtYXBPYmplY3Qobm9kZSwgc2NvcGUsIG1hcHBlcikge1xuICByZXR1cm4gbWFwTm9kZShub2RlLCBzY29wZSwgKGJhc2UpID0+IGJhc2UudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBiYXNlIDogYmFzZS50eXBlID09PSBcIm9iamVjdFwiID8gbWFwcGVyKGJhc2UpIDogeyB0eXBlOiBcIm51bGxcIiB9KTtcbn1cbmV4cG9ydCB7XG4gIERhdGVUaW1lLFxuICBQYXRoLFxuICBjcmVhdGVSZWZlcmVuY2VUeXBlTm9kZSxcbiAgZXZhbHVhdGVRdWVyeSBhcyBldmFsdWF0ZSxcbiAgZXZhbHVhdGVRdWVyeVN5bmMgYXMgZXZhbHVhdGVTeW5jLFxuICBpc1NlbGVjdG9yTmVzdGVkLFxuICBpc1NlbGVjdG9yTm9kZSxcbiAgcGFyc2UsXG4gIHRvSlMsXG4gIHR5cGVFdmFsdWF0ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPTEubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/groq-js/dist/1.mjs\n");

/***/ })

};
;