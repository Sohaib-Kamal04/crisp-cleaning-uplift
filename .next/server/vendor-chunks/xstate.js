"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/xstate";
exports.ids = ["vendor-chunks/xstate"];
exports.modules = {

/***/ "(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/xstate/actors/dist/xstate-actors.development.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEmptyActor: () => (/* binding */ createEmptyActor),\n/* harmony export */   fromCallback: () => (/* binding */ fromCallback),\n/* harmony export */   fromEventObservable: () => (/* binding */ fromEventObservable),\n/* harmony export */   fromObservable: () => (/* binding */ fromObservable),\n/* harmony export */   fromPromise: () => (/* binding */ fromPromise),\n/* harmony export */   fromTransition: () => (/* binding */ fromTransition)\n/* harmony export */ });\n/* harmony import */ var _dist_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/raise-235fa0c7.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-235fa0c7.development.esm.js\");\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dev/dist/xstate-dev.development.esm.js */ \"(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\n\n\n/**\n * Represents an actor created by `fromTransition`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromTransition,\n *   createActor,\n *   type AnyActorSystem\n * } from 'xstate';\n *\n * //* The actor's stored context.\n * type Context = {\n *   // The current count.\n *   count: number;\n *   // The amount to increase `count` by.\n *   step: number;\n * };\n * // The events the actor receives.\n * type Event = { type: 'increment' };\n * // The actor's input.\n * type Input = { step?: number };\n *\n * // Actor logic that increments `count` by `step` when it receives an event of\n * // type `increment`.\n * const logic = fromTransition<Context, Event, AnyActorSystem, Input>(\n *   (state, event, actorScope) => {\n *     actorScope.self;\n *     //         ^? TransitionActorRef<Context, Event>\n *\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + state.step\n *       };\n *     }\n *     return state;\n *   },\n *   ({ input, self }) => {\n *     self;\n *     // ^? TransitionActorRef<Context, Event>\n *\n *     return {\n *       count: 0,\n *       step: input.step ?? 1\n *     };\n *   }\n * );\n *\n * const actor = createActor(logic, { input: { step: 10 } });\n * //    ^? TransitionActorRef<Context, Event>\n * ```\n *\n * @see {@link fromTransition}\n */\n\n/**\n * Returns actor logic given a transition function and its initial state.\n *\n * A “transition function” is a function that takes the current `state` and\n * received `event` object as arguments, and returns the next state, similar to\n * a reducer.\n *\n * Actors created from transition logic (“transition actors”) can:\n *\n * - Receive events\n * - Emit snapshots of its state\n *\n * The transition function’s `state` is used as its transition actor’s\n * `context`.\n *\n * Note that the \"state\" for a transition function is provided by the initial\n * state argument, and is not the same as the State object of an actor or a\n * state within a machine configuration.\n *\n * @example\n *\n * ```ts\n * const transitionLogic = fromTransition(\n *   (state, event) => {\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + 1\n *       };\n *     }\n *     return state;\n *   },\n *   { count: 0 }\n * );\n *\n * const transitionActor = createActor(transitionLogic);\n * transitionActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * transitionActor.start();\n * // => {\n * //   status: 'active',\n * //   context: { count: 0 },\n * //   ...\n * // }\n *\n * transitionActor.send({ type: 'increment' });\n * // => {\n * //   status: 'active',\n * //   context: { count: 1 },\n * //   ...\n * // }\n * ```\n *\n * @param transition The transition function used to describe the transition\n *   logic. It should return the next state given the current state and event.\n *   It receives the following arguments:\n *\n *   - `state` - the current state.\n *   - `event` - the received event.\n *   - `actorScope` - the actor scope object, with properties like `self` and\n *       `system`.\n *\n * @param initialContext The initial state of the transition function, either an\n *   object representing the state, or a function which returns a state object.\n *   If a function, it will receive as its only argument an object with the\n *   following properties:\n *\n *   - `input` - the `input` provided to its parent transition actor.\n *   - `self` - a reference to its parent transition actor.\n *\n * @returns Actor logic\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nfunction fromTransition(transition, initialContext) {\n  return {\n    config: transition,\n    transition: (snapshot, event, actorScope) => {\n      return {\n        ...snapshot,\n        context: transition(snapshot.context, event, actorScope)\n      };\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: typeof initialContext === 'function' ? initialContext({\n          input\n        }) : initialContext\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n}\n\nconst instanceStates = /* #__PURE__ */new WeakMap();\n\n/**\n * Represents an actor created by `fromCallback`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromCallback, createActor } from 'xstate';\n *\n * // The events the actor receives.\n * type Event = { type: 'someEvent' };\n * // The actor's input.\n * type Input = { name: string };\n *\n * // Actor logic that logs whenever it receives an event of type `someEvent`.\n * const logic = fromCallback<Event, Input>(({ self, input, receive }) => {\n *   self;\n *   // ^? CallbackActorRef<Event, Input>\n *\n *   receive((event) => {\n *     if (event.type === 'someEvent') {\n *       console.log(`${input.name}: received \"someEvent\" event`);\n *       // logs 'myActor: received \"someEvent\" event'\n *     }\n *   });\n * });\n *\n * const actor = createActor(logic, { input: { name: 'myActor' } });\n * //    ^? CallbackActorRef<Event, Input>\n * ```\n *\n * @see {@link fromCallback}\n */\n\n/**\n * An actor logic creator which returns callback logic as defined by a callback\n * function.\n *\n * @remarks\n * Useful for subscription-based or other free-form logic that can send events\n * back to the parent actor.\n *\n * Actors created from callback logic (“callback actors”) can:\n *\n * - Receive events via the `receive` function\n * - Send events to the parent actor via the `sendBack` function\n *\n * Callback actors are a bit different from other actors in that they:\n *\n * - Do not work with `onDone`\n * - Do not produce a snapshot using `.getSnapshot()`\n * - Do not emit values when used with `.subscribe()`\n * - Can not be stopped with `.stop()`\n *\n * @example\n *\n * ```typescript\n * const callbackLogic = fromCallback(({ sendBack, receive }) => {\n *   let lockStatus = 'unlocked';\n *\n *   const handler = (event) => {\n *     if (lockStatus === 'locked') {\n *       return;\n *     }\n *     sendBack(event);\n *   };\n *\n *   receive((event) => {\n *     if (event.type === 'lock') {\n *       lockStatus = 'locked';\n *     } else if (event.type === 'unlock') {\n *       lockStatus = 'unlocked';\n *     }\n *   });\n *\n *   document.body.addEventListener('click', handler);\n *\n *   return () => {\n *     document.body.removeEventListener('click', handler);\n *   };\n * });\n * ```\n *\n * @param callback - The callback function used to describe the callback logic\n *   The callback function is passed an object with the following properties:\n *\n *   - `receive` - A function that can send events back to the parent actor; the\n *       listener is then called whenever events are received by the callback\n *       actor\n *   - `sendBack` - A function that can send events back to the parent actor\n *   - `input` - Data that was provided to the callback actor\n *   - `self` - The parent actor of the callback actor\n *   - `system` - The actor system to which the callback actor belongs The callback\n *       function can (optionally) return a cleanup function, which is called\n *       when the actor is stopped.\n *\n * @returns Callback logic\n * @see {@link CallbackLogicFunction} for more information about the callback function and its object argument\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nfunction fromCallback(callback) {\n  const logic = {\n    config: callback,\n    start: (state, actorScope) => {\n      const {\n        self,\n        system,\n        emit\n      } = actorScope;\n      const callbackState = {\n        receivers: undefined,\n        dispose: undefined\n      };\n      instanceStates.set(self, callbackState);\n      callbackState.dispose = callback({\n        input: state.input,\n        system,\n        self,\n        sendBack: event => {\n          if (self.getSnapshot().status === 'stopped') {\n            return;\n          }\n          if (self._parent) {\n            system._relay(self, self._parent, event);\n          }\n        },\n        receive: listener => {\n          callbackState.receivers ??= new Set();\n          callbackState.receivers.add(listener);\n        },\n        emit\n      });\n    },\n    transition: (state, event, actorScope) => {\n      const callbackState = instanceStates.get(actorScope.self);\n      if (event.type === _dist_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X) {\n        state = {\n          ...state,\n          status: 'stopped',\n          error: undefined\n        };\n        callbackState.dispose?.();\n        return state;\n      }\n      callbackState.receivers?.forEach(receiver => receiver(event));\n      return state;\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n  return logic;\n}\n\nconst XSTATE_OBSERVABLE_NEXT = 'xstate.observable.next';\nconst XSTATE_OBSERVABLE_ERROR = 'xstate.observable.error';\nconst XSTATE_OBSERVABLE_COMPLETE = 'xstate.observable.complete';\n\n/**\n * Represents an actor created by `fromObservable` or `fromEventObservable`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * // The type of the value observed by the actor's logic.\n * type Context = number;\n * // The actor's input.\n * type Input = { period?: number };\n *\n * // Actor logic that observes a number incremented every `input.period`\n * // milliseconds (default: 1_000).\n * const logic = fromObservable<Context, Input>(({ input, self }) => {\n *   self;\n *   // ^? ObservableActorRef<Event, Input>\n *\n *   return interval(input.period ?? 1_000);\n * });\n *\n * const actor = createActor(logic, { input: { period: 2_000 } });\n * //    ^? ObservableActorRef<Event, Input>\n * ```\n *\n * @see {@link fromObservable}\n * @see {@link fromEventObservable}\n */\n\n/**\n * Observable actor logic is described by an observable stream of values. Actors\n * created from observable logic (“observable actors”) can:\n *\n * - Emit snapshots of the observable’s emitted value\n *\n * The observable’s emitted value is used as its observable actor’s `context`.\n *\n * Sending events to observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * const logic = fromObservable((obj) => interval(1000));\n *\n * const actor = createActor(logic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot.context);\n * });\n *\n * actor.start();\n * // At every second:\n * // Logs 0\n * // Logs 1\n * // Logs 2\n * // ...\n * ```\n *\n * @param observableCreator A function that creates an observable. It receives\n *   one argument, an object with the following properties:\n *\n *   - `input` - Data that was provided to the observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the observable actor belongs\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n * @see {@link https://rxjs.dev} for documentation on RxJS Observable and observable creators.\n * @see {@link Subscribable} interface in XState, which is based on and compatible with RxJS Observable.\n */\nfunction fromObservable(observableCreator) {\n  // TODO: add event types\n  const logic = {\n    config: observableCreator,\n    transition: (snapshot, event) => {\n      if (snapshot.status !== 'active') {\n        return snapshot;\n      }\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_NEXT:\n          {\n            const newSnapshot = {\n              ...snapshot,\n              context: event.data\n            };\n            return newSnapshot;\n          }\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...snapshot,\n            status: 'error',\n            error: event.data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...snapshot,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case _dist_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n          snapshot._subscription.unsubscribe();\n          return {\n            ...snapshot,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return snapshot;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, {\n      self,\n      system,\n      emit\n    }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = observableCreator({\n        input: state.input,\n        system,\n        self,\n        emit\n      }).subscribe({\n        next: value => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_NEXT,\n            data: value\n          });\n        },\n        error: err => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_COMPLETE\n          });\n        }\n      });\n    },\n    getPersistedSnapshot: ({\n      _subscription,\n      ...state\n    }) => state,\n    restoreSnapshot: state => ({\n      ...state,\n      _subscription: undefined\n    })\n  };\n  return logic;\n}\n\n/**\n * Creates event observable logic that listens to an observable that delivers\n * event objects.\n *\n * Event observable actor logic is described by an observable stream of\n * {@link https://stately.ai/docs/transitions#event-objects | event objects}.\n * Actors created from event observable logic (“event observable actors”) can:\n *\n * - Implicitly send events to its parent actor\n * - Emit snapshots of its emitted event objects\n *\n * Sending events to event observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromEventObservable,\n *   Subscribable,\n *   EventObject,\n *   createMachine,\n *   createActor\n * } from 'xstate';\n * import { fromEvent } from 'rxjs';\n *\n * const mouseClickLogic = fromEventObservable(\n *   () => fromEvent(document.body, 'click') as Subscribable<EventObject>\n * );\n *\n * const canvasMachine = createMachine({\n *   invoke: {\n *     // Will send mouse `click` events to the canvas actor\n *     src: mouseClickLogic\n *   }\n * });\n *\n * const canvasActor = createActor(canvasMachine);\n * canvasActor.start();\n * ```\n *\n * @param lazyObservable A function that creates an observable that delivers\n *   event objects. It receives one argument, an object with the following\n *   properties:\n *\n *   - `input` - Data that was provided to the event observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the event observable actor belongs.\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n */\nfunction fromEventObservable(lazyObservable) {\n  // TODO: event types\n  const logic = {\n    config: lazyObservable,\n    transition: (state, event) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...state,\n            status: 'error',\n            error: event.data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...state,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case _dist_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n          state._subscription.unsubscribe();\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return state;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, {\n      self,\n      system,\n      emit\n    }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = lazyObservable({\n        input: state.input,\n        system,\n        self,\n        emit\n      }).subscribe({\n        next: value => {\n          if (self._parent) {\n            system._relay(self, self._parent, value);\n          }\n        },\n        error: err => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_COMPLETE\n          });\n        }\n      });\n    },\n    getPersistedSnapshot: ({\n      _subscription,\n      ...snapshot\n    }) => snapshot,\n    restoreSnapshot: snapshot => ({\n      ...snapshot,\n      _subscription: undefined\n    })\n  };\n  return logic;\n}\n\nconst XSTATE_PROMISE_RESOLVE = 'xstate.promise.resolve';\nconst XSTATE_PROMISE_REJECT = 'xstate.promise.reject';\n\n/**\n * Represents an actor created by `fromPromise`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromPromise, createActor } from 'xstate';\n *\n * // The actor's resolved output\n * type Output = string;\n * // The actor's input.\n * type Input = { message: string };\n *\n * // Actor logic that fetches the url of an image of a cat saying `input.message`.\n * const logic = fromPromise<Output, Input>(async ({ input, self }) => {\n *   self;\n *   // ^? PromiseActorRef<Output, Input>\n *\n *   const data = await fetch(\n *     `https://cataas.com/cat/says/${input.message}`\n *   );\n *   const url = await data.json();\n *   return url;\n * });\n *\n * const actor = createActor(logic, { input: { message: 'hello world' } });\n * //    ^? PromiseActorRef<Output, Input>\n * ```\n *\n * @see {@link fromPromise}\n */\n\nconst controllerMap = new WeakMap();\n\n/**\n * An actor logic creator which returns promise logic as defined by an async\n * process that resolves or rejects after some time.\n *\n * Actors created from promise actor logic (“promise actors”) can:\n *\n * - Emit the resolved value of the promise\n * - Output the resolved value of the promise\n *\n * Sending events to promise actors will have no effect.\n *\n * @example\n *\n * ```ts\n * const promiseLogic = fromPromise(async () => {\n *   const result = await fetch('https://example.com/...').then((data) =>\n *     data.json()\n *   );\n *\n *   return result;\n * });\n *\n * const promiseActor = createActor(promiseLogic);\n * promiseActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * promiseActor.start();\n * // => {\n * //   output: undefined,\n * //   status: 'active'\n * //   ...\n * // }\n *\n * // After promise resolves\n * // => {\n * //   output: { ... },\n * //   status: 'done',\n * //   ...\n * // }\n * ```\n *\n * @param promiseCreator A function which returns a Promise, and accepts an\n *   object with the following properties:\n *\n *   - `input` - Data that was provided to the promise actor\n *   - `self` - The parent actor of the promise actor\n *   - `system` - The actor system to which the promise actor belongs\n *\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nfunction fromPromise(promiseCreator) {\n  const logic = {\n    config: promiseCreator,\n    transition: (state, event, scope) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n      switch (event.type) {\n        case XSTATE_PROMISE_RESOLVE:\n          {\n            const resolvedValue = event.data;\n            return {\n              ...state,\n              status: 'done',\n              output: resolvedValue,\n              input: undefined\n            };\n          }\n        case XSTATE_PROMISE_REJECT:\n          return {\n            ...state,\n            status: 'error',\n            error: event.data,\n            input: undefined\n          };\n        case _dist_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n          {\n            controllerMap.get(scope.self)?.abort();\n            return {\n              ...state,\n              status: 'stopped',\n              input: undefined\n            };\n          }\n        default:\n          return state;\n      }\n    },\n    start: (state, {\n      self,\n      system,\n      emit\n    }) => {\n      // TODO: determine how to allow customizing this so that promises\n      // can be restarted if necessary\n      if (state.status !== 'active') {\n        return;\n      }\n      const controller = new AbortController();\n      controllerMap.set(self, controller);\n      const resolvedPromise = Promise.resolve(promiseCreator({\n        input: state.input,\n        system,\n        self,\n        signal: controller.signal,\n        emit\n      }));\n      resolvedPromise.then(response => {\n        if (self.getSnapshot().status !== 'active') {\n          return;\n        }\n        controllerMap.delete(self);\n        system._relay(self, self, {\n          type: XSTATE_PROMISE_RESOLVE,\n          data: response\n        });\n      }, errorData => {\n        if (self.getSnapshot().status !== 'active') {\n          return;\n        }\n        controllerMap.delete(self);\n        system._relay(self, self, {\n          type: XSTATE_PROMISE_REJECT,\n          data: errorData\n        });\n      });\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n  return logic;\n}\n\nconst emptyLogic = fromTransition(_ => undefined, undefined);\nfunction createEmptyActor() {\n  return (0,_dist_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(emptyLogic);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2FjdG9ycy9kaXN0L3hzdGF0ZS1hY3RvcnMuZGV2ZWxvcG1lbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWtHO0FBQzVDOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixRQUFRLGFBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0RBQWtEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsK0NBQStDLHNCQUFzQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQSxzQ0FBc0MsU0FBUyxtQkFBbUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsbUJBQW1CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2QkFBNkI7QUFDdEMsU0FBUyxrREFBa0Q7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlCQUF5QixzRUFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4QkFBOEI7QUFDMUMsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxhQUFhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esc0NBQXNDLFNBQVMsaUJBQWlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhCQUE4QjtBQUMxQyxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0EsU0FBUyx3QkFBd0I7QUFDakMsU0FBUyxvQkFBb0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzRUFBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3RUFBd0U7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzRUFBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxxREFBcUQsYUFBYTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHNDQUFzQyxTQUFTLDBCQUEwQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtEQUFrRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzRUFBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUywwRUFBVztBQUNwQjs7QUFFNEciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmlzcC1jbGVhbmluZy8uL25vZGVfbW9kdWxlcy94c3RhdGUvYWN0b3JzL2Rpc3QveHN0YXRlLWFjdG9ycy5kZXZlbG9wbWVudC5lc20uanM/OWExYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBYIGFzIFhTVEFURV9TVE9QLCBjIGFzIGNyZWF0ZUFjdG9yIH0gZnJvbSAnLi4vLi4vZGlzdC9yYWlzZS0yMzVmYTBjNy5kZXZlbG9wbWVudC5lc20uanMnO1xuaW1wb3J0ICcuLi8uLi9kZXYvZGlzdC94c3RhdGUtZGV2LmRldmVsb3BtZW50LmVzbS5qcyc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBhY3RvciBjcmVhdGVkIGJ5IGBmcm9tVHJhbnNpdGlvbmAuXG4gKlxuICogVGhlIHR5cGUgb2YgYHNlbGZgIHdpdGhpbiB0aGUgYWN0b3IncyBsb2dpYy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge1xuICogICBmcm9tVHJhbnNpdGlvbixcbiAqICAgY3JlYXRlQWN0b3IsXG4gKiAgIHR5cGUgQW55QWN0b3JTeXN0ZW1cbiAqIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiAvLyogVGhlIGFjdG9yJ3Mgc3RvcmVkIGNvbnRleHQuXG4gKiB0eXBlIENvbnRleHQgPSB7XG4gKiAgIC8vIFRoZSBjdXJyZW50IGNvdW50LlxuICogICBjb3VudDogbnVtYmVyO1xuICogICAvLyBUaGUgYW1vdW50IHRvIGluY3JlYXNlIGBjb3VudGAgYnkuXG4gKiAgIHN0ZXA6IG51bWJlcjtcbiAqIH07XG4gKiAvLyBUaGUgZXZlbnRzIHRoZSBhY3RvciByZWNlaXZlcy5cbiAqIHR5cGUgRXZlbnQgPSB7IHR5cGU6ICdpbmNyZW1lbnQnIH07XG4gKiAvLyBUaGUgYWN0b3IncyBpbnB1dC5cbiAqIHR5cGUgSW5wdXQgPSB7IHN0ZXA/OiBudW1iZXIgfTtcbiAqXG4gKiAvLyBBY3RvciBsb2dpYyB0aGF0IGluY3JlbWVudHMgYGNvdW50YCBieSBgc3RlcGAgd2hlbiBpdCByZWNlaXZlcyBhbiBldmVudCBvZlxuICogLy8gdHlwZSBgaW5jcmVtZW50YC5cbiAqIGNvbnN0IGxvZ2ljID0gZnJvbVRyYW5zaXRpb248Q29udGV4dCwgRXZlbnQsIEFueUFjdG9yU3lzdGVtLCBJbnB1dD4oXG4gKiAgIChzdGF0ZSwgZXZlbnQsIGFjdG9yU2NvcGUpID0+IHtcbiAqICAgICBhY3RvclNjb3BlLnNlbGY7XG4gKiAgICAgLy8gICAgICAgICBePyBUcmFuc2l0aW9uQWN0b3JSZWY8Q29udGV4dCwgRXZlbnQ+XG4gKlxuICogICAgIGlmIChldmVudC50eXBlID09PSAnaW5jcmVtZW50Jykge1xuICogICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgLi4uc3RhdGUsXG4gKiAgICAgICAgIGNvdW50OiBzdGF0ZS5jb3VudCArIHN0YXRlLnN0ZXBcbiAqICAgICAgIH07XG4gKiAgICAgfVxuICogICAgIHJldHVybiBzdGF0ZTtcbiAqICAgfSxcbiAqICAgKHsgaW5wdXQsIHNlbGYgfSkgPT4ge1xuICogICAgIHNlbGY7XG4gKiAgICAgLy8gXj8gVHJhbnNpdGlvbkFjdG9yUmVmPENvbnRleHQsIEV2ZW50PlxuICpcbiAqICAgICByZXR1cm4ge1xuICogICAgICAgY291bnQ6IDAsXG4gKiAgICAgICBzdGVwOiBpbnB1dC5zdGVwID8/IDFcbiAqICAgICB9O1xuICogICB9XG4gKiApO1xuICpcbiAqIGNvbnN0IGFjdG9yID0gY3JlYXRlQWN0b3IobG9naWMsIHsgaW5wdXQ6IHsgc3RlcDogMTAgfSB9KTtcbiAqIC8vICAgIF4/IFRyYW5zaXRpb25BY3RvclJlZjxDb250ZXh0LCBFdmVudD5cbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGZyb21UcmFuc2l0aW9ufVxuICovXG5cbi8qKlxuICogUmV0dXJucyBhY3RvciBsb2dpYyBnaXZlbiBhIHRyYW5zaXRpb24gZnVuY3Rpb24gYW5kIGl0cyBpbml0aWFsIHN0YXRlLlxuICpcbiAqIEEg4oCcdHJhbnNpdGlvbiBmdW5jdGlvbuKAnSBpcyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIGN1cnJlbnQgYHN0YXRlYCBhbmRcbiAqIHJlY2VpdmVkIGBldmVudGAgb2JqZWN0IGFzIGFyZ3VtZW50cywgYW5kIHJldHVybnMgdGhlIG5leHQgc3RhdGUsIHNpbWlsYXIgdG9cbiAqIGEgcmVkdWNlci5cbiAqXG4gKiBBY3RvcnMgY3JlYXRlZCBmcm9tIHRyYW5zaXRpb24gbG9naWMgKOKAnHRyYW5zaXRpb24gYWN0b3Jz4oCdKSBjYW46XG4gKlxuICogLSBSZWNlaXZlIGV2ZW50c1xuICogLSBFbWl0IHNuYXBzaG90cyBvZiBpdHMgc3RhdGVcbiAqXG4gKiBUaGUgdHJhbnNpdGlvbiBmdW5jdGlvbuKAmXMgYHN0YXRlYCBpcyB1c2VkIGFzIGl0cyB0cmFuc2l0aW9uIGFjdG9y4oCZc1xuICogYGNvbnRleHRgLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgXCJzdGF0ZVwiIGZvciBhIHRyYW5zaXRpb24gZnVuY3Rpb24gaXMgcHJvdmlkZWQgYnkgdGhlIGluaXRpYWxcbiAqIHN0YXRlIGFyZ3VtZW50LCBhbmQgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBTdGF0ZSBvYmplY3Qgb2YgYW4gYWN0b3Igb3IgYVxuICogc3RhdGUgd2l0aGluIGEgbWFjaGluZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IHRyYW5zaXRpb25Mb2dpYyA9IGZyb21UcmFuc2l0aW9uKFxuICogICAoc3RhdGUsIGV2ZW50KSA9PiB7XG4gKiAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdpbmNyZW1lbnQnKSB7XG4gKiAgICAgICByZXR1cm4ge1xuICogICAgICAgICAuLi5zdGF0ZSxcbiAqICAgICAgICAgY291bnQ6IHN0YXRlLmNvdW50ICsgMVxuICogICAgICAgfTtcbiAqICAgICB9XG4gKiAgICAgcmV0dXJuIHN0YXRlO1xuICogICB9LFxuICogICB7IGNvdW50OiAwIH1cbiAqICk7XG4gKlxuICogY29uc3QgdHJhbnNpdGlvbkFjdG9yID0gY3JlYXRlQWN0b3IodHJhbnNpdGlvbkxvZ2ljKTtcbiAqIHRyYW5zaXRpb25BY3Rvci5zdWJzY3JpYmUoKHNuYXBzaG90KSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKHNuYXBzaG90KTtcbiAqIH0pO1xuICogdHJhbnNpdGlvbkFjdG9yLnN0YXJ0KCk7XG4gKiAvLyA9PiB7XG4gKiAvLyAgIHN0YXR1czogJ2FjdGl2ZScsXG4gKiAvLyAgIGNvbnRleHQ6IHsgY291bnQ6IDAgfSxcbiAqIC8vICAgLi4uXG4gKiAvLyB9XG4gKlxuICogdHJhbnNpdGlvbkFjdG9yLnNlbmQoeyB0eXBlOiAnaW5jcmVtZW50JyB9KTtcbiAqIC8vID0+IHtcbiAqIC8vICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAqIC8vICAgY29udGV4dDogeyBjb3VudDogMSB9LFxuICogLy8gICAuLi5cbiAqIC8vIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0cmFuc2l0aW9uIFRoZSB0cmFuc2l0aW9uIGZ1bmN0aW9uIHVzZWQgdG8gZGVzY3JpYmUgdGhlIHRyYW5zaXRpb25cbiAqICAgbG9naWMuIEl0IHNob3VsZCByZXR1cm4gdGhlIG5leHQgc3RhdGUgZ2l2ZW4gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIGV2ZW50LlxuICogICBJdCByZWNlaXZlcyB0aGUgZm9sbG93aW5nIGFyZ3VtZW50czpcbiAqXG4gKiAgIC0gYHN0YXRlYCAtIHRoZSBjdXJyZW50IHN0YXRlLlxuICogICAtIGBldmVudGAgLSB0aGUgcmVjZWl2ZWQgZXZlbnQuXG4gKiAgIC0gYGFjdG9yU2NvcGVgIC0gdGhlIGFjdG9yIHNjb3BlIG9iamVjdCwgd2l0aCBwcm9wZXJ0aWVzIGxpa2UgYHNlbGZgIGFuZFxuICogICAgICAgYHN5c3RlbWAuXG4gKlxuICogQHBhcmFtIGluaXRpYWxDb250ZXh0IFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSB0cmFuc2l0aW9uIGZ1bmN0aW9uLCBlaXRoZXIgYW5cbiAqICAgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc3RhdGUsIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIHN0YXRlIG9iamVjdC5cbiAqICAgSWYgYSBmdW5jdGlvbiwgaXQgd2lsbCByZWNlaXZlIGFzIGl0cyBvbmx5IGFyZ3VtZW50IGFuIG9iamVjdCB3aXRoIHRoZVxuICogICBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYGlucHV0YCAtIHRoZSBgaW5wdXRgIHByb3ZpZGVkIHRvIGl0cyBwYXJlbnQgdHJhbnNpdGlvbiBhY3Rvci5cbiAqICAgLSBgc2VsZmAgLSBhIHJlZmVyZW5jZSB0byBpdHMgcGFyZW50IHRyYW5zaXRpb24gYWN0b3IuXG4gKlxuICogQHJldHVybnMgQWN0b3IgbG9naWNcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vc3RhdGVseS5haS9kb2NzL2lucHV0IHwgSW5wdXQgZG9jc30gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgaG93IGlucHV0IGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiBmcm9tVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBpbml0aWFsQ29udGV4dCkge1xuICByZXR1cm4ge1xuICAgIGNvbmZpZzogdHJhbnNpdGlvbixcbiAgICB0cmFuc2l0aW9uOiAoc25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgY29udGV4dDogdHJhbnNpdGlvbihzbmFwc2hvdC5jb250ZXh0LCBldmVudCwgYWN0b3JTY29wZSlcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRJbml0aWFsU25hcHNob3Q6IChfLCBpbnB1dCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICAgICAgb3V0cHV0OiB1bmRlZmluZWQsXG4gICAgICAgIGVycm9yOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbnRleHQ6IHR5cGVvZiBpbml0aWFsQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJyA/IGluaXRpYWxDb250ZXh0KHtcbiAgICAgICAgICBpbnB1dFxuICAgICAgICB9KSA6IGluaXRpYWxDb250ZXh0XG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0UGVyc2lzdGVkU25hcHNob3Q6IHNuYXBzaG90ID0+IHNuYXBzaG90LFxuICAgIHJlc3RvcmVTbmFwc2hvdDogc25hcHNob3QgPT4gc25hcHNob3RcbiAgfTtcbn1cblxuY29uc3QgaW5zdGFuY2VTdGF0ZXMgPSAvKiAjX19QVVJFX18gKi9uZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYWN0b3IgY3JlYXRlZCBieSBgZnJvbUNhbGxiYWNrYC5cbiAqXG4gKiBUaGUgdHlwZSBvZiBgc2VsZmAgd2l0aGluIHRoZSBhY3RvcidzIGxvZ2ljLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGZyb21DYWxsYmFjaywgY3JlYXRlQWN0b3IgfSBmcm9tICd4c3RhdGUnO1xuICpcbiAqIC8vIFRoZSBldmVudHMgdGhlIGFjdG9yIHJlY2VpdmVzLlxuICogdHlwZSBFdmVudCA9IHsgdHlwZTogJ3NvbWVFdmVudCcgfTtcbiAqIC8vIFRoZSBhY3RvcidzIGlucHV0LlxuICogdHlwZSBJbnB1dCA9IHsgbmFtZTogc3RyaW5nIH07XG4gKlxuICogLy8gQWN0b3IgbG9naWMgdGhhdCBsb2dzIHdoZW5ldmVyIGl0IHJlY2VpdmVzIGFuIGV2ZW50IG9mIHR5cGUgYHNvbWVFdmVudGAuXG4gKiBjb25zdCBsb2dpYyA9IGZyb21DYWxsYmFjazxFdmVudCwgSW5wdXQ+KCh7IHNlbGYsIGlucHV0LCByZWNlaXZlIH0pID0+IHtcbiAqICAgc2VsZjtcbiAqICAgLy8gXj8gQ2FsbGJhY2tBY3RvclJlZjxFdmVudCwgSW5wdXQ+XG4gKlxuICogICByZWNlaXZlKChldmVudCkgPT4ge1xuICogICAgIGlmIChldmVudC50eXBlID09PSAnc29tZUV2ZW50Jykge1xuICogICAgICAgY29uc29sZS5sb2coYCR7aW5wdXQubmFtZX06IHJlY2VpdmVkIFwic29tZUV2ZW50XCIgZXZlbnRgKTtcbiAqICAgICAgIC8vIGxvZ3MgJ215QWN0b3I6IHJlY2VpdmVkIFwic29tZUV2ZW50XCIgZXZlbnQnXG4gKiAgICAgfVxuICogICB9KTtcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGFjdG9yID0gY3JlYXRlQWN0b3IobG9naWMsIHsgaW5wdXQ6IHsgbmFtZTogJ215QWN0b3InIH0gfSk7XG4gKiAvLyAgICBePyBDYWxsYmFja0FjdG9yUmVmPEV2ZW50LCBJbnB1dD5cbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGZyb21DYWxsYmFja31cbiAqL1xuXG4vKipcbiAqIEFuIGFjdG9yIGxvZ2ljIGNyZWF0b3Igd2hpY2ggcmV0dXJucyBjYWxsYmFjayBsb2dpYyBhcyBkZWZpbmVkIGJ5IGEgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uLlxuICpcbiAqIEByZW1hcmtzXG4gKiBVc2VmdWwgZm9yIHN1YnNjcmlwdGlvbi1iYXNlZCBvciBvdGhlciBmcmVlLWZvcm0gbG9naWMgdGhhdCBjYW4gc2VuZCBldmVudHNcbiAqIGJhY2sgdG8gdGhlIHBhcmVudCBhY3Rvci5cbiAqXG4gKiBBY3RvcnMgY3JlYXRlZCBmcm9tIGNhbGxiYWNrIGxvZ2ljICjigJxjYWxsYmFjayBhY3RvcnPigJ0pIGNhbjpcbiAqXG4gKiAtIFJlY2VpdmUgZXZlbnRzIHZpYSB0aGUgYHJlY2VpdmVgIGZ1bmN0aW9uXG4gKiAtIFNlbmQgZXZlbnRzIHRvIHRoZSBwYXJlbnQgYWN0b3IgdmlhIHRoZSBgc2VuZEJhY2tgIGZ1bmN0aW9uXG4gKlxuICogQ2FsbGJhY2sgYWN0b3JzIGFyZSBhIGJpdCBkaWZmZXJlbnQgZnJvbSBvdGhlciBhY3RvcnMgaW4gdGhhdCB0aGV5OlxuICpcbiAqIC0gRG8gbm90IHdvcmsgd2l0aCBgb25Eb25lYFxuICogLSBEbyBub3QgcHJvZHVjZSBhIHNuYXBzaG90IHVzaW5nIGAuZ2V0U25hcHNob3QoKWBcbiAqIC0gRG8gbm90IGVtaXQgdmFsdWVzIHdoZW4gdXNlZCB3aXRoIGAuc3Vic2NyaWJlKClgXG4gKiAtIENhbiBub3QgYmUgc3RvcHBlZCB3aXRoIGAuc3RvcCgpYFxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgY2FsbGJhY2tMb2dpYyA9IGZyb21DYWxsYmFjaygoeyBzZW5kQmFjaywgcmVjZWl2ZSB9KSA9PiB7XG4gKiAgIGxldCBsb2NrU3RhdHVzID0gJ3VubG9ja2VkJztcbiAqXG4gKiAgIGNvbnN0IGhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAqICAgICBpZiAobG9ja1N0YXR1cyA9PT0gJ2xvY2tlZCcpIHtcbiAqICAgICAgIHJldHVybjtcbiAqICAgICB9XG4gKiAgICAgc2VuZEJhY2soZXZlbnQpO1xuICogICB9O1xuICpcbiAqICAgcmVjZWl2ZSgoZXZlbnQpID0+IHtcbiAqICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2xvY2snKSB7XG4gKiAgICAgICBsb2NrU3RhdHVzID0gJ2xvY2tlZCc7XG4gKiAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAndW5sb2NrJykge1xuICogICAgICAgbG9ja1N0YXR1cyA9ICd1bmxvY2tlZCc7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVyKTtcbiAqXG4gKiAgIHJldHVybiAoKSA9PiB7XG4gKiAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpO1xuICogICB9O1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdXNlZCB0byBkZXNjcmliZSB0aGUgY2FsbGJhY2sgbG9naWNcbiAqICAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHBhc3NlZCBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGByZWNlaXZlYCAtIEEgZnVuY3Rpb24gdGhhdCBjYW4gc2VuZCBldmVudHMgYmFjayB0byB0aGUgcGFyZW50IGFjdG9yOyB0aGVcbiAqICAgICAgIGxpc3RlbmVyIGlzIHRoZW4gY2FsbGVkIHdoZW5ldmVyIGV2ZW50cyBhcmUgcmVjZWl2ZWQgYnkgdGhlIGNhbGxiYWNrXG4gKiAgICAgICBhY3RvclxuICogICAtIGBzZW5kQmFja2AgLSBBIGZ1bmN0aW9uIHRoYXQgY2FuIHNlbmQgZXZlbnRzIGJhY2sgdG8gdGhlIHBhcmVudCBhY3RvclxuICogICAtIGBpbnB1dGAgLSBEYXRhIHRoYXQgd2FzIHByb3ZpZGVkIHRvIHRoZSBjYWxsYmFjayBhY3RvclxuICogICAtIGBzZWxmYCAtIFRoZSBwYXJlbnQgYWN0b3Igb2YgdGhlIGNhbGxiYWNrIGFjdG9yXG4gKiAgIC0gYHN5c3RlbWAgLSBUaGUgYWN0b3Igc3lzdGVtIHRvIHdoaWNoIHRoZSBjYWxsYmFjayBhY3RvciBiZWxvbmdzIFRoZSBjYWxsYmFja1xuICogICAgICAgZnVuY3Rpb24gY2FuIChvcHRpb25hbGx5KSByZXR1cm4gYSBjbGVhbnVwIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWRcbiAqICAgICAgIHdoZW4gdGhlIGFjdG9yIGlzIHN0b3BwZWQuXG4gKlxuICogQHJldHVybnMgQ2FsbGJhY2sgbG9naWNcbiAqIEBzZWUge0BsaW5rIENhbGxiYWNrTG9naWNGdW5jdGlvbn0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZCBpdHMgb2JqZWN0IGFyZ3VtZW50XG4gKiBAc2VlIHtAbGluayBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9pbnB1dCB8IElucHV0IGRvY3N9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGhvdyBpbnB1dCBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gZnJvbUNhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIGNvbnN0IGxvZ2ljID0ge1xuICAgIGNvbmZpZzogY2FsbGJhY2ssXG4gICAgc3RhcnQ6IChzdGF0ZSwgYWN0b3JTY29wZSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZWxmLFxuICAgICAgICBzeXN0ZW0sXG4gICAgICAgIGVtaXRcbiAgICAgIH0gPSBhY3RvclNjb3BlO1xuICAgICAgY29uc3QgY2FsbGJhY2tTdGF0ZSA9IHtcbiAgICAgICAgcmVjZWl2ZXJzOiB1bmRlZmluZWQsXG4gICAgICAgIGRpc3Bvc2U6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICAgIGluc3RhbmNlU3RhdGVzLnNldChzZWxmLCBjYWxsYmFja1N0YXRlKTtcbiAgICAgIGNhbGxiYWNrU3RhdGUuZGlzcG9zZSA9IGNhbGxiYWNrKHtcbiAgICAgICAgaW5wdXQ6IHN0YXRlLmlucHV0LFxuICAgICAgICBzeXN0ZW0sXG4gICAgICAgIHNlbGYsXG4gICAgICAgIHNlbmRCYWNrOiBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKHNlbGYuZ2V0U25hcHNob3QoKS5zdGF0dXMgPT09ICdzdG9wcGVkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VsZi5fcGFyZW50KSB7XG4gICAgICAgICAgICBzeXN0ZW0uX3JlbGF5KHNlbGYsIHNlbGYuX3BhcmVudCwgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVjZWl2ZTogbGlzdGVuZXIgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrU3RhdGUucmVjZWl2ZXJzID8/PSBuZXcgU2V0KCk7XG4gICAgICAgICAgY2FsbGJhY2tTdGF0ZS5yZWNlaXZlcnMuYWRkKGxpc3RlbmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW1pdFxuICAgICAgfSk7XG4gICAgfSxcbiAgICB0cmFuc2l0aW9uOiAoc3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFja1N0YXRlID0gaW5zdGFuY2VTdGF0ZXMuZ2V0KGFjdG9yU2NvcGUuc2VsZik7XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gWFNUQVRFX1NUT1ApIHtcbiAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgc3RhdHVzOiAnc3RvcHBlZCcsXG4gICAgICAgICAgZXJyb3I6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICBjYWxsYmFja1N0YXRlLmRpc3Bvc2U/LigpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgICBjYWxsYmFja1N0YXRlLnJlY2VpdmVycz8uZm9yRWFjaChyZWNlaXZlciA9PiByZWNlaXZlcihldmVudCkpO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFNuYXBzaG90OiAoXywgaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICBpbnB1dFxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldFBlcnNpc3RlZFNuYXBzaG90OiBzbmFwc2hvdCA9PiBzbmFwc2hvdCxcbiAgICByZXN0b3JlU25hcHNob3Q6IHNuYXBzaG90ID0+IHNuYXBzaG90XG4gIH07XG4gIHJldHVybiBsb2dpYztcbn1cblxuY29uc3QgWFNUQVRFX09CU0VSVkFCTEVfTkVYVCA9ICd4c3RhdGUub2JzZXJ2YWJsZS5uZXh0JztcbmNvbnN0IFhTVEFURV9PQlNFUlZBQkxFX0VSUk9SID0gJ3hzdGF0ZS5vYnNlcnZhYmxlLmVycm9yJztcbmNvbnN0IFhTVEFURV9PQlNFUlZBQkxFX0NPTVBMRVRFID0gJ3hzdGF0ZS5vYnNlcnZhYmxlLmNvbXBsZXRlJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGFjdG9yIGNyZWF0ZWQgYnkgYGZyb21PYnNlcnZhYmxlYCBvciBgZnJvbUV2ZW50T2JzZXJ2YWJsZWAuXG4gKlxuICogVGhlIHR5cGUgb2YgYHNlbGZgIHdpdGhpbiB0aGUgYWN0b3IncyBsb2dpYy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tT2JzZXJ2YWJsZSwgY3JlYXRlQWN0b3IgfSBmcm9tICd4c3RhdGUnO1xuICogaW1wb3J0IHsgaW50ZXJ2YWwgfSBmcm9tICdyeGpzJztcbiAqXG4gKiAvLyBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgb2JzZXJ2ZWQgYnkgdGhlIGFjdG9yJ3MgbG9naWMuXG4gKiB0eXBlIENvbnRleHQgPSBudW1iZXI7XG4gKiAvLyBUaGUgYWN0b3IncyBpbnB1dC5cbiAqIHR5cGUgSW5wdXQgPSB7IHBlcmlvZD86IG51bWJlciB9O1xuICpcbiAqIC8vIEFjdG9yIGxvZ2ljIHRoYXQgb2JzZXJ2ZXMgYSBudW1iZXIgaW5jcmVtZW50ZWQgZXZlcnkgYGlucHV0LnBlcmlvZGBcbiAqIC8vIG1pbGxpc2Vjb25kcyAoZGVmYXVsdDogMV8wMDApLlxuICogY29uc3QgbG9naWMgPSBmcm9tT2JzZXJ2YWJsZTxDb250ZXh0LCBJbnB1dD4oKHsgaW5wdXQsIHNlbGYgfSkgPT4ge1xuICogICBzZWxmO1xuICogICAvLyBePyBPYnNlcnZhYmxlQWN0b3JSZWY8RXZlbnQsIElucHV0PlxuICpcbiAqICAgcmV0dXJuIGludGVydmFsKGlucHV0LnBlcmlvZCA/PyAxXzAwMCk7XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKGxvZ2ljLCB7IGlucHV0OiB7IHBlcmlvZDogMl8wMDAgfSB9KTtcbiAqIC8vICAgIF4/IE9ic2VydmFibGVBY3RvclJlZjxFdmVudCwgSW5wdXQ+XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBmcm9tT2JzZXJ2YWJsZX1cbiAqIEBzZWUge0BsaW5rIGZyb21FdmVudE9ic2VydmFibGV9XG4gKi9cblxuLyoqXG4gKiBPYnNlcnZhYmxlIGFjdG9yIGxvZ2ljIGlzIGRlc2NyaWJlZCBieSBhbiBvYnNlcnZhYmxlIHN0cmVhbSBvZiB2YWx1ZXMuIEFjdG9yc1xuICogY3JlYXRlZCBmcm9tIG9ic2VydmFibGUgbG9naWMgKOKAnG9ic2VydmFibGUgYWN0b3Jz4oCdKSBjYW46XG4gKlxuICogLSBFbWl0IHNuYXBzaG90cyBvZiB0aGUgb2JzZXJ2YWJsZeKAmXMgZW1pdHRlZCB2YWx1ZVxuICpcbiAqIFRoZSBvYnNlcnZhYmxl4oCZcyBlbWl0dGVkIHZhbHVlIGlzIHVzZWQgYXMgaXRzIG9ic2VydmFibGUgYWN0b3LigJlzIGBjb250ZXh0YC5cbiAqXG4gKiBTZW5kaW5nIGV2ZW50cyB0byBvYnNlcnZhYmxlIGFjdG9ycyB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGZyb21PYnNlcnZhYmxlLCBjcmVhdGVBY3RvciB9IGZyb20gJ3hzdGF0ZSc7XG4gKiBpbXBvcnQgeyBpbnRlcnZhbCB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNvbnN0IGxvZ2ljID0gZnJvbU9ic2VydmFibGUoKG9iaikgPT4gaW50ZXJ2YWwoMTAwMCkpO1xuICpcbiAqIGNvbnN0IGFjdG9yID0gY3JlYXRlQWN0b3IobG9naWMpO1xuICpcbiAqIGFjdG9yLnN1YnNjcmliZSgoc25hcHNob3QpID0+IHtcbiAqICAgY29uc29sZS5sb2coc25hcHNob3QuY29udGV4dCk7XG4gKiB9KTtcbiAqXG4gKiBhY3Rvci5zdGFydCgpO1xuICogLy8gQXQgZXZlcnkgc2Vjb25kOlxuICogLy8gTG9ncyAwXG4gKiAvLyBMb2dzIDFcbiAqIC8vIExvZ3MgMlxuICogLy8gLi4uXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb2JzZXJ2YWJsZUNyZWF0b3IgQSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYW4gb2JzZXJ2YWJsZS4gSXQgcmVjZWl2ZXNcbiAqICAgb25lIGFyZ3VtZW50LCBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGBpbnB1dGAgLSBEYXRhIHRoYXQgd2FzIHByb3ZpZGVkIHRvIHRoZSBvYnNlcnZhYmxlIGFjdG9yXG4gKiAgIC0gYHNlbGZgIC0gVGhlIHBhcmVudCBhY3RvclxuICogICAtIGBzeXN0ZW1gIC0gVGhlIGFjdG9yIHN5c3RlbSB0byB3aGljaCB0aGUgb2JzZXJ2YWJsZSBhY3RvciBiZWxvbmdzXG4gKlxuICogICBJdCBzaG91bGQgcmV0dXJuIGEge0BsaW5rIFN1YnNjcmliYWJsZX0sIHdoaWNoIGlzIGNvbXBhdGlibGUgd2l0aCBhbiBSeEpTXG4gKiAgIE9ic2VydmFibGUsIGFsdGhvdWdoIFJ4SlMgaXMgbm90IHJlcXVpcmVkIHRvIGNyZWF0ZSB0aGVtLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9yeGpzLmRldn0gZm9yIGRvY3VtZW50YXRpb24gb24gUnhKUyBPYnNlcnZhYmxlIGFuZCBvYnNlcnZhYmxlIGNyZWF0b3JzLlxuICogQHNlZSB7QGxpbmsgU3Vic2NyaWJhYmxlfSBpbnRlcmZhY2UgaW4gWFN0YXRlLCB3aGljaCBpcyBiYXNlZCBvbiBhbmQgY29tcGF0aWJsZSB3aXRoIFJ4SlMgT2JzZXJ2YWJsZS5cbiAqL1xuZnVuY3Rpb24gZnJvbU9ic2VydmFibGUob2JzZXJ2YWJsZUNyZWF0b3IpIHtcbiAgLy8gVE9ETzogYWRkIGV2ZW50IHR5cGVzXG4gIGNvbnN0IGxvZ2ljID0ge1xuICAgIGNvbmZpZzogb2JzZXJ2YWJsZUNyZWF0b3IsXG4gICAgdHJhbnNpdGlvbjogKHNuYXBzaG90LCBldmVudCkgPT4ge1xuICAgICAgaWYgKHNuYXBzaG90LnN0YXR1cyAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgICAgfVxuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgWFNUQVRFX09CU0VSVkFCTEVfTkVYVDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBuZXdTbmFwc2hvdCA9IHtcbiAgICAgICAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgICAgICAgIGNvbnRleHQ6IGV2ZW50LmRhdGFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbmV3U25hcHNob3Q7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFhTVEFURV9PQlNFUlZBQkxFX0VSUk9SOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgICAgIGVycm9yOiBldmVudC5kYXRhLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgWFNUQVRFX09CU0VSVkFCTEVfQ09NUExFVEU6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgICAgICAgc3RhdHVzOiAnZG9uZScsXG4gICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX3N1YnNjcmlwdGlvbjogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBYU1RBVEVfU1RPUDpcbiAgICAgICAgICBzbmFwc2hvdC5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgICAgICAgc3RhdHVzOiAnc3RvcHBlZCcsXG4gICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX3N1YnNjcmlwdGlvbjogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gc25hcHNob3Q7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRJbml0aWFsU25hcHNob3Q6IChfLCBpbnB1dCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICAgICAgb3V0cHV0OiB1bmRlZmluZWQsXG4gICAgICAgIGVycm9yOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbnRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9LFxuICAgIHN0YXJ0OiAoc3RhdGUsIHtcbiAgICAgIHNlbGYsXG4gICAgICBzeXN0ZW0sXG4gICAgICBlbWl0XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKHN0YXRlLnN0YXR1cyA9PT0gJ2RvbmUnKSB7XG4gICAgICAgIC8vIERvIG5vdCByZXN0YXJ0IGEgY29tcGxldGVkIG9ic2VydmFibGVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3RhdGUuX3N1YnNjcmlwdGlvbiA9IG9ic2VydmFibGVDcmVhdG9yKHtcbiAgICAgICAgaW5wdXQ6IHN0YXRlLmlucHV0LFxuICAgICAgICBzeXN0ZW0sXG4gICAgICAgIHNlbGYsXG4gICAgICAgIGVtaXRcbiAgICAgIH0pLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IHZhbHVlID0+IHtcbiAgICAgICAgICBzeXN0ZW0uX3JlbGF5KHNlbGYsIHNlbGYsIHtcbiAgICAgICAgICAgIHR5cGU6IFhTVEFURV9PQlNFUlZBQkxFX05FWFQsXG4gICAgICAgICAgICBkYXRhOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZXJyID0+IHtcbiAgICAgICAgICBzeXN0ZW0uX3JlbGF5KHNlbGYsIHNlbGYsIHtcbiAgICAgICAgICAgIHR5cGU6IFhTVEFURV9PQlNFUlZBQkxFX0VSUk9SLFxuICAgICAgICAgICAgZGF0YTogZXJyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLCB7XG4gICAgICAgICAgICB0eXBlOiBYU1RBVEVfT0JTRVJWQUJMRV9DT01QTEVURVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldFBlcnNpc3RlZFNuYXBzaG90OiAoe1xuICAgICAgX3N1YnNjcmlwdGlvbixcbiAgICAgIC4uLnN0YXRlXG4gICAgfSkgPT4gc3RhdGUsXG4gICAgcmVzdG9yZVNuYXBzaG90OiBzdGF0ZSA9PiAoe1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICB9KVxuICB9O1xuICByZXR1cm4gbG9naWM7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBldmVudCBvYnNlcnZhYmxlIGxvZ2ljIHRoYXQgbGlzdGVucyB0byBhbiBvYnNlcnZhYmxlIHRoYXQgZGVsaXZlcnNcbiAqIGV2ZW50IG9iamVjdHMuXG4gKlxuICogRXZlbnQgb2JzZXJ2YWJsZSBhY3RvciBsb2dpYyBpcyBkZXNjcmliZWQgYnkgYW4gb2JzZXJ2YWJsZSBzdHJlYW0gb2ZcbiAqIHtAbGluayBodHRwczovL3N0YXRlbHkuYWkvZG9jcy90cmFuc2l0aW9ucyNldmVudC1vYmplY3RzIHwgZXZlbnQgb2JqZWN0c30uXG4gKiBBY3RvcnMgY3JlYXRlZCBmcm9tIGV2ZW50IG9ic2VydmFibGUgbG9naWMgKOKAnGV2ZW50IG9ic2VydmFibGUgYWN0b3Jz4oCdKSBjYW46XG4gKlxuICogLSBJbXBsaWNpdGx5IHNlbmQgZXZlbnRzIHRvIGl0cyBwYXJlbnQgYWN0b3JcbiAqIC0gRW1pdCBzbmFwc2hvdHMgb2YgaXRzIGVtaXR0ZWQgZXZlbnQgb2JqZWN0c1xuICpcbiAqIFNlbmRpbmcgZXZlbnRzIHRvIGV2ZW50IG9ic2VydmFibGUgYWN0b3JzIHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHtcbiAqICAgZnJvbUV2ZW50T2JzZXJ2YWJsZSxcbiAqICAgU3Vic2NyaWJhYmxlLFxuICogICBFdmVudE9iamVjdCxcbiAqICAgY3JlYXRlTWFjaGluZSxcbiAqICAgY3JlYXRlQWN0b3JcbiAqIH0gZnJvbSAneHN0YXRlJztcbiAqIGltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMnO1xuICpcbiAqIGNvbnN0IG1vdXNlQ2xpY2tMb2dpYyA9IGZyb21FdmVudE9ic2VydmFibGUoXG4gKiAgICgpID0+IGZyb21FdmVudChkb2N1bWVudC5ib2R5LCAnY2xpY2snKSBhcyBTdWJzY3JpYmFibGU8RXZlbnRPYmplY3Q+XG4gKiApO1xuICpcbiAqIGNvbnN0IGNhbnZhc01hY2hpbmUgPSBjcmVhdGVNYWNoaW5lKHtcbiAqICAgaW52b2tlOiB7XG4gKiAgICAgLy8gV2lsbCBzZW5kIG1vdXNlIGBjbGlja2AgZXZlbnRzIHRvIHRoZSBjYW52YXMgYWN0b3JcbiAqICAgICBzcmM6IG1vdXNlQ2xpY2tMb2dpY1xuICogICB9XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBjYW52YXNBY3RvciA9IGNyZWF0ZUFjdG9yKGNhbnZhc01hY2hpbmUpO1xuICogY2FudmFzQWN0b3Iuc3RhcnQoKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBsYXp5T2JzZXJ2YWJsZSBBIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhbiBvYnNlcnZhYmxlIHRoYXQgZGVsaXZlcnNcbiAqICAgZXZlbnQgb2JqZWN0cy4gSXQgcmVjZWl2ZXMgb25lIGFyZ3VtZW50LCBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiAgIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGBpbnB1dGAgLSBEYXRhIHRoYXQgd2FzIHByb3ZpZGVkIHRvIHRoZSBldmVudCBvYnNlcnZhYmxlIGFjdG9yXG4gKiAgIC0gYHNlbGZgIC0gVGhlIHBhcmVudCBhY3RvclxuICogICAtIGBzeXN0ZW1gIC0gVGhlIGFjdG9yIHN5c3RlbSB0byB3aGljaCB0aGUgZXZlbnQgb2JzZXJ2YWJsZSBhY3RvciBiZWxvbmdzLlxuICpcbiAqICAgSXQgc2hvdWxkIHJldHVybiBhIHtAbGluayBTdWJzY3JpYmFibGV9LCB3aGljaCBpcyBjb21wYXRpYmxlIHdpdGggYW4gUnhKU1xuICogICBPYnNlcnZhYmxlLCBhbHRob3VnaCBSeEpTIGlzIG5vdCByZXF1aXJlZCB0byBjcmVhdGUgdGhlbS5cbiAqL1xuZnVuY3Rpb24gZnJvbUV2ZW50T2JzZXJ2YWJsZShsYXp5T2JzZXJ2YWJsZSkge1xuICAvLyBUT0RPOiBldmVudCB0eXBlc1xuICBjb25zdCBsb2dpYyA9IHtcbiAgICBjb25maWc6IGxhenlPYnNlcnZhYmxlLFxuICAgIHRyYW5zaXRpb246IChzdGF0ZSwgZXZlbnQpID0+IHtcbiAgICAgIGlmIChzdGF0ZS5zdGF0dXMgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlIFhTVEFURV9PQlNFUlZBQkxFX0VSUk9SOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgICAgIGVycm9yOiBldmVudC5kYXRhLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgWFNUQVRFX09CU0VSVkFCTEVfQ09NUExFVEU6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgc3RhdHVzOiAnZG9uZScsXG4gICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX3N1YnNjcmlwdGlvbjogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBYU1RBVEVfU1RPUDpcbiAgICAgICAgICBzdGF0ZS5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgc3RhdHVzOiAnc3RvcHBlZCcsXG4gICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX3N1YnNjcmlwdGlvbjogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRJbml0aWFsU25hcHNob3Q6IChfLCBpbnB1dCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICAgICAgb3V0cHV0OiB1bmRlZmluZWQsXG4gICAgICAgIGVycm9yOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbnRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9LFxuICAgIHN0YXJ0OiAoc3RhdGUsIHtcbiAgICAgIHNlbGYsXG4gICAgICBzeXN0ZW0sXG4gICAgICBlbWl0XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKHN0YXRlLnN0YXR1cyA9PT0gJ2RvbmUnKSB7XG4gICAgICAgIC8vIERvIG5vdCByZXN0YXJ0IGEgY29tcGxldGVkIG9ic2VydmFibGVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3RhdGUuX3N1YnNjcmlwdGlvbiA9IGxhenlPYnNlcnZhYmxlKHtcbiAgICAgICAgaW5wdXQ6IHN0YXRlLmlucHV0LFxuICAgICAgICBzeXN0ZW0sXG4gICAgICAgIHNlbGYsXG4gICAgICAgIGVtaXRcbiAgICAgIH0pLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IHZhbHVlID0+IHtcbiAgICAgICAgICBpZiAoc2VsZi5fcGFyZW50KSB7XG4gICAgICAgICAgICBzeXN0ZW0uX3JlbGF5KHNlbGYsIHNlbGYuX3BhcmVudCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGVyciA9PiB7XG4gICAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLCB7XG4gICAgICAgICAgICB0eXBlOiBYU1RBVEVfT0JTRVJWQUJMRV9FUlJPUixcbiAgICAgICAgICAgIGRhdGE6IGVyclxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgIHN5c3RlbS5fcmVsYXkoc2VsZiwgc2VsZiwge1xuICAgICAgICAgICAgdHlwZTogWFNUQVRFX09CU0VSVkFCTEVfQ09NUExFVEVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRQZXJzaXN0ZWRTbmFwc2hvdDogKHtcbiAgICAgIF9zdWJzY3JpcHRpb24sXG4gICAgICAuLi5zbmFwc2hvdFxuICAgIH0pID0+IHNuYXBzaG90LFxuICAgIHJlc3RvcmVTbmFwc2hvdDogc25hcHNob3QgPT4gKHtcbiAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgX3N1YnNjcmlwdGlvbjogdW5kZWZpbmVkXG4gICAgfSlcbiAgfTtcbiAgcmV0dXJuIGxvZ2ljO1xufVxuXG5jb25zdCBYU1RBVEVfUFJPTUlTRV9SRVNPTFZFID0gJ3hzdGF0ZS5wcm9taXNlLnJlc29sdmUnO1xuY29uc3QgWFNUQVRFX1BST01JU0VfUkVKRUNUID0gJ3hzdGF0ZS5wcm9taXNlLnJlamVjdCc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBhY3RvciBjcmVhdGVkIGJ5IGBmcm9tUHJvbWlzZWAuXG4gKlxuICogVGhlIHR5cGUgb2YgYHNlbGZgIHdpdGhpbiB0aGUgYWN0b3IncyBsb2dpYy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tUHJvbWlzZSwgY3JlYXRlQWN0b3IgfSBmcm9tICd4c3RhdGUnO1xuICpcbiAqIC8vIFRoZSBhY3RvcidzIHJlc29sdmVkIG91dHB1dFxuICogdHlwZSBPdXRwdXQgPSBzdHJpbmc7XG4gKiAvLyBUaGUgYWN0b3IncyBpbnB1dC5cbiAqIHR5cGUgSW5wdXQgPSB7IG1lc3NhZ2U6IHN0cmluZyB9O1xuICpcbiAqIC8vIEFjdG9yIGxvZ2ljIHRoYXQgZmV0Y2hlcyB0aGUgdXJsIG9mIGFuIGltYWdlIG9mIGEgY2F0IHNheWluZyBgaW5wdXQubWVzc2FnZWAuXG4gKiBjb25zdCBsb2dpYyA9IGZyb21Qcm9taXNlPE91dHB1dCwgSW5wdXQ+KGFzeW5jICh7IGlucHV0LCBzZWxmIH0pID0+IHtcbiAqICAgc2VsZjtcbiAqICAgLy8gXj8gUHJvbWlzZUFjdG9yUmVmPE91dHB1dCwgSW5wdXQ+XG4gKlxuICogICBjb25zdCBkYXRhID0gYXdhaXQgZmV0Y2goXG4gKiAgICAgYGh0dHBzOi8vY2F0YWFzLmNvbS9jYXQvc2F5cy8ke2lucHV0Lm1lc3NhZ2V9YFxuICogICApO1xuICogICBjb25zdCB1cmwgPSBhd2FpdCBkYXRhLmpzb24oKTtcbiAqICAgcmV0dXJuIHVybDtcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGFjdG9yID0gY3JlYXRlQWN0b3IobG9naWMsIHsgaW5wdXQ6IHsgbWVzc2FnZTogJ2hlbGxvIHdvcmxkJyB9IH0pO1xuICogLy8gICAgXj8gUHJvbWlzZUFjdG9yUmVmPE91dHB1dCwgSW5wdXQ+XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBmcm9tUHJvbWlzZX1cbiAqL1xuXG5jb25zdCBjb250cm9sbGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBBbiBhY3RvciBsb2dpYyBjcmVhdG9yIHdoaWNoIHJldHVybnMgcHJvbWlzZSBsb2dpYyBhcyBkZWZpbmVkIGJ5IGFuIGFzeW5jXG4gKiBwcm9jZXNzIHRoYXQgcmVzb2x2ZXMgb3IgcmVqZWN0cyBhZnRlciBzb21lIHRpbWUuXG4gKlxuICogQWN0b3JzIGNyZWF0ZWQgZnJvbSBwcm9taXNlIGFjdG9yIGxvZ2ljICjigJxwcm9taXNlIGFjdG9yc+KAnSkgY2FuOlxuICpcbiAqIC0gRW1pdCB0aGUgcmVzb2x2ZWQgdmFsdWUgb2YgdGhlIHByb21pc2VcbiAqIC0gT3V0cHV0IHRoZSByZXNvbHZlZCB2YWx1ZSBvZiB0aGUgcHJvbWlzZVxuICpcbiAqIFNlbmRpbmcgZXZlbnRzIHRvIHByb21pc2UgYWN0b3JzIHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogY29uc3QgcHJvbWlzZUxvZ2ljID0gZnJvbVByb21pc2UoYXN5bmMgKCkgPT4ge1xuICogICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9leGFtcGxlLmNvbS8uLi4nKS50aGVuKChkYXRhKSA9PlxuICogICAgIGRhdGEuanNvbigpXG4gKiAgICk7XG4gKlxuICogICByZXR1cm4gcmVzdWx0O1xuICogfSk7XG4gKlxuICogY29uc3QgcHJvbWlzZUFjdG9yID0gY3JlYXRlQWN0b3IocHJvbWlzZUxvZ2ljKTtcbiAqIHByb21pc2VBY3Rvci5zdWJzY3JpYmUoKHNuYXBzaG90KSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKHNuYXBzaG90KTtcbiAqIH0pO1xuICogcHJvbWlzZUFjdG9yLnN0YXJ0KCk7XG4gKiAvLyA9PiB7XG4gKiAvLyAgIG91dHB1dDogdW5kZWZpbmVkLFxuICogLy8gICBzdGF0dXM6ICdhY3RpdmUnXG4gKiAvLyAgIC4uLlxuICogLy8gfVxuICpcbiAqIC8vIEFmdGVyIHByb21pc2UgcmVzb2x2ZXNcbiAqIC8vID0+IHtcbiAqIC8vICAgb3V0cHV0OiB7IC4uLiB9LFxuICogLy8gICBzdGF0dXM6ICdkb25lJyxcbiAqIC8vICAgLi4uXG4gKiAvLyB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHJvbWlzZUNyZWF0b3IgQSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgUHJvbWlzZSwgYW5kIGFjY2VwdHMgYW5cbiAqICAgb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgaW5wdXRgIC0gRGF0YSB0aGF0IHdhcyBwcm92aWRlZCB0byB0aGUgcHJvbWlzZSBhY3RvclxuICogICAtIGBzZWxmYCAtIFRoZSBwYXJlbnQgYWN0b3Igb2YgdGhlIHByb21pc2UgYWN0b3JcbiAqICAgLSBgc3lzdGVtYCAtIFRoZSBhY3RvciBzeXN0ZW0gdG8gd2hpY2ggdGhlIHByb21pc2UgYWN0b3IgYmVsb25nc1xuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vc3RhdGVseS5haS9kb2NzL2lucHV0IHwgSW5wdXQgZG9jc30gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgaG93IGlucHV0IGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiBmcm9tUHJvbWlzZShwcm9taXNlQ3JlYXRvcikge1xuICBjb25zdCBsb2dpYyA9IHtcbiAgICBjb25maWc6IHByb21pc2VDcmVhdG9yLFxuICAgIHRyYW5zaXRpb246IChzdGF0ZSwgZXZlbnQsIHNjb3BlKSA9PiB7XG4gICAgICBpZiAoc3RhdGUuc3RhdHVzICE9PSAnYWN0aXZlJykge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSBYU1RBVEVfUFJPTUlTRV9SRVNPTFZFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkVmFsdWUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgIHN0YXR1czogJ2RvbmUnLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHJlc29sdmVkVmFsdWUsXG4gICAgICAgICAgICAgIGlucHV0OiB1bmRlZmluZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFhTVEFURV9QUk9NSVNFX1JFSkVDVDpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgICBlcnJvcjogZXZlbnQuZGF0YSxcbiAgICAgICAgICAgIGlucHV0OiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFhTVEFURV9TVE9QOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXJNYXAuZ2V0KHNjb3BlLnNlbGYpPy5hYm9ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgIHN0YXR1czogJ3N0b3BwZWQnLFxuICAgICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgfSxcbiAgICBzdGFydDogKHN0YXRlLCB7XG4gICAgICBzZWxmLFxuICAgICAgc3lzdGVtLFxuICAgICAgZW1pdFxuICAgIH0pID0+IHtcbiAgICAgIC8vIFRPRE86IGRldGVybWluZSBob3cgdG8gYWxsb3cgY3VzdG9taXppbmcgdGhpcyBzbyB0aGF0IHByb21pc2VzXG4gICAgICAvLyBjYW4gYmUgcmVzdGFydGVkIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHN0YXRlLnN0YXR1cyAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnRyb2xsZXJNYXAuc2V0KHNlbGYsIGNvbnRyb2xsZXIpO1xuICAgICAgY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHByb21pc2VDcmVhdG9yKHtcbiAgICAgICAgaW5wdXQ6IHN0YXRlLmlucHV0LFxuICAgICAgICBzeXN0ZW0sXG4gICAgICAgIHNlbGYsXG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIGVtaXRcbiAgICAgIH0pKTtcbiAgICAgIHJlc29sdmVkUHJvbWlzZS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgaWYgKHNlbGYuZ2V0U25hcHNob3QoKS5zdGF0dXMgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXJNYXAuZGVsZXRlKHNlbGYpO1xuICAgICAgICBzeXN0ZW0uX3JlbGF5KHNlbGYsIHNlbGYsIHtcbiAgICAgICAgICB0eXBlOiBYU1RBVEVfUFJPTUlTRV9SRVNPTFZFLFxuICAgICAgICAgIGRhdGE6IHJlc3BvbnNlXG4gICAgICAgIH0pO1xuICAgICAgfSwgZXJyb3JEYXRhID0+IHtcbiAgICAgICAgaWYgKHNlbGYuZ2V0U25hcHNob3QoKS5zdGF0dXMgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXJNYXAuZGVsZXRlKHNlbGYpO1xuICAgICAgICBzeXN0ZW0uX3JlbGF5KHNlbGYsIHNlbGYsIHtcbiAgICAgICAgICB0eXBlOiBYU1RBVEVfUFJPTUlTRV9SRUpFQ1QsXG4gICAgICAgICAgZGF0YTogZXJyb3JEYXRhXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRJbml0aWFsU25hcHNob3Q6IChfLCBpbnB1dCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICAgICAgb3V0cHV0OiB1bmRlZmluZWQsXG4gICAgICAgIGVycm9yOiB1bmRlZmluZWQsXG4gICAgICAgIGlucHV0XG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0UGVyc2lzdGVkU25hcHNob3Q6IHNuYXBzaG90ID0+IHNuYXBzaG90LFxuICAgIHJlc3RvcmVTbmFwc2hvdDogc25hcHNob3QgPT4gc25hcHNob3RcbiAgfTtcbiAgcmV0dXJuIGxvZ2ljO1xufVxuXG5jb25zdCBlbXB0eUxvZ2ljID0gZnJvbVRyYW5zaXRpb24oXyA9PiB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG5mdW5jdGlvbiBjcmVhdGVFbXB0eUFjdG9yKCkge1xuICByZXR1cm4gY3JlYXRlQWN0b3IoZW1wdHlMb2dpYyk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUVtcHR5QWN0b3IsIGZyb21DYWxsYmFjaywgZnJvbUV2ZW50T2JzZXJ2YWJsZSwgZnJvbU9ic2VydmFibGUsIGZyb21Qcm9taXNlLCBmcm9tVHJhbnNpdGlvbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/xstate/dev/dist/xstate-dev.development.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   devToolsAdapter: () => (/* binding */ devToolsAdapter),\n/* harmony export */   getGlobal: () => (/* binding */ getGlobal),\n/* harmony export */   registerService: () => (/* binding */ registerService)\n/* harmony export */ });\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nfunction getGlobal() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  {\n    console.warn('XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues');\n  }\n}\nfunction getDevTools() {\n  const w = getGlobal();\n  if (w.__xstate__) {\n    return w.__xstate__;\n  }\n  return undefined;\n}\nfunction registerService(service) {\n  if (typeof window === 'undefined') {\n    return;\n  }\n  const devTools = getDevTools();\n  if (devTools) {\n    devTools.register(service);\n  }\n}\nconst devToolsAdapter = service => {\n  if (typeof window === 'undefined') {\n    return;\n  }\n  const devTools = getDevTools();\n  if (devTools) {\n    devTools.register(service);\n  }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rldi9kaXN0L3hzdGF0ZS1kZXYuZGV2ZWxvcG1lbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1RCIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaXNwLWNsZWFuaW5nLy4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9kZXYvZGlzdC94c3RhdGUtZGV2LmRldmVsb3BtZW50LmVzbS5qcz9mMzIyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvZ2xvYmFsVGhpc1xuZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGdsb2JhbDtcbiAgfVxuICB7XG4gICAgY29uc29sZS53YXJuKCdYU3RhdGUgY291bGQgbm90IGZpbmQgYSBnbG9iYWwgb2JqZWN0IGluIHRoaXMgZW52aXJvbm1lbnQuIFBsZWFzZSBsZXQgdGhlIG1haW50YWluZXJzIGtub3cgYW5kIHJhaXNlIGFuIGlzc3VlIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9zdGF0ZWx5YWkveHN0YXRlL2lzc3VlcycpO1xuICB9XG59XG5mdW5jdGlvbiBnZXREZXZUb29scygpIHtcbiAgY29uc3QgdyA9IGdldEdsb2JhbCgpO1xuICBpZiAody5fX3hzdGF0ZV9fKSB7XG4gICAgcmV0dXJuIHcuX194c3RhdGVfXztcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJTZXJ2aWNlKHNlcnZpY2UpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRldlRvb2xzID0gZ2V0RGV2VG9vbHMoKTtcbiAgaWYgKGRldlRvb2xzKSB7XG4gICAgZGV2VG9vbHMucmVnaXN0ZXIoc2VydmljZSk7XG4gIH1cbn1cbmNvbnN0IGRldlRvb2xzQWRhcHRlciA9IHNlcnZpY2UgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZGV2VG9vbHMgPSBnZXREZXZUb29scygpO1xuICBpZiAoZGV2VG9vbHMpIHtcbiAgICBkZXZUb29scy5yZWdpc3RlcihzZXJ2aWNlKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgZGV2VG9vbHNBZGFwdGVyLCBnZXRHbG9iYWwsIHJlZ2lzdGVyU2VydmljZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/StateMachine-53479528.development.esm.js":
/*!***************************************************************************!*\
  !*** ./node_modules/xstate/dist/StateMachine-53479528.development.esm.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: () => (/* binding */ StateMachine),\n/* harmony export */   a: () => (/* binding */ StateNode)\n/* harmony export */ });\n/* harmony import */ var _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raise-235fa0c7.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-235fa0c7.development.esm.js\");\n/* harmony import */ var _assign_ef1b62f6_development_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assign-ef1b62f6.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/assign-ef1b62f6.development.esm.js\");\n\n\n\nconst cache = new WeakMap();\nfunction memo(object, key, fn) {\n  let memoizedData = cache.get(object);\n  if (!memoizedData) {\n    memoizedData = {\n      [key]: fn()\n    };\n    cache.set(object, memoizedData);\n  } else if (!(key in memoizedData)) {\n    memoizedData[key] = fn();\n  }\n  return memoizedData[key];\n}\n\nconst EMPTY_OBJECT = {};\nconst toSerializableAction = action => {\n  if (typeof action === 'string') {\n    return {\n      type: action\n    };\n  }\n  if (typeof action === 'function') {\n    if ('resolve' in action) {\n      return {\n        type: action.type\n      };\n    }\n    return {\n      type: action.name\n    };\n  }\n  return action;\n};\nclass StateNode {\n  constructor(/** The raw config used to create the machine. */\n  config, options) {\n    this.config = config;\n    /**\n     * The relative key of the state node, which represents its location in the\n     * overall state value.\n     */\n    this.key = void 0;\n    /** The unique ID of the state node. */\n    this.id = void 0;\n    /**\n     * The type of this state node:\n     *\n     * - `'atomic'` - no child state nodes\n     * - `'compound'` - nested child state nodes (XOR)\n     * - `'parallel'` - orthogonal nested child state nodes (AND)\n     * - `'history'` - history state node\n     * - `'final'` - final state node\n     */\n    this.type = void 0;\n    /** The string path from the root machine node to this node. */\n    this.path = void 0;\n    /** The child state nodes. */\n    this.states = void 0;\n    /**\n     * The type of history on this state node. Can be:\n     *\n     * - `'shallow'` - recalls only top-level historical state value\n     * - `'deep'` - recalls historical state value at all levels\n     */\n    this.history = void 0;\n    /** The action(s) to be executed upon entering the state node. */\n    this.entry = void 0;\n    /** The action(s) to be executed upon exiting the state node. */\n    this.exit = void 0;\n    /** The parent state node. */\n    this.parent = void 0;\n    /** The root machine node. */\n    this.machine = void 0;\n    /**\n     * The meta data associated with this state node, which will be returned in\n     * State instances.\n     */\n    this.meta = void 0;\n    /**\n     * The output data sent with the \"xstate.done.state._id_\" event if this is a\n     * final state node.\n     */\n    this.output = void 0;\n    /**\n     * The order this state node appears. Corresponds to the implicit document\n     * order.\n     */\n    this.order = -1;\n    this.description = void 0;\n    this.tags = [];\n    this.transitions = void 0;\n    this.always = void 0;\n    this.parent = options._parent;\n    this.key = options._key;\n    this.machine = options._machine;\n    this.path = this.parent ? this.parent.path.concat(this.key) : [];\n    this.id = this.config.id || [this.machine.id, ...this.path].join(_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.S);\n    this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? 'compound' : this.config.history ? 'history' : 'atomic');\n    this.description = this.config.description;\n    this.order = this.machine.idMap.size;\n    this.machine.idMap.set(this.id, this);\n    this.states = this.config.states ? (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.q)(this.config.states, (stateConfig, key) => {\n      const stateNode = new StateNode(stateConfig, {\n        _parent: this,\n        _key: key,\n        _machine: this.machine\n      });\n      return stateNode;\n    }) : EMPTY_OBJECT;\n    if (this.type === 'compound' && !this.config.initial) {\n      throw new Error(`No initial state specified for compound state node \"#${this.id}\". Try adding { initial: \"${Object.keys(this.states)[0]}\" } to the state config.`);\n    }\n\n    // History config\n    this.history = this.config.history === true ? 'shallow' : this.config.history || false;\n    this.entry = (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.config.entry).slice();\n    this.exit = (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.config.exit).slice();\n    this.meta = this.config.meta;\n    this.output = this.type === 'final' || !this.parent ? this.config.output : undefined;\n    this.tags = (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)(config.tags).slice();\n  }\n\n  /** @internal */\n  _initialize() {\n    this.transitions = (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)(this);\n    if (this.config.always) {\n      this.always = (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.v)(this.config.always).map(t => (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.w)(this, _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.N, t));\n    }\n    Object.keys(this.states).forEach(key => {\n      this.states[key]._initialize();\n    });\n  }\n\n  /** The well-structured state node definition. */\n  get definition() {\n    return {\n      id: this.id,\n      key: this.key,\n      version: this.machine.version,\n      type: this.type,\n      initial: this.initial ? {\n        target: this.initial.target,\n        source: this,\n        actions: this.initial.actions.map(toSerializableAction),\n        eventType: null,\n        reenter: false,\n        toJSON: () => ({\n          target: this.initial.target.map(t => `#${t.id}`),\n          source: `#${this.id}`,\n          actions: this.initial.actions.map(toSerializableAction),\n          eventType: null\n        })\n      } : undefined,\n      history: this.history,\n      states: (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.q)(this.states, state => {\n        return state.definition;\n      }),\n      on: this.on,\n      transitions: [...this.transitions.values()].flat().map(t => ({\n        ...t,\n        actions: t.actions.map(toSerializableAction)\n      })),\n      entry: this.entry.map(toSerializableAction),\n      exit: this.exit.map(toSerializableAction),\n      meta: this.meta,\n      order: this.order || -1,\n      output: this.output,\n      invoke: this.invoke,\n      description: this.description,\n      tags: this.tags\n    };\n  }\n\n  /** @internal */\n  toJSON() {\n    return this.definition;\n  }\n\n  /** The logic invoked as actors by this state node. */\n  get invoke() {\n    return memo(this, 'invoke', () => (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.config.invoke).map((invokeConfig, i) => {\n      const {\n        src,\n        systemId\n      } = invokeConfig;\n      const resolvedId = invokeConfig.id ?? (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.y)(this.id, i);\n      const sourceName = typeof src === 'string' ? src : `xstate.invoke.${(0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.y)(this.id, i)}`;\n      return {\n        ...invokeConfig,\n        src: sourceName,\n        id: resolvedId,\n        systemId: systemId,\n        toJSON() {\n          const {\n            onDone,\n            onError,\n            ...invokeDefValues\n          } = invokeConfig;\n          return {\n            ...invokeDefValues,\n            type: 'xstate.invoke',\n            src: sourceName,\n            id: resolvedId\n          };\n        }\n      };\n    }));\n  }\n\n  /** The mapping of events to transitions. */\n  get on() {\n    return memo(this, 'on', () => {\n      const transitions = this.transitions;\n      return [...transitions].flatMap(([descriptor, t]) => t.map(t => [descriptor, t])).reduce((map, [descriptor, transition]) => {\n        map[descriptor] = map[descriptor] || [];\n        map[descriptor].push(transition);\n        return map;\n      }, {});\n    });\n  }\n  get after() {\n    return memo(this, 'delayedTransitions', () => (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.z)(this));\n  }\n  get initial() {\n    return memo(this, 'initial', () => (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.B)(this, this.config.initial));\n  }\n\n  /** @internal */\n  next(snapshot, event) {\n    const eventType = event.type;\n    const actions = [];\n    let selectedTransition;\n    const candidates = memo(this, `candidates-${eventType}`, () => (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.C)(this, eventType));\n    for (const candidate of candidates) {\n      const {\n        guard\n      } = candidate;\n      const resolvedContext = snapshot.context;\n      let guardPassed = false;\n      try {\n        guardPassed = !guard || (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.x)(guard, resolvedContext, event, snapshot);\n      } catch (err) {\n        const guardType = typeof guard === 'string' ? guard : typeof guard === 'object' ? guard.type : undefined;\n        throw new Error(`Unable to evaluate guard ${guardType ? `'${guardType}' ` : ''}in transition for event '${eventType}' in state node '${this.id}':\\n${err.message}`);\n      }\n      if (guardPassed) {\n        actions.push(...candidate.actions);\n        selectedTransition = candidate;\n        break;\n      }\n    }\n    return selectedTransition ? [selectedTransition] : undefined;\n  }\n\n  /** All the event types accepted by this state node and its descendants. */\n  get events() {\n    return memo(this, 'events', () => {\n      const {\n        states\n      } = this;\n      const events = new Set(this.ownEvents);\n      if (states) {\n        for (const stateId of Object.keys(states)) {\n          const state = states[stateId];\n          if (state.states) {\n            for (const event of state.events) {\n              events.add(`${event}`);\n            }\n          }\n        }\n      }\n      return Array.from(events);\n    });\n  }\n\n  /**\n   * All the events that have transitions directly from this state node.\n   *\n   * Excludes any inert events.\n   */\n  get ownEvents() {\n    const keys = Object.keys(Object.fromEntries(this.transitions));\n    const events = new Set(keys.filter(descriptor => {\n      return this.transitions.get(descriptor).some(transition => !(!transition.target && !transition.actions.length && !transition.reenter));\n    }));\n    return Array.from(events);\n  }\n}\n\nconst STATE_IDENTIFIER = '#';\nclass StateMachine {\n  constructor(/** The raw config used to create the machine. */\n  config, implementations) {\n    this.config = config;\n    /** The machine's own version. */\n    this.version = void 0;\n    this.schemas = void 0;\n    this.implementations = void 0;\n    /** @internal */\n    this.__xstatenode = true;\n    /** @internal */\n    this.idMap = new Map();\n    this.root = void 0;\n    this.id = void 0;\n    this.states = void 0;\n    this.events = void 0;\n    this.id = config.id || '(machine)';\n    this.implementations = {\n      actors: implementations?.actors ?? {},\n      actions: implementations?.actions ?? {},\n      delays: implementations?.delays ?? {},\n      guards: implementations?.guards ?? {}\n    };\n    this.version = this.config.version;\n    this.schemas = this.config.schemas;\n    this.transition = this.transition.bind(this);\n    this.getInitialSnapshot = this.getInitialSnapshot.bind(this);\n    this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);\n    this.restoreSnapshot = this.restoreSnapshot.bind(this);\n    this.start = this.start.bind(this);\n    this.root = new StateNode(config, {\n      _key: this.id,\n      _machine: this\n    });\n    this.root._initialize();\n    this.states = this.root.states; // TODO: remove!\n    this.events = this.root.events;\n    if (!('output' in this.root) && Object.values(this.states).some(state => state.type === 'final' && 'output' in state)) {\n      console.warn('Missing `machine.output` declaration (top-level final state with output detected)');\n    }\n  }\n\n  /**\n   * Clones this state machine with the provided implementations.\n   *\n   * @param implementations Options (`actions`, `guards`, `actors`, `delays`) to\n   *   recursively merge with the existing options.\n   * @returns A new `StateMachine` instance with the provided implementations.\n   */\n  provide(implementations) {\n    const {\n      actions,\n      guards,\n      actors,\n      delays\n    } = this.implementations;\n    return new StateMachine(this.config, {\n      actions: {\n        ...actions,\n        ...implementations.actions\n      },\n      guards: {\n        ...guards,\n        ...implementations.guards\n      },\n      actors: {\n        ...actors,\n        ...implementations.actors\n      },\n      delays: {\n        ...delays,\n        ...implementations.delays\n      }\n    });\n  }\n  resolveState(config) {\n    const resolvedStateValue = (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.D)(this.root, config.value);\n    const nodeSet = (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.E)((0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.g)(this.root, resolvedStateValue));\n    return (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.F)({\n      _nodes: [...nodeSet],\n      context: config.context || {},\n      children: {},\n      status: (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.G)(nodeSet, this.root) ? 'done' : config.status || 'active',\n      output: config.output,\n      error: config.error,\n      historyValue: config.historyValue\n    }, this);\n  }\n\n  /**\n   * Determines the next snapshot given the current `snapshot` and received\n   * `event`. Calculates a full macrostep from all microsteps.\n   *\n   * @param snapshot The current snapshot\n   * @param event The received event\n   */\n  transition(snapshot, event, actorScope) {\n    return (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.H)(snapshot, event, actorScope, []).snapshot;\n  }\n\n  /**\n   * Determines the next state given the current `state` and `event`. Calculates\n   * a microstep.\n   *\n   * @param state The current state\n   * @param event The received event\n   */\n  microstep(snapshot, event, actorScope) {\n    return (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.H)(snapshot, event, actorScope, []).microstates;\n  }\n  getTransitionData(snapshot, event) {\n    return (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.I)(this.root, snapshot.value, snapshot, event) || [];\n  }\n\n  /**\n   * The initial state _before_ evaluating any microsteps. This \"pre-initial\"\n   * state is provided to initial actions executed in the initial state.\n   */\n  getPreInitialState(actorScope, initEvent, internalQueue) {\n    const {\n      context\n    } = this.config;\n    const preInitial = (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.F)({\n      context: typeof context !== 'function' && context ? context : {},\n      _nodes: [this.root],\n      children: {},\n      status: 'active'\n    }, this);\n    if (typeof context === 'function') {\n      const assignment = ({\n        spawn,\n        event,\n        self\n      }) => context({\n        spawn,\n        input: event.input,\n        self\n      });\n      return (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.J)(preInitial, initEvent, actorScope, [(0,_assign_ef1b62f6_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(assignment)], internalQueue, undefined);\n    }\n    return preInitial;\n  }\n\n  /**\n   * Returns the initial `State` instance, with reference to `self` as an\n   * `ActorRef`.\n   */\n  getInitialSnapshot(actorScope, input) {\n    const initEvent = (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.K)(input); // TODO: fix;\n    const internalQueue = [];\n    const preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue);\n    const nextState = (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.L)([{\n      target: [...(0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.M)(this.root)],\n      source: this.root,\n      reenter: true,\n      actions: [],\n      eventType: null,\n      toJSON: null // TODO: fix\n    }], preInitialState, actorScope, initEvent, true, internalQueue);\n    const {\n      snapshot: macroState\n    } = (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.H)(nextState, initEvent, actorScope, internalQueue);\n    return macroState;\n  }\n  start(snapshot) {\n    Object.values(snapshot.children).forEach(child => {\n      if (child.getSnapshot().status === 'active') {\n        child.start();\n      }\n    });\n  }\n  getStateNodeById(stateId) {\n    const fullPath = (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.O)(stateId);\n    const relativePath = fullPath.slice(1);\n    const resolvedStateId = (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.P)(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0];\n    const stateNode = this.idMap.get(resolvedStateId);\n    if (!stateNode) {\n      throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);\n    }\n    return (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.Q)(stateNode, relativePath);\n  }\n  get definition() {\n    return this.root.definition;\n  }\n  toJSON() {\n    return this.definition;\n  }\n  getPersistedSnapshot(snapshot, options) {\n    return (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.R)(snapshot, options);\n  }\n  restoreSnapshot(snapshot, _actorScope) {\n    const children = {};\n    const snapshotChildren = snapshot.children;\n    Object.keys(snapshotChildren).forEach(actorId => {\n      const actorData = snapshotChildren[actorId];\n      const childState = actorData.snapshot;\n      const src = actorData.src;\n      const logic = typeof src === 'string' ? (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.T)(this, src) : src;\n      if (!logic) {\n        return;\n      }\n      const actorRef = (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(logic, {\n        id: actorId,\n        parent: _actorScope.self,\n        syncSnapshot: actorData.syncSnapshot,\n        snapshot: childState,\n        src,\n        systemId: actorData.systemId\n      });\n      children[actorId] = actorRef;\n    });\n    function resolveHistoryReferencedState(root, referenced) {\n      if (referenced instanceof StateNode) {\n        return referenced;\n      }\n      try {\n        return root.machine.getStateNodeById(referenced.id);\n      } catch {\n        {\n          console.warn(`Could not resolve StateNode for id: ${referenced.id}`);\n        }\n      }\n    }\n    function reviveHistoryValue(root, historyValue) {\n      if (!historyValue || typeof historyValue !== 'object') {\n        return {};\n      }\n      const revived = {};\n      for (const key in historyValue) {\n        const arr = historyValue[key];\n        for (const item of arr) {\n          const resolved = resolveHistoryReferencedState(root, item);\n          if (!resolved) {\n            continue;\n          }\n          revived[key] ??= [];\n          revived[key].push(resolved);\n        }\n      }\n      return revived;\n    }\n    const revivedHistoryValue = reviveHistoryValue(this.root, snapshot.historyValue);\n    const restoredSnapshot = (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.F)({\n      ...snapshot,\n      children,\n      _nodes: Array.from((0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.E)((0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.g)(this.root, snapshot.value))),\n      historyValue: revivedHistoryValue\n    }, this);\n    const seen = new Set();\n    function reviveContext(contextPart, children) {\n      if (seen.has(contextPart)) {\n        return;\n      }\n      seen.add(contextPart);\n      for (const key in contextPart) {\n        const value = contextPart[key];\n        if (value && typeof value === 'object') {\n          if ('xstate$$type' in value && value.xstate$$type === _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.$) {\n            contextPart[key] = children[value.id];\n            continue;\n          }\n          reviveContext(value, children);\n        }\n      }\n    }\n    reviveContext(restoredSnapshot.context, children);\n    return restoredSnapshot;\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvU3RhdGVNYWNoaW5lLTUzNDc5NTI4LmRldmVsb3BtZW50LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQStzQjtBQUM1b0I7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsaUVBQWU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMscUVBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4RUFBOEUsUUFBUSxnQkFBZ0IsWUFBWSw0QkFBNEIsSUFBSTtBQUNsSjs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHFFQUFPO0FBQ3hCLGdCQUFnQixxRUFBTztBQUN2QjtBQUNBO0FBQ0EsZ0JBQWdCLHFFQUFPO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIscUVBQWlCO0FBQ3hDO0FBQ0Esb0JBQW9CLHFFQUF1Qiw4QkFBOEIscUVBQWdCLE9BQU8saUVBQVU7QUFDMUc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsS0FBSztBQUN4RCxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBLGNBQWMscUVBQVM7QUFDdkI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxxRUFBTztBQUM3QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNENBQTRDLHFFQUFjO0FBQzFELDBFQUEwRSxxRUFBYyxhQUFhO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0RBQWtELHFFQUFxQjtBQUN2RTtBQUNBO0FBQ0EsdUNBQXVDLHFFQUF1QjtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFVBQVUsU0FBUyxxRUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFFQUFhO0FBQzdDLFFBQVE7QUFDUjtBQUNBLG9EQUFvRCxnQkFBZ0IsVUFBVSxTQUFTLDJCQUEyQixVQUFVLG1CQUFtQixRQUFRLE1BQU0sWUFBWTtBQUN6SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsNkNBQTZDO0FBQzdDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0IscUVBQWlCO0FBQ2hELG9CQUFvQixxRUFBZ0IsQ0FBQyxxRUFBYTtBQUNsRCxXQUFXLHFFQUFxQjtBQUNoQztBQUNBLG1DQUFtQztBQUNuQyxrQkFBa0I7QUFDbEIsY0FBYyxxRUFBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUVBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUVBQVM7QUFDcEI7QUFDQTtBQUNBLFdBQVcscUVBQWM7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sdUJBQXVCLHFFQUFxQjtBQUM1QyxzRUFBc0U7QUFDdEU7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsYUFBYSxxRUFBd0IscUNBQXFDLHNFQUFNO0FBQ2hGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFFQUFlLFNBQVM7QUFDOUM7QUFDQTtBQUNBLHNCQUFzQixxRUFBUztBQUMvQixrQkFBa0IscUVBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU0sRUFBRSxxRUFBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCLHFFQUFXO0FBQ2hDO0FBQ0EsNEJBQTRCLHFFQUFTO0FBQ3JDO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCLCtCQUErQixRQUFRO0FBQ25HO0FBQ0EsV0FBVyxxRUFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUVBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMscUVBQXNCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxRUFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsOERBQThELGNBQWM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUVBQXFCO0FBQ2xEO0FBQ0E7QUFDQSx5QkFBeUIscUVBQWdCLENBQUMscUVBQWE7QUFDdkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGlFQUFZO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3Jpc3AtY2xlYW5pbmcvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvU3RhdGVNYWNoaW5lLTUzNDc5NTI4LmRldmVsb3BtZW50LmVzbS5qcz83NjEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFMgYXMgU1RBVEVfREVMSU1JVEVSLCBxIGFzIG1hcFZhbHVlcywgdCBhcyB0b0FycmF5LCB1IGFzIGZvcm1hdFRyYW5zaXRpb25zLCB2IGFzIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5LCB3IGFzIGZvcm1hdFRyYW5zaXRpb24sIE4gYXMgTlVMTF9FVkVOVCwgeCBhcyBldmFsdWF0ZUd1YXJkLCB5IGFzIGNyZWF0ZUludm9rZUlkLCB6IGFzIGdldERlbGF5ZWRUcmFuc2l0aW9ucywgQiBhcyBmb3JtYXRJbml0aWFsVHJhbnNpdGlvbiwgQyBhcyBnZXRDYW5kaWRhdGVzLCBEIGFzIHJlc29sdmVTdGF0ZVZhbHVlLCBFIGFzIGdldEFsbFN0YXRlTm9kZXMsIGcgYXMgZ2V0U3RhdGVOb2RlcywgRiBhcyBjcmVhdGVNYWNoaW5lU25hcHNob3QsIEcgYXMgaXNJbkZpbmFsU3RhdGUsIEggYXMgbWFjcm9zdGVwLCBJIGFzIHRyYW5zaXRpb25Ob2RlLCBKIGFzIHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dCwgSyBhcyBjcmVhdGVJbml0RXZlbnQsIEwgYXMgbWljcm9zdGVwLCBNIGFzIGdldEluaXRpYWxTdGF0ZU5vZGVzLCBPIGFzIHRvU3RhdGVQYXRoLCBQIGFzIGlzU3RhdGVJZCwgUSBhcyBnZXRTdGF0ZU5vZGVCeVBhdGgsIFIgYXMgZ2V0UGVyc2lzdGVkU25hcHNob3QsIFQgYXMgcmVzb2x2ZVJlZmVyZW5jZWRBY3RvciwgYyBhcyBjcmVhdGVBY3RvciwgJCBhcyAkJEFDVE9SX1RZUEUgfSBmcm9tICcuL3JhaXNlLTIzNWZhMGM3LmRldmVsb3BtZW50LmVzbS5qcyc7XG5pbXBvcnQgeyBhIGFzIGFzc2lnbiB9IGZyb20gJy4vYXNzaWduLWVmMWI2MmY2LmRldmVsb3BtZW50LmVzbS5qcyc7XG5cbmNvbnN0IGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIG1lbW8ob2JqZWN0LCBrZXksIGZuKSB7XG4gIGxldCBtZW1vaXplZERhdGEgPSBjYWNoZS5nZXQob2JqZWN0KTtcbiAgaWYgKCFtZW1vaXplZERhdGEpIHtcbiAgICBtZW1vaXplZERhdGEgPSB7XG4gICAgICBba2V5XTogZm4oKVxuICAgIH07XG4gICAgY2FjaGUuc2V0KG9iamVjdCwgbWVtb2l6ZWREYXRhKTtcbiAgfSBlbHNlIGlmICghKGtleSBpbiBtZW1vaXplZERhdGEpKSB7XG4gICAgbWVtb2l6ZWREYXRhW2tleV0gPSBmbigpO1xuICB9XG4gIHJldHVybiBtZW1vaXplZERhdGFba2V5XTtcbn1cblxuY29uc3QgRU1QVFlfT0JKRUNUID0ge307XG5jb25zdCB0b1NlcmlhbGl6YWJsZUFjdGlvbiA9IGFjdGlvbiA9PiB7XG4gIGlmICh0eXBlb2YgYWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBhY3Rpb25cbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKCdyZXNvbHZlJyBpbiBhY3Rpb24pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGFjdGlvbi50eXBlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogYWN0aW9uLm5hbWVcbiAgICB9O1xuICB9XG4gIHJldHVybiBhY3Rpb247XG59O1xuY2xhc3MgU3RhdGVOb2RlIHtcbiAgY29uc3RydWN0b3IoLyoqIFRoZSByYXcgY29uZmlnIHVzZWQgdG8gY3JlYXRlIHRoZSBtYWNoaW5lLiAqL1xuICBjb25maWcsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAvKipcbiAgICAgKiBUaGUgcmVsYXRpdmUga2V5IG9mIHRoZSBzdGF0ZSBub2RlLCB3aGljaCByZXByZXNlbnRzIGl0cyBsb2NhdGlvbiBpbiB0aGVcbiAgICAgKiBvdmVyYWxsIHN0YXRlIHZhbHVlLlxuICAgICAqL1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBzdGF0ZSBub2RlLiAqL1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhpcyBzdGF0ZSBub2RlOlxuICAgICAqXG4gICAgICogLSBgJ2F0b21pYydgIC0gbm8gY2hpbGQgc3RhdGUgbm9kZXNcbiAgICAgKiAtIGAnY29tcG91bmQnYCAtIG5lc3RlZCBjaGlsZCBzdGF0ZSBub2RlcyAoWE9SKVxuICAgICAqIC0gYCdwYXJhbGxlbCdgIC0gb3J0aG9nb25hbCBuZXN0ZWQgY2hpbGQgc3RhdGUgbm9kZXMgKEFORClcbiAgICAgKiAtIGAnaGlzdG9yeSdgIC0gaGlzdG9yeSBzdGF0ZSBub2RlXG4gICAgICogLSBgJ2ZpbmFsJ2AgLSBmaW5hbCBzdGF0ZSBub2RlXG4gICAgICovXG4gICAgdGhpcy50eXBlID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgc3RyaW5nIHBhdGggZnJvbSB0aGUgcm9vdCBtYWNoaW5lIG5vZGUgdG8gdGhpcyBub2RlLiAqL1xuICAgIHRoaXMucGF0aCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIGNoaWxkIHN0YXRlIG5vZGVzLiAqL1xuICAgIHRoaXMuc3RhdGVzID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIGhpc3Rvcnkgb24gdGhpcyBzdGF0ZSBub2RlLiBDYW4gYmU6XG4gICAgICpcbiAgICAgKiAtIGAnc2hhbGxvdydgIC0gcmVjYWxscyBvbmx5IHRvcC1sZXZlbCBoaXN0b3JpY2FsIHN0YXRlIHZhbHVlXG4gICAgICogLSBgJ2RlZXAnYCAtIHJlY2FsbHMgaGlzdG9yaWNhbCBzdGF0ZSB2YWx1ZSBhdCBhbGwgbGV2ZWxzXG4gICAgICovXG4gICAgdGhpcy5oaXN0b3J5ID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgYWN0aW9uKHMpIHRvIGJlIGV4ZWN1dGVkIHVwb24gZW50ZXJpbmcgdGhlIHN0YXRlIG5vZGUuICovXG4gICAgdGhpcy5lbnRyeSA9IHZvaWQgMDtcbiAgICAvKiogVGhlIGFjdGlvbihzKSB0byBiZSBleGVjdXRlZCB1cG9uIGV4aXRpbmcgdGhlIHN0YXRlIG5vZGUuICovXG4gICAgdGhpcy5leGl0ID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgcGFyZW50IHN0YXRlIG5vZGUuICovXG4gICAgdGhpcy5wYXJlbnQgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSByb290IG1hY2hpbmUgbm9kZS4gKi9cbiAgICB0aGlzLm1hY2hpbmUgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGEgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyBzdGF0ZSBub2RlLCB3aGljaCB3aWxsIGJlIHJldHVybmVkIGluXG4gICAgICogU3RhdGUgaW5zdGFuY2VzLlxuICAgICAqL1xuICAgIHRoaXMubWV0YSA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgb3V0cHV0IGRhdGEgc2VudCB3aXRoIHRoZSBcInhzdGF0ZS5kb25lLnN0YXRlLl9pZF9cIiBldmVudCBpZiB0aGlzIGlzIGFcbiAgICAgKiBmaW5hbCBzdGF0ZSBub2RlLlxuICAgICAqL1xuICAgIHRoaXMub3V0cHV0ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBvcmRlciB0aGlzIHN0YXRlIG5vZGUgYXBwZWFycy4gQ29ycmVzcG9uZHMgdG8gdGhlIGltcGxpY2l0IGRvY3VtZW50XG4gICAgICogb3JkZXIuXG4gICAgICovXG4gICAgdGhpcy5vcmRlciA9IC0xO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy50YWdzID0gW107XG4gICAgdGhpcy50cmFuc2l0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmFsd2F5cyA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcmVudCA9IG9wdGlvbnMuX3BhcmVudDtcbiAgICB0aGlzLmtleSA9IG9wdGlvbnMuX2tleTtcbiAgICB0aGlzLm1hY2hpbmUgPSBvcHRpb25zLl9tYWNoaW5lO1xuICAgIHRoaXMucGF0aCA9IHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQucGF0aC5jb25jYXQodGhpcy5rZXkpIDogW107XG4gICAgdGhpcy5pZCA9IHRoaXMuY29uZmlnLmlkIHx8IFt0aGlzLm1hY2hpbmUuaWQsIC4uLnRoaXMucGF0aF0uam9pbihTVEFURV9ERUxJTUlURVIpO1xuICAgIHRoaXMudHlwZSA9IHRoaXMuY29uZmlnLnR5cGUgfHwgKHRoaXMuY29uZmlnLnN0YXRlcyAmJiBPYmplY3Qua2V5cyh0aGlzLmNvbmZpZy5zdGF0ZXMpLmxlbmd0aCA/ICdjb21wb3VuZCcgOiB0aGlzLmNvbmZpZy5oaXN0b3J5ID8gJ2hpc3RvcnknIDogJ2F0b21pYycpO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSB0aGlzLmNvbmZpZy5kZXNjcmlwdGlvbjtcbiAgICB0aGlzLm9yZGVyID0gdGhpcy5tYWNoaW5lLmlkTWFwLnNpemU7XG4gICAgdGhpcy5tYWNoaW5lLmlkTWFwLnNldCh0aGlzLmlkLCB0aGlzKTtcbiAgICB0aGlzLnN0YXRlcyA9IHRoaXMuY29uZmlnLnN0YXRlcyA/IG1hcFZhbHVlcyh0aGlzLmNvbmZpZy5zdGF0ZXMsIChzdGF0ZUNvbmZpZywga2V5KSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZU5vZGUgPSBuZXcgU3RhdGVOb2RlKHN0YXRlQ29uZmlnLCB7XG4gICAgICAgIF9wYXJlbnQ6IHRoaXMsXG4gICAgICAgIF9rZXk6IGtleSxcbiAgICAgICAgX21hY2hpbmU6IHRoaXMubWFjaGluZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc3RhdGVOb2RlO1xuICAgIH0pIDogRU1QVFlfT0JKRUNUO1xuICAgIGlmICh0aGlzLnR5cGUgPT09ICdjb21wb3VuZCcgJiYgIXRoaXMuY29uZmlnLmluaXRpYWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gaW5pdGlhbCBzdGF0ZSBzcGVjaWZpZWQgZm9yIGNvbXBvdW5kIHN0YXRlIG5vZGUgXCIjJHt0aGlzLmlkfVwiLiBUcnkgYWRkaW5nIHsgaW5pdGlhbDogXCIke09iamVjdC5rZXlzKHRoaXMuc3RhdGVzKVswXX1cIiB9IHRvIHRoZSBzdGF0ZSBjb25maWcuYCk7XG4gICAgfVxuXG4gICAgLy8gSGlzdG9yeSBjb25maWdcbiAgICB0aGlzLmhpc3RvcnkgPSB0aGlzLmNvbmZpZy5oaXN0b3J5ID09PSB0cnVlID8gJ3NoYWxsb3cnIDogdGhpcy5jb25maWcuaGlzdG9yeSB8fCBmYWxzZTtcbiAgICB0aGlzLmVudHJ5ID0gdG9BcnJheSh0aGlzLmNvbmZpZy5lbnRyeSkuc2xpY2UoKTtcbiAgICB0aGlzLmV4aXQgPSB0b0FycmF5KHRoaXMuY29uZmlnLmV4aXQpLnNsaWNlKCk7XG4gICAgdGhpcy5tZXRhID0gdGhpcy5jb25maWcubWV0YTtcbiAgICB0aGlzLm91dHB1dCA9IHRoaXMudHlwZSA9PT0gJ2ZpbmFsJyB8fCAhdGhpcy5wYXJlbnQgPyB0aGlzLmNvbmZpZy5vdXRwdXQgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy50YWdzID0gdG9BcnJheShjb25maWcudGFncykuc2xpY2UoKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy50cmFuc2l0aW9ucyA9IGZvcm1hdFRyYW5zaXRpb25zKHRoaXMpO1xuICAgIGlmICh0aGlzLmNvbmZpZy5hbHdheXMpIHtcbiAgICAgIHRoaXMuYWx3YXlzID0gdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkodGhpcy5jb25maWcuYWx3YXlzKS5tYXAodCA9PiBmb3JtYXRUcmFuc2l0aW9uKHRoaXMsIE5VTExfRVZFTlQsIHQpKTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXModGhpcy5zdGF0ZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHRoaXMuc3RhdGVzW2tleV0uX2luaXRpYWxpemUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBUaGUgd2VsbC1zdHJ1Y3R1cmVkIHN0YXRlIG5vZGUgZGVmaW5pdGlvbi4gKi9cbiAgZ2V0IGRlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgIHZlcnNpb246IHRoaXMubWFjaGluZS52ZXJzaW9uLFxuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgaW5pdGlhbDogdGhpcy5pbml0aWFsID8ge1xuICAgICAgICB0YXJnZXQ6IHRoaXMuaW5pdGlhbC50YXJnZXQsXG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgYWN0aW9uczogdGhpcy5pbml0aWFsLmFjdGlvbnMubWFwKHRvU2VyaWFsaXphYmxlQWN0aW9uKSxcbiAgICAgICAgZXZlbnRUeXBlOiBudWxsLFxuICAgICAgICByZWVudGVyOiBmYWxzZSxcbiAgICAgICAgdG9KU09OOiAoKSA9PiAoe1xuICAgICAgICAgIHRhcmdldDogdGhpcy5pbml0aWFsLnRhcmdldC5tYXAodCA9PiBgIyR7dC5pZH1gKSxcbiAgICAgICAgICBzb3VyY2U6IGAjJHt0aGlzLmlkfWAsXG4gICAgICAgICAgYWN0aW9uczogdGhpcy5pbml0aWFsLmFjdGlvbnMubWFwKHRvU2VyaWFsaXphYmxlQWN0aW9uKSxcbiAgICAgICAgICBldmVudFR5cGU6IG51bGxcbiAgICAgICAgfSlcbiAgICAgIH0gOiB1bmRlZmluZWQsXG4gICAgICBoaXN0b3J5OiB0aGlzLmhpc3RvcnksXG4gICAgICBzdGF0ZXM6IG1hcFZhbHVlcyh0aGlzLnN0YXRlcywgc3RhdGUgPT4ge1xuICAgICAgICByZXR1cm4gc3RhdGUuZGVmaW5pdGlvbjtcbiAgICAgIH0pLFxuICAgICAgb246IHRoaXMub24sXG4gICAgICB0cmFuc2l0aW9uczogWy4uLnRoaXMudHJhbnNpdGlvbnMudmFsdWVzKCldLmZsYXQoKS5tYXAodCA9PiAoe1xuICAgICAgICAuLi50LFxuICAgICAgICBhY3Rpb25zOiB0LmFjdGlvbnMubWFwKHRvU2VyaWFsaXphYmxlQWN0aW9uKVxuICAgICAgfSkpLFxuICAgICAgZW50cnk6IHRoaXMuZW50cnkubWFwKHRvU2VyaWFsaXphYmxlQWN0aW9uKSxcbiAgICAgIGV4aXQ6IHRoaXMuZXhpdC5tYXAodG9TZXJpYWxpemFibGVBY3Rpb24pLFxuICAgICAgbWV0YTogdGhpcy5tZXRhLFxuICAgICAgb3JkZXI6IHRoaXMub3JkZXIgfHwgLTEsXG4gICAgICBvdXRwdXQ6IHRoaXMub3V0cHV0LFxuICAgICAgaW52b2tlOiB0aGlzLmludm9rZSxcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgdGFnczogdGhpcy50YWdzXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluaXRpb247XG4gIH1cblxuICAvKiogVGhlIGxvZ2ljIGludm9rZWQgYXMgYWN0b3JzIGJ5IHRoaXMgc3RhdGUgbm9kZS4gKi9cbiAgZ2V0IGludm9rZSgpIHtcbiAgICByZXR1cm4gbWVtbyh0aGlzLCAnaW52b2tlJywgKCkgPT4gdG9BcnJheSh0aGlzLmNvbmZpZy5pbnZva2UpLm1hcCgoaW52b2tlQ29uZmlnLCBpKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNyYyxcbiAgICAgICAgc3lzdGVtSWRcbiAgICAgIH0gPSBpbnZva2VDb25maWc7XG4gICAgICBjb25zdCByZXNvbHZlZElkID0gaW52b2tlQ29uZmlnLmlkID8/IGNyZWF0ZUludm9rZUlkKHRoaXMuaWQsIGkpO1xuICAgICAgY29uc3Qgc291cmNlTmFtZSA9IHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnID8gc3JjIDogYHhzdGF0ZS5pbnZva2UuJHtjcmVhdGVJbnZva2VJZCh0aGlzLmlkLCBpKX1gO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaW52b2tlQ29uZmlnLFxuICAgICAgICBzcmM6IHNvdXJjZU5hbWUsXG4gICAgICAgIGlkOiByZXNvbHZlZElkLFxuICAgICAgICBzeXN0ZW1JZDogc3lzdGVtSWQsXG4gICAgICAgIHRvSlNPTigpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBvbkRvbmUsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgLi4uaW52b2tlRGVmVmFsdWVzXG4gICAgICAgICAgfSA9IGludm9rZUNvbmZpZztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uaW52b2tlRGVmVmFsdWVzLFxuICAgICAgICAgICAgdHlwZTogJ3hzdGF0ZS5pbnZva2UnLFxuICAgICAgICAgICAgc3JjOiBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgaWQ6IHJlc29sdmVkSWRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKTtcbiAgfVxuXG4gIC8qKiBUaGUgbWFwcGluZyBvZiBldmVudHMgdG8gdHJhbnNpdGlvbnMuICovXG4gIGdldCBvbigpIHtcbiAgICByZXR1cm4gbWVtbyh0aGlzLCAnb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2l0aW9ucyA9IHRoaXMudHJhbnNpdGlvbnM7XG4gICAgICByZXR1cm4gWy4uLnRyYW5zaXRpb25zXS5mbGF0TWFwKChbZGVzY3JpcHRvciwgdF0pID0+IHQubWFwKHQgPT4gW2Rlc2NyaXB0b3IsIHRdKSkucmVkdWNlKChtYXAsIFtkZXNjcmlwdG9yLCB0cmFuc2l0aW9uXSkgPT4ge1xuICAgICAgICBtYXBbZGVzY3JpcHRvcl0gPSBtYXBbZGVzY3JpcHRvcl0gfHwgW107XG4gICAgICAgIG1hcFtkZXNjcmlwdG9yXS5wdXNoKHRyYW5zaXRpb24pO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgfSwge30pO1xuICAgIH0pO1xuICB9XG4gIGdldCBhZnRlcigpIHtcbiAgICByZXR1cm4gbWVtbyh0aGlzLCAnZGVsYXllZFRyYW5zaXRpb25zJywgKCkgPT4gZ2V0RGVsYXllZFRyYW5zaXRpb25zKHRoaXMpKTtcbiAgfVxuICBnZXQgaW5pdGlhbCgpIHtcbiAgICByZXR1cm4gbWVtbyh0aGlzLCAnaW5pdGlhbCcsICgpID0+IGZvcm1hdEluaXRpYWxUcmFuc2l0aW9uKHRoaXMsIHRoaXMuY29uZmlnLmluaXRpYWwpKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgbmV4dChzbmFwc2hvdCwgZXZlbnQpIHtcbiAgICBjb25zdCBldmVudFR5cGUgPSBldmVudC50eXBlO1xuICAgIGNvbnN0IGFjdGlvbnMgPSBbXTtcbiAgICBsZXQgc2VsZWN0ZWRUcmFuc2l0aW9uO1xuICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBtZW1vKHRoaXMsIGBjYW5kaWRhdGVzLSR7ZXZlbnRUeXBlfWAsICgpID0+IGdldENhbmRpZGF0ZXModGhpcywgZXZlbnRUeXBlKSk7XG4gICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgY2FuZGlkYXRlcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBndWFyZFxuICAgICAgfSA9IGNhbmRpZGF0ZTtcbiAgICAgIGNvbnN0IHJlc29sdmVkQ29udGV4dCA9IHNuYXBzaG90LmNvbnRleHQ7XG4gICAgICBsZXQgZ3VhcmRQYXNzZWQgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGd1YXJkUGFzc2VkID0gIWd1YXJkIHx8IGV2YWx1YXRlR3VhcmQoZ3VhcmQsIHJlc29sdmVkQ29udGV4dCwgZXZlbnQsIHNuYXBzaG90KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBndWFyZFR5cGUgPSB0eXBlb2YgZ3VhcmQgPT09ICdzdHJpbmcnID8gZ3VhcmQgOiB0eXBlb2YgZ3VhcmQgPT09ICdvYmplY3QnID8gZ3VhcmQudHlwZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZXZhbHVhdGUgZ3VhcmQgJHtndWFyZFR5cGUgPyBgJyR7Z3VhcmRUeXBlfScgYCA6ICcnfWluIHRyYW5zaXRpb24gZm9yIGV2ZW50ICcke2V2ZW50VHlwZX0nIGluIHN0YXRlIG5vZGUgJyR7dGhpcy5pZH0nOlxcbiR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmRQYXNzZWQpIHtcbiAgICAgICAgYWN0aW9ucy5wdXNoKC4uLmNhbmRpZGF0ZS5hY3Rpb25zKTtcbiAgICAgICAgc2VsZWN0ZWRUcmFuc2l0aW9uID0gY2FuZGlkYXRlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkVHJhbnNpdGlvbiA/IFtzZWxlY3RlZFRyYW5zaXRpb25dIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqIEFsbCB0aGUgZXZlbnQgdHlwZXMgYWNjZXB0ZWQgYnkgdGhpcyBzdGF0ZSBub2RlIGFuZCBpdHMgZGVzY2VuZGFudHMuICovXG4gIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIG1lbW8odGhpcywgJ2V2ZW50cycsICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhdGVzXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGV2ZW50cyA9IG5ldyBTZXQodGhpcy5vd25FdmVudHMpO1xuICAgICAgaWYgKHN0YXRlcykge1xuICAgICAgICBmb3IgKGNvbnN0IHN0YXRlSWQgb2YgT2JqZWN0LmtleXMoc3RhdGVzKSkge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RhdGVzW3N0YXRlSWRdO1xuICAgICAgICAgIGlmIChzdGF0ZS5zdGF0ZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2Ygc3RhdGUuZXZlbnRzKSB7XG4gICAgICAgICAgICAgIGV2ZW50cy5hZGQoYCR7ZXZlbnR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShldmVudHMpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbCB0aGUgZXZlbnRzIHRoYXQgaGF2ZSB0cmFuc2l0aW9ucyBkaXJlY3RseSBmcm9tIHRoaXMgc3RhdGUgbm9kZS5cbiAgICpcbiAgICogRXhjbHVkZXMgYW55IGluZXJ0IGV2ZW50cy5cbiAgICovXG4gIGdldCBvd25FdmVudHMoKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKE9iamVjdC5mcm9tRW50cmllcyh0aGlzLnRyYW5zaXRpb25zKSk7XG4gICAgY29uc3QgZXZlbnRzID0gbmV3IFNldChrZXlzLmZpbHRlcihkZXNjcmlwdG9yID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25zLmdldChkZXNjcmlwdG9yKS5zb21lKHRyYW5zaXRpb24gPT4gISghdHJhbnNpdGlvbi50YXJnZXQgJiYgIXRyYW5zaXRpb24uYWN0aW9ucy5sZW5ndGggJiYgIXRyYW5zaXRpb24ucmVlbnRlcikpO1xuICAgIH0pKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShldmVudHMpO1xuICB9XG59XG5cbmNvbnN0IFNUQVRFX0lERU5USUZJRVIgPSAnIyc7XG5jbGFzcyBTdGF0ZU1hY2hpbmUge1xuICBjb25zdHJ1Y3RvcigvKiogVGhlIHJhdyBjb25maWcgdXNlZCB0byBjcmVhdGUgdGhlIG1hY2hpbmUuICovXG4gIGNvbmZpZywgaW1wbGVtZW50YXRpb25zKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgLyoqIFRoZSBtYWNoaW5lJ3Mgb3duIHZlcnNpb24uICovXG4gICAgdGhpcy52ZXJzaW9uID0gdm9pZCAwO1xuICAgIHRoaXMuc2NoZW1hcyA9IHZvaWQgMDtcbiAgICB0aGlzLmltcGxlbWVudGF0aW9ucyA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fX3hzdGF0ZW5vZGUgPSB0cnVlO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLmlkTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucm9vdCA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhdGVzID0gdm9pZCAwO1xuICAgIHRoaXMuZXZlbnRzID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSBjb25maWcuaWQgfHwgJyhtYWNoaW5lKSc7XG4gICAgdGhpcy5pbXBsZW1lbnRhdGlvbnMgPSB7XG4gICAgICBhY3RvcnM6IGltcGxlbWVudGF0aW9ucz8uYWN0b3JzID8/IHt9LFxuICAgICAgYWN0aW9uczogaW1wbGVtZW50YXRpb25zPy5hY3Rpb25zID8/IHt9LFxuICAgICAgZGVsYXlzOiBpbXBsZW1lbnRhdGlvbnM/LmRlbGF5cyA/PyB7fSxcbiAgICAgIGd1YXJkczogaW1wbGVtZW50YXRpb25zPy5ndWFyZHMgPz8ge31cbiAgICB9O1xuICAgIHRoaXMudmVyc2lvbiA9IHRoaXMuY29uZmlnLnZlcnNpb247XG4gICAgdGhpcy5zY2hlbWFzID0gdGhpcy5jb25maWcuc2NoZW1hcztcbiAgICB0aGlzLnRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb24uYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldEluaXRpYWxTbmFwc2hvdCA9IHRoaXMuZ2V0SW5pdGlhbFNuYXBzaG90LmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRQZXJzaXN0ZWRTbmFwc2hvdCA9IHRoaXMuZ2V0UGVyc2lzdGVkU25hcHNob3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlc3RvcmVTbmFwc2hvdCA9IHRoaXMucmVzdG9yZVNuYXBzaG90LmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdGFydCA9IHRoaXMuc3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnJvb3QgPSBuZXcgU3RhdGVOb2RlKGNvbmZpZywge1xuICAgICAgX2tleTogdGhpcy5pZCxcbiAgICAgIF9tYWNoaW5lOiB0aGlzXG4gICAgfSk7XG4gICAgdGhpcy5yb290Ll9pbml0aWFsaXplKCk7XG4gICAgdGhpcy5zdGF0ZXMgPSB0aGlzLnJvb3Quc3RhdGVzOyAvLyBUT0RPOiByZW1vdmUhXG4gICAgdGhpcy5ldmVudHMgPSB0aGlzLnJvb3QuZXZlbnRzO1xuICAgIGlmICghKCdvdXRwdXQnIGluIHRoaXMucm9vdCkgJiYgT2JqZWN0LnZhbHVlcyh0aGlzLnN0YXRlcykuc29tZShzdGF0ZSA9PiBzdGF0ZS50eXBlID09PSAnZmluYWwnICYmICdvdXRwdXQnIGluIHN0YXRlKSkge1xuICAgICAgY29uc29sZS53YXJuKCdNaXNzaW5nIGBtYWNoaW5lLm91dHB1dGAgZGVjbGFyYXRpb24gKHRvcC1sZXZlbCBmaW5hbCBzdGF0ZSB3aXRoIG91dHB1dCBkZXRlY3RlZCknKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIHRoaXMgc3RhdGUgbWFjaGluZSB3aXRoIHRoZSBwcm92aWRlZCBpbXBsZW1lbnRhdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBpbXBsZW1lbnRhdGlvbnMgT3B0aW9ucyAoYGFjdGlvbnNgLCBgZ3VhcmRzYCwgYGFjdG9yc2AsIGBkZWxheXNgKSB0b1xuICAgKiAgIHJlY3Vyc2l2ZWx5IG1lcmdlIHdpdGggdGhlIGV4aXN0aW5nIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIEEgbmV3IGBTdGF0ZU1hY2hpbmVgIGluc3RhbmNlIHdpdGggdGhlIHByb3ZpZGVkIGltcGxlbWVudGF0aW9ucy5cbiAgICovXG4gIHByb3ZpZGUoaW1wbGVtZW50YXRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgYWN0aW9ucyxcbiAgICAgIGd1YXJkcyxcbiAgICAgIGFjdG9ycyxcbiAgICAgIGRlbGF5c1xuICAgIH0gPSB0aGlzLmltcGxlbWVudGF0aW9ucztcbiAgICByZXR1cm4gbmV3IFN0YXRlTWFjaGluZSh0aGlzLmNvbmZpZywge1xuICAgICAgYWN0aW9uczoge1xuICAgICAgICAuLi5hY3Rpb25zLFxuICAgICAgICAuLi5pbXBsZW1lbnRhdGlvbnMuYWN0aW9uc1xuICAgICAgfSxcbiAgICAgIGd1YXJkczoge1xuICAgICAgICAuLi5ndWFyZHMsXG4gICAgICAgIC4uLmltcGxlbWVudGF0aW9ucy5ndWFyZHNcbiAgICAgIH0sXG4gICAgICBhY3RvcnM6IHtcbiAgICAgICAgLi4uYWN0b3JzLFxuICAgICAgICAuLi5pbXBsZW1lbnRhdGlvbnMuYWN0b3JzXG4gICAgICB9LFxuICAgICAgZGVsYXlzOiB7XG4gICAgICAgIC4uLmRlbGF5cyxcbiAgICAgICAgLi4uaW1wbGVtZW50YXRpb25zLmRlbGF5c1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlc29sdmVTdGF0ZShjb25maWcpIHtcbiAgICBjb25zdCByZXNvbHZlZFN0YXRlVmFsdWUgPSByZXNvbHZlU3RhdGVWYWx1ZSh0aGlzLnJvb3QsIGNvbmZpZy52YWx1ZSk7XG4gICAgY29uc3Qgbm9kZVNldCA9IGdldEFsbFN0YXRlTm9kZXMoZ2V0U3RhdGVOb2Rlcyh0aGlzLnJvb3QsIHJlc29sdmVkU3RhdGVWYWx1ZSkpO1xuICAgIHJldHVybiBjcmVhdGVNYWNoaW5lU25hcHNob3Qoe1xuICAgICAgX25vZGVzOiBbLi4ubm9kZVNldF0sXG4gICAgICBjb250ZXh0OiBjb25maWcuY29udGV4dCB8fCB7fSxcbiAgICAgIGNoaWxkcmVuOiB7fSxcbiAgICAgIHN0YXR1czogaXNJbkZpbmFsU3RhdGUobm9kZVNldCwgdGhpcy5yb290KSA/ICdkb25lJyA6IGNvbmZpZy5zdGF0dXMgfHwgJ2FjdGl2ZScsXG4gICAgICBvdXRwdXQ6IGNvbmZpZy5vdXRwdXQsXG4gICAgICBlcnJvcjogY29uZmlnLmVycm9yLFxuICAgICAgaGlzdG9yeVZhbHVlOiBjb25maWcuaGlzdG9yeVZhbHVlXG4gICAgfSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgbmV4dCBzbmFwc2hvdCBnaXZlbiB0aGUgY3VycmVudCBgc25hcHNob3RgIGFuZCByZWNlaXZlZFxuICAgKiBgZXZlbnRgLiBDYWxjdWxhdGVzIGEgZnVsbCBtYWNyb3N0ZXAgZnJvbSBhbGwgbWljcm9zdGVwcy5cbiAgICpcbiAgICogQHBhcmFtIHNuYXBzaG90IFRoZSBjdXJyZW50IHNuYXBzaG90XG4gICAqIEBwYXJhbSBldmVudCBUaGUgcmVjZWl2ZWQgZXZlbnRcbiAgICovXG4gIHRyYW5zaXRpb24oc25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlKSB7XG4gICAgcmV0dXJuIG1hY3Jvc3RlcChzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIFtdKS5zbmFwc2hvdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBuZXh0IHN0YXRlIGdpdmVuIHRoZSBjdXJyZW50IGBzdGF0ZWAgYW5kIGBldmVudGAuIENhbGN1bGF0ZXNcbiAgICogYSBtaWNyb3N0ZXAuXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZSBUaGUgY3VycmVudCBzdGF0ZVxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIHJlY2VpdmVkIGV2ZW50XG4gICAqL1xuICBtaWNyb3N0ZXAoc25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlKSB7XG4gICAgcmV0dXJuIG1hY3Jvc3RlcChzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIFtdKS5taWNyb3N0YXRlcztcbiAgfVxuICBnZXRUcmFuc2l0aW9uRGF0YShzbmFwc2hvdCwgZXZlbnQpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk5vZGUodGhpcy5yb290LCBzbmFwc2hvdC52YWx1ZSwgc25hcHNob3QsIGV2ZW50KSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaW5pdGlhbCBzdGF0ZSBfYmVmb3JlXyBldmFsdWF0aW5nIGFueSBtaWNyb3N0ZXBzLiBUaGlzIFwicHJlLWluaXRpYWxcIlxuICAgKiBzdGF0ZSBpcyBwcm92aWRlZCB0byBpbml0aWFsIGFjdGlvbnMgZXhlY3V0ZWQgaW4gdGhlIGluaXRpYWwgc3RhdGUuXG4gICAqL1xuICBnZXRQcmVJbml0aWFsU3RhdGUoYWN0b3JTY29wZSwgaW5pdEV2ZW50LCBpbnRlcm5hbFF1ZXVlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dFxuICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBwcmVJbml0aWFsID0gY3JlYXRlTWFjaGluZVNuYXBzaG90KHtcbiAgICAgIGNvbnRleHQ6IHR5cGVvZiBjb250ZXh0ICE9PSAnZnVuY3Rpb24nICYmIGNvbnRleHQgPyBjb250ZXh0IDoge30sXG4gICAgICBfbm9kZXM6IFt0aGlzLnJvb3RdLFxuICAgICAgY2hpbGRyZW46IHt9LFxuICAgICAgc3RhdHVzOiAnYWN0aXZlJ1xuICAgIH0sIHRoaXMpO1xuICAgIGlmICh0eXBlb2YgY29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgYXNzaWdubWVudCA9ICh7XG4gICAgICAgIHNwYXduLFxuICAgICAgICBldmVudCxcbiAgICAgICAgc2VsZlxuICAgICAgfSkgPT4gY29udGV4dCh7XG4gICAgICAgIHNwYXduLFxuICAgICAgICBpbnB1dDogZXZlbnQuaW5wdXQsXG4gICAgICAgIHNlbGZcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dChwcmVJbml0aWFsLCBpbml0RXZlbnQsIGFjdG9yU2NvcGUsIFthc3NpZ24oYXNzaWdubWVudCldLCBpbnRlcm5hbFF1ZXVlLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcHJlSW5pdGlhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsIGBTdGF0ZWAgaW5zdGFuY2UsIHdpdGggcmVmZXJlbmNlIHRvIGBzZWxmYCBhcyBhblxuICAgKiBgQWN0b3JSZWZgLlxuICAgKi9cbiAgZ2V0SW5pdGlhbFNuYXBzaG90KGFjdG9yU2NvcGUsIGlucHV0KSB7XG4gICAgY29uc3QgaW5pdEV2ZW50ID0gY3JlYXRlSW5pdEV2ZW50KGlucHV0KTsgLy8gVE9ETzogZml4O1xuICAgIGNvbnN0IGludGVybmFsUXVldWUgPSBbXTtcbiAgICBjb25zdCBwcmVJbml0aWFsU3RhdGUgPSB0aGlzLmdldFByZUluaXRpYWxTdGF0ZShhY3RvclNjb3BlLCBpbml0RXZlbnQsIGludGVybmFsUXVldWUpO1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9IG1pY3Jvc3RlcChbe1xuICAgICAgdGFyZ2V0OiBbLi4uZ2V0SW5pdGlhbFN0YXRlTm9kZXModGhpcy5yb290KV0sXG4gICAgICBzb3VyY2U6IHRoaXMucm9vdCxcbiAgICAgIHJlZW50ZXI6IHRydWUsXG4gICAgICBhY3Rpb25zOiBbXSxcbiAgICAgIGV2ZW50VHlwZTogbnVsbCxcbiAgICAgIHRvSlNPTjogbnVsbCAvLyBUT0RPOiBmaXhcbiAgICB9XSwgcHJlSW5pdGlhbFN0YXRlLCBhY3RvclNjb3BlLCBpbml0RXZlbnQsIHRydWUsIGludGVybmFsUXVldWUpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNuYXBzaG90OiBtYWNyb1N0YXRlXG4gICAgfSA9IG1hY3Jvc3RlcChuZXh0U3RhdGUsIGluaXRFdmVudCwgYWN0b3JTY29wZSwgaW50ZXJuYWxRdWV1ZSk7XG4gICAgcmV0dXJuIG1hY3JvU3RhdGU7XG4gIH1cbiAgc3RhcnQoc25hcHNob3QpIHtcbiAgICBPYmplY3QudmFsdWVzKHNuYXBzaG90LmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGlmIChjaGlsZC5nZXRTbmFwc2hvdCgpLnN0YXR1cyA9PT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgY2hpbGQuc3RhcnQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRTdGF0ZU5vZGVCeUlkKHN0YXRlSWQpIHtcbiAgICBjb25zdCBmdWxsUGF0aCA9IHRvU3RhdGVQYXRoKHN0YXRlSWQpO1xuICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IGZ1bGxQYXRoLnNsaWNlKDEpO1xuICAgIGNvbnN0IHJlc29sdmVkU3RhdGVJZCA9IGlzU3RhdGVJZChmdWxsUGF0aFswXSkgPyBmdWxsUGF0aFswXS5zbGljZShTVEFURV9JREVOVElGSUVSLmxlbmd0aCkgOiBmdWxsUGF0aFswXTtcbiAgICBjb25zdCBzdGF0ZU5vZGUgPSB0aGlzLmlkTWFwLmdldChyZXNvbHZlZFN0YXRlSWQpO1xuICAgIGlmICghc3RhdGVOb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENoaWxkIHN0YXRlIG5vZGUgJyMke3Jlc29sdmVkU3RhdGVJZH0nIGRvZXMgbm90IGV4aXN0IG9uIG1hY2hpbmUgJyR7dGhpcy5pZH0nYCk7XG4gICAgfVxuICAgIHJldHVybiBnZXRTdGF0ZU5vZGVCeVBhdGgoc3RhdGVOb2RlLCByZWxhdGl2ZVBhdGgpO1xuICB9XG4gIGdldCBkZWZpbml0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJvb3QuZGVmaW5pdGlvbjtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbjtcbiAgfVxuICBnZXRQZXJzaXN0ZWRTbmFwc2hvdChzbmFwc2hvdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRQZXJzaXN0ZWRTbmFwc2hvdChzbmFwc2hvdCwgb3B0aW9ucyk7XG4gIH1cbiAgcmVzdG9yZVNuYXBzaG90KHNuYXBzaG90LCBfYWN0b3JTY29wZSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0ge307XG4gICAgY29uc3Qgc25hcHNob3RDaGlsZHJlbiA9IHNuYXBzaG90LmNoaWxkcmVuO1xuICAgIE9iamVjdC5rZXlzKHNuYXBzaG90Q2hpbGRyZW4pLmZvckVhY2goYWN0b3JJZCA9PiB7XG4gICAgICBjb25zdCBhY3RvckRhdGEgPSBzbmFwc2hvdENoaWxkcmVuW2FjdG9ySWRdO1xuICAgICAgY29uc3QgY2hpbGRTdGF0ZSA9IGFjdG9yRGF0YS5zbmFwc2hvdDtcbiAgICAgIGNvbnN0IHNyYyA9IGFjdG9yRGF0YS5zcmM7XG4gICAgICBjb25zdCBsb2dpYyA9IHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnID8gcmVzb2x2ZVJlZmVyZW5jZWRBY3Rvcih0aGlzLCBzcmMpIDogc3JjO1xuICAgICAgaWYgKCFsb2dpYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhY3RvclJlZiA9IGNyZWF0ZUFjdG9yKGxvZ2ljLCB7XG4gICAgICAgIGlkOiBhY3RvcklkLFxuICAgICAgICBwYXJlbnQ6IF9hY3RvclNjb3BlLnNlbGYsXG4gICAgICAgIHN5bmNTbmFwc2hvdDogYWN0b3JEYXRhLnN5bmNTbmFwc2hvdCxcbiAgICAgICAgc25hcHNob3Q6IGNoaWxkU3RhdGUsXG4gICAgICAgIHNyYyxcbiAgICAgICAgc3lzdGVtSWQ6IGFjdG9yRGF0YS5zeXN0ZW1JZFxuICAgICAgfSk7XG4gICAgICBjaGlsZHJlblthY3RvcklkXSA9IGFjdG9yUmVmO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHJlc29sdmVIaXN0b3J5UmVmZXJlbmNlZFN0YXRlKHJvb3QsIHJlZmVyZW5jZWQpIHtcbiAgICAgIGlmIChyZWZlcmVuY2VkIGluc3RhbmNlb2YgU3RhdGVOb2RlKSB7XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VkO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJvb3QubWFjaGluZS5nZXRTdGF0ZU5vZGVCeUlkKHJlZmVyZW5jZWQuaWQpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCByZXNvbHZlIFN0YXRlTm9kZSBmb3IgaWQ6ICR7cmVmZXJlbmNlZC5pZH1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXZpdmVIaXN0b3J5VmFsdWUocm9vdCwgaGlzdG9yeVZhbHVlKSB7XG4gICAgICBpZiAoIWhpc3RvcnlWYWx1ZSB8fCB0eXBlb2YgaGlzdG9yeVZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBjb25zdCByZXZpdmVkID0ge307XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBoaXN0b3J5VmFsdWUpIHtcbiAgICAgICAgY29uc3QgYXJyID0gaGlzdG9yeVZhbHVlW2tleV07XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVIaXN0b3J5UmVmZXJlbmNlZFN0YXRlKHJvb3QsIGl0ZW0pO1xuICAgICAgICAgIGlmICghcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXZpdmVkW2tleV0gPz89IFtdO1xuICAgICAgICAgIHJldml2ZWRba2V5XS5wdXNoKHJlc29sdmVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldml2ZWQ7XG4gICAgfVxuICAgIGNvbnN0IHJldml2ZWRIaXN0b3J5VmFsdWUgPSByZXZpdmVIaXN0b3J5VmFsdWUodGhpcy5yb290LCBzbmFwc2hvdC5oaXN0b3J5VmFsdWUpO1xuICAgIGNvbnN0IHJlc3RvcmVkU25hcHNob3QgPSBjcmVhdGVNYWNoaW5lU25hcHNob3Qoe1xuICAgICAgLi4uc25hcHNob3QsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIF9ub2RlczogQXJyYXkuZnJvbShnZXRBbGxTdGF0ZU5vZGVzKGdldFN0YXRlTm9kZXModGhpcy5yb290LCBzbmFwc2hvdC52YWx1ZSkpKSxcbiAgICAgIGhpc3RvcnlWYWx1ZTogcmV2aXZlZEhpc3RvcnlWYWx1ZVxuICAgIH0sIHRoaXMpO1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgZnVuY3Rpb24gcmV2aXZlQ29udGV4dChjb250ZXh0UGFydCwgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChzZWVuLmhhcyhjb250ZXh0UGFydCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2Vlbi5hZGQoY29udGV4dFBhcnQpO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29udGV4dFBhcnQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjb250ZXh0UGFydFtrZXldO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmICgneHN0YXRlJCR0eXBlJyBpbiB2YWx1ZSAmJiB2YWx1ZS54c3RhdGUkJHR5cGUgPT09ICQkQUNUT1JfVFlQRSkge1xuICAgICAgICAgICAgY29udGV4dFBhcnRba2V5XSA9IGNoaWxkcmVuW3ZhbHVlLmlkXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXZpdmVDb250ZXh0KHZhbHVlLCBjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV2aXZlQ29udGV4dChyZXN0b3JlZFNuYXBzaG90LmNvbnRleHQsIGNoaWxkcmVuKTtcbiAgICByZXR1cm4gcmVzdG9yZWRTbmFwc2hvdDtcbiAgfVxufVxuXG5leHBvcnQgeyBTdGF0ZU1hY2hpbmUgYXMgUywgU3RhdGVOb2RlIGFzIGEgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/StateMachine-53479528.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/assign-ef1b62f6.development.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/xstate/dist/assign-ef1b62f6.development.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ assign)\n/* harmony export */ });\n/* harmony import */ var _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raise-235fa0c7.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-235fa0c7.development.esm.js\");\n\n\nfunction createSpawner(actorScope, {\n  machine,\n  context\n}, event, spawnedChildren) {\n  const spawn = (src, options) => {\n    if (typeof src === 'string') {\n      const logic = (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.T)(machine, src);\n      if (!logic) {\n        throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);\n      }\n      const actorRef = (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(logic, {\n        id: options?.id,\n        parent: actorScope.self,\n        syncSnapshot: options?.syncSnapshot,\n        input: typeof options?.input === 'function' ? options.input({\n          context,\n          event,\n          self: actorScope.self\n        }) : options?.input,\n        src,\n        systemId: options?.systemId\n      });\n      spawnedChildren[actorRef.id] = actorRef;\n      return actorRef;\n    } else {\n      const actorRef = (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(src, {\n        id: options?.id,\n        parent: actorScope.self,\n        syncSnapshot: options?.syncSnapshot,\n        input: options?.input,\n        src,\n        systemId: options?.systemId\n      });\n      return actorRef;\n    }\n  };\n  return (src, options) => {\n    const actorRef = spawn(src, options); // TODO: fix types\n    spawnedChildren[actorRef.id] = actorRef;\n    actorScope.defer(() => {\n      if (actorRef._processingStatus === _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.Y.Stopped) {\n        return;\n      }\n      actorRef.start();\n    });\n    return actorRef;\n  };\n}\n\nfunction resolveAssign(actorScope, snapshot, actionArgs, actionParams, {\n  assignment\n}) {\n  if (!snapshot.context) {\n    throw new Error('Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.');\n  }\n  const spawnedChildren = {};\n  const assignArgs = {\n    context: snapshot.context,\n    event: actionArgs.event,\n    spawn: createSpawner(actorScope, snapshot, actionArgs.event, spawnedChildren),\n    self: actorScope.self,\n    system: actorScope.system\n  };\n  let partialUpdate = {};\n  if (typeof assignment === 'function') {\n    partialUpdate = assignment(assignArgs, actionParams);\n  } else {\n    for (const key of Object.keys(assignment)) {\n      const propAssignment = assignment[key];\n      partialUpdate[key] = typeof propAssignment === 'function' ? propAssignment(assignArgs, actionParams) : propAssignment;\n    }\n  }\n  const updatedContext = Object.assign({}, snapshot.context, partialUpdate);\n  return [(0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.Z)(snapshot, {\n    context: updatedContext,\n    children: Object.keys(spawnedChildren).length ? {\n      ...snapshot.children,\n      ...spawnedChildren\n    } : snapshot.children\n  }), undefined, undefined];\n}\n/**\n * Updates the current context of the machine.\n *\n * @example\n *\n * ```ts\n * import { createMachine, assign } from 'xstate';\n *\n * const countMachine = createMachine({\n *   context: {\n *     count: 0,\n *     message: ''\n *   },\n *   on: {\n *     inc: {\n *       actions: assign({\n *         count: ({ context }) => context.count + 1\n *       })\n *     },\n *     updateMessage: {\n *       actions: assign(({ context, event }) => {\n *         return {\n *           message: event.message.trim()\n *         };\n *       })\n *     }\n *   }\n * });\n * ```\n *\n * @param assignment An object that represents the partial context to update, or\n *   a function that returns an object that represents the partial context to\n *   update.\n */\nfunction assign(assignment) {\n  if (_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.U) {\n    console.warn('Custom actions should not call `assign()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.');\n  }\n  function assign(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  assign.type = 'xstate.assign';\n  assign.assignment = assignment;\n  assign.resolve = resolveAssign;\n  return assign;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvYXNzaWduLWVmMWI2MmY2LmRldmVsb3BtZW50LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrTDs7QUFFbEw7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxvQkFBb0IscUVBQXNCO0FBQzFDO0FBQ0Esd0NBQXdDLElBQUksZ0NBQWdDLFdBQVc7QUFDdkY7QUFDQSx1QkFBdUIscUVBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOLHVCQUF1QixxRUFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLHlDQUF5QyxpRUFBZ0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxVQUFVLHFFQUFvQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpRUFBcUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaXNwLWNsZWFuaW5nLy4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9kaXN0L2Fzc2lnbi1lZjFiNjJmNi5kZXZlbG9wbWVudC5lc20uanM/NmEwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBZIGFzIFByb2Nlc3NpbmdTdGF0dXMsIFQgYXMgcmVzb2x2ZVJlZmVyZW5jZWRBY3RvciwgYyBhcyBjcmVhdGVBY3RvciwgWiBhcyBjbG9uZU1hY2hpbmVTbmFwc2hvdCwgVSBhcyBleGVjdXRpbmdDdXN0b21BY3Rpb24gfSBmcm9tICcuL3JhaXNlLTIzNWZhMGM3LmRldmVsb3BtZW50LmVzbS5qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNwYXduZXIoYWN0b3JTY29wZSwge1xuICBtYWNoaW5lLFxuICBjb250ZXh0XG59LCBldmVudCwgc3Bhd25lZENoaWxkcmVuKSB7XG4gIGNvbnN0IHNwYXduID0gKHNyYywgb3B0aW9ucykgPT4ge1xuICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgbG9naWMgPSByZXNvbHZlUmVmZXJlbmNlZEFjdG9yKG1hY2hpbmUsIHNyYyk7XG4gICAgICBpZiAoIWxvZ2ljKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWN0b3IgbG9naWMgJyR7c3JjfScgbm90IGltcGxlbWVudGVkIGluIG1hY2hpbmUgJyR7bWFjaGluZS5pZH0nYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBhY3RvclJlZiA9IGNyZWF0ZUFjdG9yKGxvZ2ljLCB7XG4gICAgICAgIGlkOiBvcHRpb25zPy5pZCxcbiAgICAgICAgcGFyZW50OiBhY3RvclNjb3BlLnNlbGYsXG4gICAgICAgIHN5bmNTbmFwc2hvdDogb3B0aW9ucz8uc3luY1NuYXBzaG90LFxuICAgICAgICBpbnB1dDogdHlwZW9mIG9wdGlvbnM/LmlucHV0ID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5pbnB1dCh7XG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBldmVudCxcbiAgICAgICAgICBzZWxmOiBhY3RvclNjb3BlLnNlbGZcbiAgICAgICAgfSkgOiBvcHRpb25zPy5pbnB1dCxcbiAgICAgICAgc3JjLFxuICAgICAgICBzeXN0ZW1JZDogb3B0aW9ucz8uc3lzdGVtSWRcbiAgICAgIH0pO1xuICAgICAgc3Bhd25lZENoaWxkcmVuW2FjdG9yUmVmLmlkXSA9IGFjdG9yUmVmO1xuICAgICAgcmV0dXJuIGFjdG9yUmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhY3RvclJlZiA9IGNyZWF0ZUFjdG9yKHNyYywge1xuICAgICAgICBpZDogb3B0aW9ucz8uaWQsXG4gICAgICAgIHBhcmVudDogYWN0b3JTY29wZS5zZWxmLFxuICAgICAgICBzeW5jU25hcHNob3Q6IG9wdGlvbnM/LnN5bmNTbmFwc2hvdCxcbiAgICAgICAgaW5wdXQ6IG9wdGlvbnM/LmlucHV0LFxuICAgICAgICBzcmMsXG4gICAgICAgIHN5c3RlbUlkOiBvcHRpb25zPy5zeXN0ZW1JZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWN0b3JSZWY7XG4gICAgfVxuICB9O1xuICByZXR1cm4gKHNyYywgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGFjdG9yUmVmID0gc3Bhd24oc3JjLCBvcHRpb25zKTsgLy8gVE9ETzogZml4IHR5cGVzXG4gICAgc3Bhd25lZENoaWxkcmVuW2FjdG9yUmVmLmlkXSA9IGFjdG9yUmVmO1xuICAgIGFjdG9yU2NvcGUuZGVmZXIoKCkgPT4ge1xuICAgICAgaWYgKGFjdG9yUmVmLl9wcm9jZXNzaW5nU3RhdHVzID09PSBQcm9jZXNzaW5nU3RhdHVzLlN0b3BwZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYWN0b3JSZWYuc3RhcnQoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWN0b3JSZWY7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3NpZ24oYWN0b3JTY29wZSwgc25hcHNob3QsIGFjdGlvbkFyZ3MsIGFjdGlvblBhcmFtcywge1xuICBhc3NpZ25tZW50XG59KSB7XG4gIGlmICghc25hcHNob3QuY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFzc2lnbiB0byB1bmRlZmluZWQgYGNvbnRleHRgLiBFbnN1cmUgdGhhdCBgY29udGV4dGAgaXMgZGVmaW5lZCBpbiB0aGUgbWFjaGluZSBjb25maWcuJyk7XG4gIH1cbiAgY29uc3Qgc3Bhd25lZENoaWxkcmVuID0ge307XG4gIGNvbnN0IGFzc2lnbkFyZ3MgPSB7XG4gICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICBldmVudDogYWN0aW9uQXJncy5ldmVudCxcbiAgICBzcGF3bjogY3JlYXRlU3Bhd25lcihhY3RvclNjb3BlLCBzbmFwc2hvdCwgYWN0aW9uQXJncy5ldmVudCwgc3Bhd25lZENoaWxkcmVuKSxcbiAgICBzZWxmOiBhY3RvclNjb3BlLnNlbGYsXG4gICAgc3lzdGVtOiBhY3RvclNjb3BlLnN5c3RlbVxuICB9O1xuICBsZXQgcGFydGlhbFVwZGF0ZSA9IHt9O1xuICBpZiAodHlwZW9mIGFzc2lnbm1lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwYXJ0aWFsVXBkYXRlID0gYXNzaWdubWVudChhc3NpZ25BcmdzLCBhY3Rpb25QYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGFzc2lnbm1lbnQpKSB7XG4gICAgICBjb25zdCBwcm9wQXNzaWdubWVudCA9IGFzc2lnbm1lbnRba2V5XTtcbiAgICAgIHBhcnRpYWxVcGRhdGVba2V5XSA9IHR5cGVvZiBwcm9wQXNzaWdubWVudCA9PT0gJ2Z1bmN0aW9uJyA/IHByb3BBc3NpZ25tZW50KGFzc2lnbkFyZ3MsIGFjdGlvblBhcmFtcykgOiBwcm9wQXNzaWdubWVudDtcbiAgICB9XG4gIH1cbiAgY29uc3QgdXBkYXRlZENvbnRleHQgPSBPYmplY3QuYXNzaWduKHt9LCBzbmFwc2hvdC5jb250ZXh0LCBwYXJ0aWFsVXBkYXRlKTtcbiAgcmV0dXJuIFtjbG9uZU1hY2hpbmVTbmFwc2hvdChzbmFwc2hvdCwge1xuICAgIGNvbnRleHQ6IHVwZGF0ZWRDb250ZXh0LFxuICAgIGNoaWxkcmVuOiBPYmplY3Qua2V5cyhzcGF3bmVkQ2hpbGRyZW4pLmxlbmd0aCA/IHtcbiAgICAgIC4uLnNuYXBzaG90LmNoaWxkcmVuLFxuICAgICAgLi4uc3Bhd25lZENoaWxkcmVuXG4gICAgfSA6IHNuYXBzaG90LmNoaWxkcmVuXG4gIH0pLCB1bmRlZmluZWQsIHVuZGVmaW5lZF07XG59XG4vKipcbiAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgY29udGV4dCBvZiB0aGUgbWFjaGluZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjcmVhdGVNYWNoaW5lLCBhc3NpZ24gfSBmcm9tICd4c3RhdGUnO1xuICpcbiAqIGNvbnN0IGNvdW50TWFjaGluZSA9IGNyZWF0ZU1hY2hpbmUoe1xuICogICBjb250ZXh0OiB7XG4gKiAgICAgY291bnQ6IDAsXG4gKiAgICAgbWVzc2FnZTogJydcbiAqICAgfSxcbiAqICAgb246IHtcbiAqICAgICBpbmM6IHtcbiAqICAgICAgIGFjdGlvbnM6IGFzc2lnbih7XG4gKiAgICAgICAgIGNvdW50OiAoeyBjb250ZXh0IH0pID0+IGNvbnRleHQuY291bnQgKyAxXG4gKiAgICAgICB9KVxuICogICAgIH0sXG4gKiAgICAgdXBkYXRlTWVzc2FnZToge1xuICogICAgICAgYWN0aW9uczogYXNzaWduKCh7IGNvbnRleHQsIGV2ZW50IH0pID0+IHtcbiAqICAgICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgICBtZXNzYWdlOiBldmVudC5tZXNzYWdlLnRyaW0oKVxuICogICAgICAgICB9O1xuICogICAgICAgfSlcbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGFzc2lnbm1lbnQgQW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcGFydGlhbCBjb250ZXh0IHRvIHVwZGF0ZSwgb3JcbiAqICAgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcGFydGlhbCBjb250ZXh0IHRvXG4gKiAgIHVwZGF0ZS5cbiAqL1xuZnVuY3Rpb24gYXNzaWduKGFzc2lnbm1lbnQpIHtcbiAgaWYgKGV4ZWN1dGluZ0N1c3RvbUFjdGlvbikge1xuICAgIGNvbnNvbGUud2FybignQ3VzdG9tIGFjdGlvbnMgc2hvdWxkIG5vdCBjYWxsIGBhc3NpZ24oKWAgZGlyZWN0bHksIGFzIGl0IGlzIG5vdCBpbXBlcmF0aXZlLiBTZWUgaHR0cHM6Ly9zdGF0ZWx5LmFpL2RvY3MvYWN0aW9ucyNidWlsdC1pbi1hY3Rpb25zIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gIH1cbiAgZnVuY3Rpb24gYXNzaWduKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBhc3NpZ24udHlwZSA9ICd4c3RhdGUuYXNzaWduJztcbiAgYXNzaWduLmFzc2lnbm1lbnQgPSBhc3NpZ25tZW50O1xuICBhc3NpZ24ucmVzb2x2ZSA9IHJlc29sdmVBc3NpZ247XG4gIHJldHVybiBhc3NpZ247XG59XG5cbmV4cG9ydCB7IGFzc2lnbiBhcyBhIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/assign-ef1b62f6.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/log-3eec9346.development.esm.js":
/*!******************************************************************!*\
  !*** ./node_modules/xstate/dist/log-3eec9346.development.esm.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: () => (/* binding */ SpecialTargets),\n/* harmony export */   a: () => (/* binding */ emit),\n/* harmony export */   b: () => (/* binding */ sendParent),\n/* harmony export */   e: () => (/* binding */ enqueueActions),\n/* harmony export */   f: () => (/* binding */ forwardTo),\n/* harmony export */   l: () => (/* binding */ log),\n/* harmony export */   s: () => (/* binding */ sendTo)\n/* harmony export */ });\n/* harmony import */ var _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raise-235fa0c7.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-235fa0c7.development.esm.js\");\n/* harmony import */ var _assign_ef1b62f6_development_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assign-ef1b62f6.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/assign-ef1b62f6.development.esm.js\");\n\n\n\nfunction resolveEmit(_, snapshot, args, actionParams, {\n  event: eventOrExpr\n}) {\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\n  return [snapshot, {\n    event: resolvedEvent\n  }, undefined];\n}\nfunction executeEmit(actorScope, {\n  event\n}) {\n  actorScope.defer(() => actorScope.emit(event));\n}\n/**\n * Emits an event to event handlers registered on the actor via `actor.on(event,\n * handler)`.\n *\n * @example\n *\n * ```ts\n * import { emit } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     something: {\n *       actions: emit({\n *         type: 'emitted',\n *         some: 'data'\n *       })\n *     }\n *   }\n *   // ...\n * });\n *\n * const actor = createActor(machine).start();\n *\n * actor.on('emitted', (event) => {\n *   console.log(event);\n * });\n *\n * actor.send({ type: 'something' });\n * // logs:\n * // {\n * //   type: 'emitted',\n * //   some: 'data'\n * // }\n * ```\n */\nfunction emit(/** The event to emit, or an expression that returns an event to emit. */\neventOrExpr) {\n  if (_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.U) {\n    console.warn('Custom actions should not call `emit()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.');\n  }\n  function emit(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  emit.type = 'xstate.emit';\n  emit.event = eventOrExpr;\n  emit.resolve = resolveEmit;\n  emit.execute = executeEmit;\n  return emit;\n}\n\n// this is needed to make JSDoc `@link` work properly\n\n/**\n * @remarks\n * `T | unknown` reduces to `unknown` and that can be problematic when it comes\n * to contextual typing. It especially is a problem when the union has a\n * function member, like here:\n *\n * ```ts\n * declare function test(\n *   cbOrVal: ((arg: number) => unknown) | unknown\n * ): void;\n * test((arg) => {}); // oops, implicit any\n * ```\n *\n * This type can be used to avoid this problem. This union represents the same\n * value space as `unknown`.\n */\n\n// https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887\n\n// @TODO: we can't use native `NoInfer` as we need those:\n// https://github.com/microsoft/TypeScript/pull/61092\n// https://github.com/microsoft/TypeScript/pull/61077\n// but even with those fixes native NoInfer still doesn't work - further issues have to be reproduced and fixed\n\n/** @deprecated Use the built-in `NoInfer` type instead */\n\n/** The full definition of an event, with a string `type`. */\n\n/**\n * The string or object representing the state value relative to the parent\n * state node.\n *\n * @remarks\n * - For a child atomic state node, this is a string, e.g., `\"pending\"`.\n * - For complex state nodes, this is an object, e.g., `{ success:\n *   \"someChildState\" }`.\n */\n\n/** @deprecated Use `AnyMachineSnapshot` instead */\n\n// TODO: possibly refactor this somehow, use even a simpler type, and maybe even make `machine.options` private or something\n/** @ignore */\n\nlet SpecialTargets = /*#__PURE__*/function (SpecialTargets) {\n  SpecialTargets[\"Parent\"] = \"#_parent\";\n  SpecialTargets[\"Internal\"] = \"#_internal\";\n  return SpecialTargets;\n}({});\n\n/** @deprecated Use `AnyActor` instead. */\n\n// Based on RxJS types\n\n// TODO: in v6, this should only accept AnyActorLogic, like ActorRefFromLogic\n\n/** @deprecated Use `Actor<T>` instead. */\n\n/**\n * Represents logic which can be used by an actor.\n *\n * @template TSnapshot - The type of the snapshot.\n * @template TEvent - The type of the event object.\n * @template TInput - The type of the input.\n * @template TSystem - The type of the actor system.\n */\n\n/** @deprecated */\n\n// TODO: cover all that can be actually returned\n\nfunction resolveSendTo(actorScope, snapshot, args, actionParams, {\n  to,\n  event: eventOrExpr,\n  id,\n  delay\n}, extra) {\n  const delaysMap = snapshot.machine.implementations.delays;\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    `Only event objects may be used with sendTo; use sendTo({ type: \"${eventOrExpr}\" }) instead`);\n  }\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\n  let resolvedDelay;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay = typeof configDelay === 'function' ? configDelay(args, actionParams) : configDelay;\n  } else {\n    resolvedDelay = typeof delay === 'function' ? delay(args, actionParams) : delay;\n  }\n  const resolvedTarget = typeof to === 'function' ? to(args, actionParams) : to;\n  let targetActorRef;\n  if (typeof resolvedTarget === 'string') {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n    if (resolvedTarget === SpecialTargets.Parent) {\n      targetActorRef = actorScope.self._parent;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n    else if (resolvedTarget === SpecialTargets.Internal) {\n      targetActorRef = actorScope.self;\n    } else if (resolvedTarget.startsWith('#_')) {\n      // SCXML compatibility: https://www.w3.org/TR/scxml/#SCXMLEventProcessor\n      // #_invokeid. If the target is the special term '#_invokeid', where invokeid is the invokeid of an SCXML session that the sending session has created by <invoke>, the Processor must add the event to the external queue of that session.\n      targetActorRef = snapshot.children[resolvedTarget.slice(2)];\n    } else {\n      targetActorRef = extra.deferredActorIds?.includes(resolvedTarget) ? resolvedTarget : snapshot.children[resolvedTarget];\n    }\n    if (!targetActorRef) {\n      throw new Error(`Unable to send event to actor '${resolvedTarget}' from machine '${snapshot.machine.id}'.`);\n    }\n  } else {\n    targetActorRef = resolvedTarget || actorScope.self;\n  }\n  return [snapshot, {\n    to: targetActorRef,\n    targetId: typeof resolvedTarget === 'string' ? resolvedTarget : undefined,\n    event: resolvedEvent,\n    id,\n    delay: resolvedDelay\n  }, undefined];\n}\nfunction retryResolveSendTo(_, snapshot, params) {\n  if (typeof params.to === 'string') {\n    params.to = snapshot.children[params.to];\n  }\n}\nfunction executeSendTo(actorScope, params) {\n  // this forms an outgoing events queue\n  // thanks to that the recipient actors are able to read the *updated* snapshot value of the sender\n  actorScope.defer(() => {\n    const {\n      to,\n      event,\n      delay,\n      id\n    } = params;\n    if (typeof delay === 'number') {\n      actorScope.system.scheduler.schedule(actorScope.self, to, event, delay, id);\n      return;\n    }\n    actorScope.system._relay(actorScope.self,\n    // at this point, in a deferred task, it should already be mutated by retryResolveSendTo\n    // if it initially started as a string\n    to, event.type === _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.V ? (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.W)(actorScope.self.id, event.data) : event);\n  });\n}\n/**\n * Sends an event to an actor.\n *\n * @param actor The `ActorRef` to send the event to.\n * @param event The event to send, or an expression that evaluates to the event\n *   to send\n * @param options Send action options\n *\n *   - `id` - The unique send event identifier (used with `cancel()`).\n *   - `delay` - The number of milliseconds to delay the sending of the event.\n */\nfunction sendTo(to, eventOrExpr, options) {\n  if (_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.U) {\n    console.warn('Custom actions should not call `sendTo()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.');\n  }\n  function sendTo(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  sendTo.type = 'xstate.sendTo';\n  sendTo.to = to;\n  sendTo.event = eventOrExpr;\n  sendTo.id = options?.id;\n  sendTo.delay = options?.delay;\n  sendTo.resolve = resolveSendTo;\n  sendTo.retryResolve = retryResolveSendTo;\n  sendTo.execute = executeSendTo;\n  return sendTo;\n}\n\n/**\n * Sends an event to this machine's parent.\n *\n * @param event The event to send to the parent machine.\n * @param options Options to pass into the send event.\n */\nfunction sendParent(event, options) {\n  return sendTo(SpecialTargets.Parent, event, options);\n}\n/**\n * Forwards (sends) an event to the `target` actor.\n *\n * @param target The target actor to forward the event to.\n * @param options Options to pass into the send action creator.\n */\nfunction forwardTo(target, options) {\n  if ((!target || typeof target === 'function')) {\n    const originalTarget = target;\n    target = (...args) => {\n      const resolvedTarget = typeof originalTarget === 'function' ? originalTarget(...args) : originalTarget;\n      if (!resolvedTarget) {\n        throw new Error(`Attempted to forward event to undefined actor. This risks an infinite loop in the sender.`);\n      }\n      return resolvedTarget;\n    };\n  }\n  return sendTo(target, ({\n    event\n  }) => event, options);\n}\n\nfunction resolveEnqueueActions(actorScope, snapshot, args, actionParams, {\n  collect\n}) {\n  const actions = [];\n  const enqueue = function enqueue(action) {\n    actions.push(action);\n  };\n  enqueue.assign = (...args) => {\n    actions.push((0,_assign_ef1b62f6_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(...args));\n  };\n  enqueue.cancel = (...args) => {\n    actions.push((0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(...args));\n  };\n  enqueue.raise = (...args) => {\n    // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n    // then it fails to typecheck that because `...args` use `string` in place of `TDelay`\n    actions.push((0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.r)(...args));\n  };\n  enqueue.sendTo = (...args) => {\n    // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n    // then it fails to typecheck that because `...args` use `string` in place of `TDelay\n    actions.push(sendTo(...args));\n  };\n  enqueue.sendParent = (...args) => {\n    actions.push(sendParent(...args));\n  };\n  enqueue.spawnChild = (...args) => {\n    actions.push((0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(...args));\n  };\n  enqueue.stopChild = (...args) => {\n    actions.push((0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.s)(...args));\n  };\n  enqueue.emit = (...args) => {\n    actions.push(emit(...args));\n  };\n  collect({\n    context: args.context,\n    event: args.event,\n    enqueue,\n    check: guard => (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.x)(guard, snapshot.context, args.event, snapshot),\n    self: actorScope.self,\n    system: actorScope.system\n  }, actionParams);\n  return [snapshot, undefined, actions];\n}\n/**\n * Creates an action object that will execute actions that are queued by the\n * `enqueue(action)` function.\n *\n * @example\n *\n * ```ts\n * import { createMachine, enqueueActions } from 'xstate';\n *\n * const machine = createMachine({\n *   entry: enqueueActions(({ enqueue, check }) => {\n *     enqueue.assign({ count: 0 });\n *\n *     if (check('someGuard')) {\n *       enqueue.assign({ count: 1 });\n *     }\n *\n *     enqueue('someAction');\n *   })\n * });\n * ```\n */\nfunction enqueueActions(collect) {\n  function enqueueActions(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  enqueueActions.type = 'xstate.enqueueActions';\n  enqueueActions.collect = collect;\n  enqueueActions.resolve = resolveEnqueueActions;\n  return enqueueActions;\n}\n\nfunction resolveLog(_, snapshot, actionArgs, actionParams, {\n  value,\n  label\n}) {\n  return [snapshot, {\n    value: typeof value === 'function' ? value(actionArgs, actionParams) : value,\n    label\n  }, undefined];\n}\nfunction executeLog({\n  logger\n}, {\n  value,\n  label\n}) {\n  if (label) {\n    logger(label, value);\n  } else {\n    logger(value);\n  }\n}\n/**\n * @param expr The expression function to evaluate which will be logged. Takes\n *   in 2 arguments:\n *\n *   - `ctx` - the current state context\n *   - `event` - the event that caused this action to be executed.\n *\n * @param label The label to give to the logged expression.\n */\nfunction log(value = ({\n  context,\n  event\n}) => ({\n  context,\n  event\n}), label) {\n  function log(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  log.type = 'xstate.log';\n  log.value = value;\n  log.label = label;\n  log.resolve = resolveLog;\n  log.execute = executeLog;\n  return log;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvbG9nLTNlZWM5MzQ2LmRldmVsb3BtZW50LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBOE07QUFDM0k7O0FBRW5FO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpRUFBcUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCx1QkFBdUI7QUFDdkI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRzs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYSxTQUFTLFlBQVksR0FBRztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZUFBZSxrQkFBa0Isb0JBQW9CO0FBQzdHO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlFQUFZLEdBQUcscUVBQXFCO0FBQzNELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0saUVBQXFCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNFQUFNO0FBQ3ZCO0FBQ0E7QUFDQSxpQkFBaUIscUVBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUVBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUVBQVU7QUFDM0I7QUFDQTtBQUNBLGlCQUFpQixxRUFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFFQUFhO0FBQ2pDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUMsd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmlzcC1jbGVhbmluZy8uL25vZGVfbW9kdWxlcy94c3RhdGUvZGlzdC9sb2ctM2VlYzkzNDYuZGV2ZWxvcG1lbnQuZXNtLmpzPzBhZTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVSBhcyBleGVjdXRpbmdDdXN0b21BY3Rpb24sIFYgYXMgWFNUQVRFX0VSUk9SLCBXIGFzIGNyZWF0ZUVycm9yQWN0b3JFdmVudCwgeCBhcyBldmFsdWF0ZUd1YXJkLCBhIGFzIGNhbmNlbCwgciBhcyByYWlzZSwgYiBhcyBzcGF3bkNoaWxkLCBzIGFzIHN0b3BDaGlsZCB9IGZyb20gJy4vcmFpc2UtMjM1ZmEwYzcuZGV2ZWxvcG1lbnQuZXNtLmpzJztcbmltcG9ydCB7IGEgYXMgYXNzaWduIH0gZnJvbSAnLi9hc3NpZ24tZWYxYjYyZjYuZGV2ZWxvcG1lbnQuZXNtLmpzJztcblxuZnVuY3Rpb24gcmVzb2x2ZUVtaXQoXywgc25hcHNob3QsIGFyZ3MsIGFjdGlvblBhcmFtcywge1xuICBldmVudDogZXZlbnRPckV4cHJcbn0pIHtcbiAgY29uc3QgcmVzb2x2ZWRFdmVudCA9IHR5cGVvZiBldmVudE9yRXhwciA9PT0gJ2Z1bmN0aW9uJyA/IGV2ZW50T3JFeHByKGFyZ3MsIGFjdGlvblBhcmFtcykgOiBldmVudE9yRXhwcjtcbiAgcmV0dXJuIFtzbmFwc2hvdCwge1xuICAgIGV2ZW50OiByZXNvbHZlZEV2ZW50XG4gIH0sIHVuZGVmaW5lZF07XG59XG5mdW5jdGlvbiBleGVjdXRlRW1pdChhY3RvclNjb3BlLCB7XG4gIGV2ZW50XG59KSB7XG4gIGFjdG9yU2NvcGUuZGVmZXIoKCkgPT4gYWN0b3JTY29wZS5lbWl0KGV2ZW50KSk7XG59XG4vKipcbiAqIEVtaXRzIGFuIGV2ZW50IHRvIGV2ZW50IGhhbmRsZXJzIHJlZ2lzdGVyZWQgb24gdGhlIGFjdG9yIHZpYSBgYWN0b3Iub24oZXZlbnQsXG4gKiBoYW5kbGVyKWAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZW1pdCB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgbWFjaGluZSA9IGNyZWF0ZU1hY2hpbmUoe1xuICogICAvLyAuLi5cbiAqICAgb246IHtcbiAqICAgICBzb21ldGhpbmc6IHtcbiAqICAgICAgIGFjdGlvbnM6IGVtaXQoe1xuICogICAgICAgICB0eXBlOiAnZW1pdHRlZCcsXG4gKiAgICAgICAgIHNvbWU6ICdkYXRhJ1xuICogICAgICAgfSlcbiAqICAgICB9XG4gKiAgIH1cbiAqICAgLy8gLi4uXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKG1hY2hpbmUpLnN0YXJ0KCk7XG4gKlxuICogYWN0b3Iub24oJ2VtaXR0ZWQnLCAoZXZlbnQpID0+IHtcbiAqICAgY29uc29sZS5sb2coZXZlbnQpO1xuICogfSk7XG4gKlxuICogYWN0b3Iuc2VuZCh7IHR5cGU6ICdzb21ldGhpbmcnIH0pO1xuICogLy8gbG9nczpcbiAqIC8vIHtcbiAqIC8vICAgdHlwZTogJ2VtaXR0ZWQnLFxuICogLy8gICBzb21lOiAnZGF0YSdcbiAqIC8vIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBlbWl0KC8qKiBUaGUgZXZlbnQgdG8gZW1pdCwgb3IgYW4gZXhwcmVzc2lvbiB0aGF0IHJldHVybnMgYW4gZXZlbnQgdG8gZW1pdC4gKi9cbmV2ZW50T3JFeHByKSB7XG4gIGlmIChleGVjdXRpbmdDdXN0b21BY3Rpb24pIHtcbiAgICBjb25zb2xlLndhcm4oJ0N1c3RvbSBhY3Rpb25zIHNob3VsZCBub3QgY2FsbCBgZW1pdCgpYCBkaXJlY3RseSwgYXMgaXQgaXMgbm90IGltcGVyYXRpdmUuIFNlZSBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9hY3Rpb25zI2J1aWx0LWluLWFjdGlvbnMgZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgfVxuICBmdW5jdGlvbiBlbWl0KF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBlbWl0LnR5cGUgPSAneHN0YXRlLmVtaXQnO1xuICBlbWl0LmV2ZW50ID0gZXZlbnRPckV4cHI7XG4gIGVtaXQucmVzb2x2ZSA9IHJlc29sdmVFbWl0O1xuICBlbWl0LmV4ZWN1dGUgPSBleGVjdXRlRW1pdDtcbiAgcmV0dXJuIGVtaXQ7XG59XG5cbi8vIHRoaXMgaXMgbmVlZGVkIHRvIG1ha2UgSlNEb2MgYEBsaW5rYCB3b3JrIHByb3Blcmx5XG5cbi8qKlxuICogQHJlbWFya3NcbiAqIGBUIHwgdW5rbm93bmAgcmVkdWNlcyB0byBgdW5rbm93bmAgYW5kIHRoYXQgY2FuIGJlIHByb2JsZW1hdGljIHdoZW4gaXQgY29tZXNcbiAqIHRvIGNvbnRleHR1YWwgdHlwaW5nLiBJdCBlc3BlY2lhbGx5IGlzIGEgcHJvYmxlbSB3aGVuIHRoZSB1bmlvbiBoYXMgYVxuICogZnVuY3Rpb24gbWVtYmVyLCBsaWtlIGhlcmU6XG4gKlxuICogYGBgdHNcbiAqIGRlY2xhcmUgZnVuY3Rpb24gdGVzdChcbiAqICAgY2JPclZhbDogKChhcmc6IG51bWJlcikgPT4gdW5rbm93bikgfCB1bmtub3duXG4gKiApOiB2b2lkO1xuICogdGVzdCgoYXJnKSA9PiB7fSk7IC8vIG9vcHMsIGltcGxpY2l0IGFueVxuICogYGBgXG4gKlxuICogVGhpcyB0eXBlIGNhbiBiZSB1c2VkIHRvIGF2b2lkIHRoaXMgcHJvYmxlbS4gVGhpcyB1bmlvbiByZXByZXNlbnRzIHRoZSBzYW1lXG4gKiB2YWx1ZSBzcGFjZSBhcyBgdW5rbm93bmAuXG4gKi9cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yMzE4MiNpc3N1ZWNvbW1lbnQtMzc5MDkxODg3XG5cbi8vIEBUT0RPOiB3ZSBjYW4ndCB1c2UgbmF0aXZlIGBOb0luZmVyYCBhcyB3ZSBuZWVkIHRob3NlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L3B1bGwvNjEwOTJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9wdWxsLzYxMDc3XG4vLyBidXQgZXZlbiB3aXRoIHRob3NlIGZpeGVzIG5hdGl2ZSBOb0luZmVyIHN0aWxsIGRvZXNuJ3Qgd29yayAtIGZ1cnRoZXIgaXNzdWVzIGhhdmUgdG8gYmUgcmVwcm9kdWNlZCBhbmQgZml4ZWRcblxuLyoqIEBkZXByZWNhdGVkIFVzZSB0aGUgYnVpbHQtaW4gYE5vSW5mZXJgIHR5cGUgaW5zdGVhZCAqL1xuXG4vKiogVGhlIGZ1bGwgZGVmaW5pdGlvbiBvZiBhbiBldmVudCwgd2l0aCBhIHN0cmluZyBgdHlwZWAuICovXG5cbi8qKlxuICogVGhlIHN0cmluZyBvciBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSB2YWx1ZSByZWxhdGl2ZSB0byB0aGUgcGFyZW50XG4gKiBzdGF0ZSBub2RlLlxuICpcbiAqIEByZW1hcmtzXG4gKiAtIEZvciBhIGNoaWxkIGF0b21pYyBzdGF0ZSBub2RlLCB0aGlzIGlzIGEgc3RyaW5nLCBlLmcuLCBgXCJwZW5kaW5nXCJgLlxuICogLSBGb3IgY29tcGxleCBzdGF0ZSBub2RlcywgdGhpcyBpcyBhbiBvYmplY3QsIGUuZy4sIGB7IHN1Y2Nlc3M6XG4gKiAgIFwic29tZUNoaWxkU3RhdGVcIiB9YC5cbiAqL1xuXG4vKiogQGRlcHJlY2F0ZWQgVXNlIGBBbnlNYWNoaW5lU25hcHNob3RgIGluc3RlYWQgKi9cblxuLy8gVE9ETzogcG9zc2libHkgcmVmYWN0b3IgdGhpcyBzb21laG93LCB1c2UgZXZlbiBhIHNpbXBsZXIgdHlwZSwgYW5kIG1heWJlIGV2ZW4gbWFrZSBgbWFjaGluZS5vcHRpb25zYCBwcml2YXRlIG9yIHNvbWV0aGluZ1xuLyoqIEBpZ25vcmUgKi9cblxubGV0IFNwZWNpYWxUYXJnZXRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChTcGVjaWFsVGFyZ2V0cykge1xuICBTcGVjaWFsVGFyZ2V0c1tcIlBhcmVudFwiXSA9IFwiI19wYXJlbnRcIjtcbiAgU3BlY2lhbFRhcmdldHNbXCJJbnRlcm5hbFwiXSA9IFwiI19pbnRlcm5hbFwiO1xuICByZXR1cm4gU3BlY2lhbFRhcmdldHM7XG59KHt9KTtcblxuLyoqIEBkZXByZWNhdGVkIFVzZSBgQW55QWN0b3JgIGluc3RlYWQuICovXG5cbi8vIEJhc2VkIG9uIFJ4SlMgdHlwZXNcblxuLy8gVE9ETzogaW4gdjYsIHRoaXMgc2hvdWxkIG9ubHkgYWNjZXB0IEFueUFjdG9yTG9naWMsIGxpa2UgQWN0b3JSZWZGcm9tTG9naWNcblxuLyoqIEBkZXByZWNhdGVkIFVzZSBgQWN0b3I8VD5gIGluc3RlYWQuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBsb2dpYyB3aGljaCBjYW4gYmUgdXNlZCBieSBhbiBhY3Rvci5cbiAqXG4gKiBAdGVtcGxhdGUgVFNuYXBzaG90IC0gVGhlIHR5cGUgb2YgdGhlIHNuYXBzaG90LlxuICogQHRlbXBsYXRlIFRFdmVudCAtIFRoZSB0eXBlIG9mIHRoZSBldmVudCBvYmplY3QuXG4gKiBAdGVtcGxhdGUgVElucHV0IC0gVGhlIHR5cGUgb2YgdGhlIGlucHV0LlxuICogQHRlbXBsYXRlIFRTeXN0ZW0gLSBUaGUgdHlwZSBvZiB0aGUgYWN0b3Igc3lzdGVtLlxuICovXG5cbi8qKiBAZGVwcmVjYXRlZCAqL1xuXG4vLyBUT0RPOiBjb3ZlciBhbGwgdGhhdCBjYW4gYmUgYWN0dWFsbHkgcmV0dXJuZWRcblxuZnVuY3Rpb24gcmVzb2x2ZVNlbmRUbyhhY3RvclNjb3BlLCBzbmFwc2hvdCwgYXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIHRvLFxuICBldmVudDogZXZlbnRPckV4cHIsXG4gIGlkLFxuICBkZWxheVxufSwgZXh0cmEpIHtcbiAgY29uc3QgZGVsYXlzTWFwID0gc25hcHNob3QubWFjaGluZS5pbXBsZW1lbnRhdGlvbnMuZGVsYXlzO1xuICBpZiAodHlwZW9mIGV2ZW50T3JFeHByID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG4gICAgYE9ubHkgZXZlbnQgb2JqZWN0cyBtYXkgYmUgdXNlZCB3aXRoIHNlbmRUbzsgdXNlIHNlbmRUbyh7IHR5cGU6IFwiJHtldmVudE9yRXhwcn1cIiB9KSBpbnN0ZWFkYCk7XG4gIH1cbiAgY29uc3QgcmVzb2x2ZWRFdmVudCA9IHR5cGVvZiBldmVudE9yRXhwciA9PT0gJ2Z1bmN0aW9uJyA/IGV2ZW50T3JFeHByKGFyZ3MsIGFjdGlvblBhcmFtcykgOiBldmVudE9yRXhwcjtcbiAgbGV0IHJlc29sdmVkRGVsYXk7XG4gIGlmICh0eXBlb2YgZGVsYXkgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgY29uZmlnRGVsYXkgPSBkZWxheXNNYXAgJiYgZGVsYXlzTWFwW2RlbGF5XTtcbiAgICByZXNvbHZlZERlbGF5ID0gdHlwZW9mIGNvbmZpZ0RlbGF5ID09PSAnZnVuY3Rpb24nID8gY29uZmlnRGVsYXkoYXJncywgYWN0aW9uUGFyYW1zKSA6IGNvbmZpZ0RlbGF5O1xuICB9IGVsc2Uge1xuICAgIHJlc29sdmVkRGVsYXkgPSB0eXBlb2YgZGVsYXkgPT09ICdmdW5jdGlvbicgPyBkZWxheShhcmdzLCBhY3Rpb25QYXJhbXMpIDogZGVsYXk7XG4gIH1cbiAgY29uc3QgcmVzb2x2ZWRUYXJnZXQgPSB0eXBlb2YgdG8gPT09ICdmdW5jdGlvbicgPyB0byhhcmdzLCBhY3Rpb25QYXJhbXMpIDogdG87XG4gIGxldCB0YXJnZXRBY3RvclJlZjtcbiAgaWYgKHR5cGVvZiByZXNvbHZlZFRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb25cbiAgICBpZiAocmVzb2x2ZWRUYXJnZXQgPT09IFNwZWNpYWxUYXJnZXRzLlBhcmVudCkge1xuICAgICAgdGFyZ2V0QWN0b3JSZWYgPSBhY3RvclNjb3BlLnNlbGYuX3BhcmVudDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uXG4gICAgZWxzZSBpZiAocmVzb2x2ZWRUYXJnZXQgPT09IFNwZWNpYWxUYXJnZXRzLkludGVybmFsKSB7XG4gICAgICB0YXJnZXRBY3RvclJlZiA9IGFjdG9yU2NvcGUuc2VsZjtcbiAgICB9IGVsc2UgaWYgKHJlc29sdmVkVGFyZ2V0LnN0YXJ0c1dpdGgoJyNfJykpIHtcbiAgICAgIC8vIFNDWE1MIGNvbXBhdGliaWxpdHk6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zY3htbC8jU0NYTUxFdmVudFByb2Nlc3NvclxuICAgICAgLy8gI19pbnZva2VpZC4gSWYgdGhlIHRhcmdldCBpcyB0aGUgc3BlY2lhbCB0ZXJtICcjX2ludm9rZWlkJywgd2hlcmUgaW52b2tlaWQgaXMgdGhlIGludm9rZWlkIG9mIGFuIFNDWE1MIHNlc3Npb24gdGhhdCB0aGUgc2VuZGluZyBzZXNzaW9uIGhhcyBjcmVhdGVkIGJ5IDxpbnZva2U+LCB0aGUgUHJvY2Vzc29yIG11c3QgYWRkIHRoZSBldmVudCB0byB0aGUgZXh0ZXJuYWwgcXVldWUgb2YgdGhhdCBzZXNzaW9uLlxuICAgICAgdGFyZ2V0QWN0b3JSZWYgPSBzbmFwc2hvdC5jaGlsZHJlbltyZXNvbHZlZFRhcmdldC5zbGljZSgyKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldEFjdG9yUmVmID0gZXh0cmEuZGVmZXJyZWRBY3Rvcklkcz8uaW5jbHVkZXMocmVzb2x2ZWRUYXJnZXQpID8gcmVzb2x2ZWRUYXJnZXQgOiBzbmFwc2hvdC5jaGlsZHJlbltyZXNvbHZlZFRhcmdldF07XG4gICAgfVxuICAgIGlmICghdGFyZ2V0QWN0b3JSZWYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHNlbmQgZXZlbnQgdG8gYWN0b3IgJyR7cmVzb2x2ZWRUYXJnZXR9JyBmcm9tIG1hY2hpbmUgJyR7c25hcHNob3QubWFjaGluZS5pZH0nLmApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXRBY3RvclJlZiA9IHJlc29sdmVkVGFyZ2V0IHx8IGFjdG9yU2NvcGUuc2VsZjtcbiAgfVxuICByZXR1cm4gW3NuYXBzaG90LCB7XG4gICAgdG86IHRhcmdldEFjdG9yUmVmLFxuICAgIHRhcmdldElkOiB0eXBlb2YgcmVzb2x2ZWRUYXJnZXQgPT09ICdzdHJpbmcnID8gcmVzb2x2ZWRUYXJnZXQgOiB1bmRlZmluZWQsXG4gICAgZXZlbnQ6IHJlc29sdmVkRXZlbnQsXG4gICAgaWQsXG4gICAgZGVsYXk6IHJlc29sdmVkRGVsYXlcbiAgfSwgdW5kZWZpbmVkXTtcbn1cbmZ1bmN0aW9uIHJldHJ5UmVzb2x2ZVNlbmRUbyhfLCBzbmFwc2hvdCwgcGFyYW1zKSB7XG4gIGlmICh0eXBlb2YgcGFyYW1zLnRvID09PSAnc3RyaW5nJykge1xuICAgIHBhcmFtcy50byA9IHNuYXBzaG90LmNoaWxkcmVuW3BhcmFtcy50b107XG4gIH1cbn1cbmZ1bmN0aW9uIGV4ZWN1dGVTZW5kVG8oYWN0b3JTY29wZSwgcGFyYW1zKSB7XG4gIC8vIHRoaXMgZm9ybXMgYW4gb3V0Z29pbmcgZXZlbnRzIHF1ZXVlXG4gIC8vIHRoYW5rcyB0byB0aGF0IHRoZSByZWNpcGllbnQgYWN0b3JzIGFyZSBhYmxlIHRvIHJlYWQgdGhlICp1cGRhdGVkKiBzbmFwc2hvdCB2YWx1ZSBvZiB0aGUgc2VuZGVyXG4gIGFjdG9yU2NvcGUuZGVmZXIoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHRvLFxuICAgICAgZXZlbnQsXG4gICAgICBkZWxheSxcbiAgICAgIGlkXG4gICAgfSA9IHBhcmFtcztcbiAgICBpZiAodHlwZW9mIGRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgYWN0b3JTY29wZS5zeXN0ZW0uc2NoZWR1bGVyLnNjaGVkdWxlKGFjdG9yU2NvcGUuc2VsZiwgdG8sIGV2ZW50LCBkZWxheSwgaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhY3RvclNjb3BlLnN5c3RlbS5fcmVsYXkoYWN0b3JTY29wZS5zZWxmLFxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGluIGEgZGVmZXJyZWQgdGFzaywgaXQgc2hvdWxkIGFscmVhZHkgYmUgbXV0YXRlZCBieSByZXRyeVJlc29sdmVTZW5kVG9cbiAgICAvLyBpZiBpdCBpbml0aWFsbHkgc3RhcnRlZCBhcyBhIHN0cmluZ1xuICAgIHRvLCBldmVudC50eXBlID09PSBYU1RBVEVfRVJST1IgPyBjcmVhdGVFcnJvckFjdG9yRXZlbnQoYWN0b3JTY29wZS5zZWxmLmlkLCBldmVudC5kYXRhKSA6IGV2ZW50KTtcbiAgfSk7XG59XG4vKipcbiAqIFNlbmRzIGFuIGV2ZW50IHRvIGFuIGFjdG9yLlxuICpcbiAqIEBwYXJhbSBhY3RvciBUaGUgYEFjdG9yUmVmYCB0byBzZW5kIHRoZSBldmVudCB0by5cbiAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gc2VuZCwgb3IgYW4gZXhwcmVzc2lvbiB0aGF0IGV2YWx1YXRlcyB0byB0aGUgZXZlbnRcbiAqICAgdG8gc2VuZFxuICogQHBhcmFtIG9wdGlvbnMgU2VuZCBhY3Rpb24gb3B0aW9uc1xuICpcbiAqICAgLSBgaWRgIC0gVGhlIHVuaXF1ZSBzZW5kIGV2ZW50IGlkZW50aWZpZXIgKHVzZWQgd2l0aCBgY2FuY2VsKClgKS5cbiAqICAgLSBgZGVsYXlgIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgdGhlIHNlbmRpbmcgb2YgdGhlIGV2ZW50LlxuICovXG5mdW5jdGlvbiBzZW5kVG8odG8sIGV2ZW50T3JFeHByLCBvcHRpb25zKSB7XG4gIGlmIChleGVjdXRpbmdDdXN0b21BY3Rpb24pIHtcbiAgICBjb25zb2xlLndhcm4oJ0N1c3RvbSBhY3Rpb25zIHNob3VsZCBub3QgY2FsbCBgc2VuZFRvKClgIGRpcmVjdGx5LCBhcyBpdCBpcyBub3QgaW1wZXJhdGl2ZS4gU2VlIGh0dHBzOi8vc3RhdGVseS5haS9kb2NzL2FjdGlvbnMjYnVpbHQtaW4tYWN0aW9ucyBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICB9XG4gIGZ1bmN0aW9uIHNlbmRUbyhfYXJncywgX3BhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgc2VuZFRvLnR5cGUgPSAneHN0YXRlLnNlbmRUbyc7XG4gIHNlbmRUby50byA9IHRvO1xuICBzZW5kVG8uZXZlbnQgPSBldmVudE9yRXhwcjtcbiAgc2VuZFRvLmlkID0gb3B0aW9ucz8uaWQ7XG4gIHNlbmRUby5kZWxheSA9IG9wdGlvbnM/LmRlbGF5O1xuICBzZW5kVG8ucmVzb2x2ZSA9IHJlc29sdmVTZW5kVG87XG4gIHNlbmRUby5yZXRyeVJlc29sdmUgPSByZXRyeVJlc29sdmVTZW5kVG87XG4gIHNlbmRUby5leGVjdXRlID0gZXhlY3V0ZVNlbmRUbztcbiAgcmV0dXJuIHNlbmRUbztcbn1cblxuLyoqXG4gKiBTZW5kcyBhbiBldmVudCB0byB0aGlzIG1hY2hpbmUncyBwYXJlbnQuXG4gKlxuICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byBzZW5kIHRvIHRoZSBwYXJlbnQgbWFjaGluZS5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gcGFzcyBpbnRvIHRoZSBzZW5kIGV2ZW50LlxuICovXG5mdW5jdGlvbiBzZW5kUGFyZW50KGV2ZW50LCBvcHRpb25zKSB7XG4gIHJldHVybiBzZW5kVG8oU3BlY2lhbFRhcmdldHMuUGFyZW50LCBldmVudCwgb3B0aW9ucyk7XG59XG4vKipcbiAqIEZvcndhcmRzIChzZW5kcykgYW4gZXZlbnQgdG8gdGhlIGB0YXJnZXRgIGFjdG9yLlxuICpcbiAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBhY3RvciB0byBmb3J3YXJkIHRoZSBldmVudCB0by5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gcGFzcyBpbnRvIHRoZSBzZW5kIGFjdGlvbiBjcmVhdG9yLlxuICovXG5mdW5jdGlvbiBmb3J3YXJkVG8odGFyZ2V0LCBvcHRpb25zKSB7XG4gIGlmICgoIXRhcmdldCB8fCB0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGNvbnN0IG9yaWdpbmFsVGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRhcmdldCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCByZXNvbHZlZFRhcmdldCA9IHR5cGVvZiBvcmlnaW5hbFRhcmdldCA9PT0gJ2Z1bmN0aW9uJyA/IG9yaWdpbmFsVGFyZ2V0KC4uLmFyZ3MpIDogb3JpZ2luYWxUYXJnZXQ7XG4gICAgICBpZiAoIXJlc29sdmVkVGFyZ2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0ZW1wdGVkIHRvIGZvcndhcmQgZXZlbnQgdG8gdW5kZWZpbmVkIGFjdG9yLiBUaGlzIHJpc2tzIGFuIGluZmluaXRlIGxvb3AgaW4gdGhlIHNlbmRlci5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNvbHZlZFRhcmdldDtcbiAgICB9O1xuICB9XG4gIHJldHVybiBzZW5kVG8odGFyZ2V0LCAoe1xuICAgIGV2ZW50XG4gIH0pID0+IGV2ZW50LCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUVucXVldWVBY3Rpb25zKGFjdG9yU2NvcGUsIHNuYXBzaG90LCBhcmdzLCBhY3Rpb25QYXJhbXMsIHtcbiAgY29sbGVjdFxufSkge1xuICBjb25zdCBhY3Rpb25zID0gW107XG4gIGNvbnN0IGVucXVldWUgPSBmdW5jdGlvbiBlbnF1ZXVlKGFjdGlvbikge1xuICAgIGFjdGlvbnMucHVzaChhY3Rpb24pO1xuICB9O1xuICBlbnF1ZXVlLmFzc2lnbiA9ICguLi5hcmdzKSA9PiB7XG4gICAgYWN0aW9ucy5wdXNoKGFzc2lnbiguLi5hcmdzKSk7XG4gIH07XG4gIGVucXVldWUuY2FuY2VsID0gKC4uLmFyZ3MpID0+IHtcbiAgICBhY3Rpb25zLnB1c2goY2FuY2VsKC4uLmFyZ3MpKTtcbiAgfTtcbiAgZW5xdWV1ZS5yYWlzZSA9ICguLi5hcmdzKSA9PiB7XG4gICAgLy8gZm9yIHNvbWUgcmVhc29uIGl0IGZhaWxzIHRvIGluZmVyIGBURGVsYXlgIGZyb20gYC4uLmFyZ3NgIGhlcmUgYW5kIHBpY2tzIGl0cyBkZWZhdWx0IChgbmV2ZXJgKVxuICAgIC8vIHRoZW4gaXQgZmFpbHMgdG8gdHlwZWNoZWNrIHRoYXQgYmVjYXVzZSBgLi4uYXJnc2AgdXNlIGBzdHJpbmdgIGluIHBsYWNlIG9mIGBURGVsYXlgXG4gICAgYWN0aW9ucy5wdXNoKHJhaXNlKC4uLmFyZ3MpKTtcbiAgfTtcbiAgZW5xdWV1ZS5zZW5kVG8gPSAoLi4uYXJncykgPT4ge1xuICAgIC8vIGZvciBzb21lIHJlYXNvbiBpdCBmYWlscyB0byBpbmZlciBgVERlbGF5YCBmcm9tIGAuLi5hcmdzYCBoZXJlIGFuZCBwaWNrcyBpdHMgZGVmYXVsdCAoYG5ldmVyYClcbiAgICAvLyB0aGVuIGl0IGZhaWxzIHRvIHR5cGVjaGVjayB0aGF0IGJlY2F1c2UgYC4uLmFyZ3NgIHVzZSBgc3RyaW5nYCBpbiBwbGFjZSBvZiBgVERlbGF5XG4gICAgYWN0aW9ucy5wdXNoKHNlbmRUbyguLi5hcmdzKSk7XG4gIH07XG4gIGVucXVldWUuc2VuZFBhcmVudCA9ICguLi5hcmdzKSA9PiB7XG4gICAgYWN0aW9ucy5wdXNoKHNlbmRQYXJlbnQoLi4uYXJncykpO1xuICB9O1xuICBlbnF1ZXVlLnNwYXduQ2hpbGQgPSAoLi4uYXJncykgPT4ge1xuICAgIGFjdGlvbnMucHVzaChzcGF3bkNoaWxkKC4uLmFyZ3MpKTtcbiAgfTtcbiAgZW5xdWV1ZS5zdG9wQ2hpbGQgPSAoLi4uYXJncykgPT4ge1xuICAgIGFjdGlvbnMucHVzaChzdG9wQ2hpbGQoLi4uYXJncykpO1xuICB9O1xuICBlbnF1ZXVlLmVtaXQgPSAoLi4uYXJncykgPT4ge1xuICAgIGFjdGlvbnMucHVzaChlbWl0KC4uLmFyZ3MpKTtcbiAgfTtcbiAgY29sbGVjdCh7XG4gICAgY29udGV4dDogYXJncy5jb250ZXh0LFxuICAgIGV2ZW50OiBhcmdzLmV2ZW50LFxuICAgIGVucXVldWUsXG4gICAgY2hlY2s6IGd1YXJkID0+IGV2YWx1YXRlR3VhcmQoZ3VhcmQsIHNuYXBzaG90LmNvbnRleHQsIGFyZ3MuZXZlbnQsIHNuYXBzaG90KSxcbiAgICBzZWxmOiBhY3RvclNjb3BlLnNlbGYsXG4gICAgc3lzdGVtOiBhY3RvclNjb3BlLnN5c3RlbVxuICB9LCBhY3Rpb25QYXJhbXMpO1xuICByZXR1cm4gW3NuYXBzaG90LCB1bmRlZmluZWQsIGFjdGlvbnNdO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGFjdGlvbiBvYmplY3QgdGhhdCB3aWxsIGV4ZWN1dGUgYWN0aW9ucyB0aGF0IGFyZSBxdWV1ZWQgYnkgdGhlXG4gKiBgZW5xdWV1ZShhY3Rpb24pYCBmdW5jdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjcmVhdGVNYWNoaW5lLCBlbnF1ZXVlQWN0aW9ucyB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgbWFjaGluZSA9IGNyZWF0ZU1hY2hpbmUoe1xuICogICBlbnRyeTogZW5xdWV1ZUFjdGlvbnMoKHsgZW5xdWV1ZSwgY2hlY2sgfSkgPT4ge1xuICogICAgIGVucXVldWUuYXNzaWduKHsgY291bnQ6IDAgfSk7XG4gKlxuICogICAgIGlmIChjaGVjaygnc29tZUd1YXJkJykpIHtcbiAqICAgICAgIGVucXVldWUuYXNzaWduKHsgY291bnQ6IDEgfSk7XG4gKiAgICAgfVxuICpcbiAqICAgICBlbnF1ZXVlKCdzb21lQWN0aW9uJyk7XG4gKiAgIH0pXG4gKiB9KTtcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBlbnF1ZXVlQWN0aW9ucyhjb2xsZWN0KSB7XG4gIGZ1bmN0aW9uIGVucXVldWVBY3Rpb25zKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBlbnF1ZXVlQWN0aW9ucy50eXBlID0gJ3hzdGF0ZS5lbnF1ZXVlQWN0aW9ucyc7XG4gIGVucXVldWVBY3Rpb25zLmNvbGxlY3QgPSBjb2xsZWN0O1xuICBlbnF1ZXVlQWN0aW9ucy5yZXNvbHZlID0gcmVzb2x2ZUVucXVldWVBY3Rpb25zO1xuICByZXR1cm4gZW5xdWV1ZUFjdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVMb2coXywgc25hcHNob3QsIGFjdGlvbkFyZ3MsIGFjdGlvblBhcmFtcywge1xuICB2YWx1ZSxcbiAgbGFiZWxcbn0pIHtcbiAgcmV0dXJuIFtzbmFwc2hvdCwge1xuICAgIHZhbHVlOiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZShhY3Rpb25BcmdzLCBhY3Rpb25QYXJhbXMpIDogdmFsdWUsXG4gICAgbGFiZWxcbiAgfSwgdW5kZWZpbmVkXTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVMb2coe1xuICBsb2dnZXJcbn0sIHtcbiAgdmFsdWUsXG4gIGxhYmVsXG59KSB7XG4gIGlmIChsYWJlbCkge1xuICAgIGxvZ2dlcihsYWJlbCwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGxvZ2dlcih2YWx1ZSk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIGV4cHIgVGhlIGV4cHJlc3Npb24gZnVuY3Rpb24gdG8gZXZhbHVhdGUgd2hpY2ggd2lsbCBiZSBsb2dnZWQuIFRha2VzXG4gKiAgIGluIDIgYXJndW1lbnRzOlxuICpcbiAqICAgLSBgY3R4YCAtIHRoZSBjdXJyZW50IHN0YXRlIGNvbnRleHRcbiAqICAgLSBgZXZlbnRgIC0gdGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgYWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICpcbiAqIEBwYXJhbSBsYWJlbCBUaGUgbGFiZWwgdG8gZ2l2ZSB0byB0aGUgbG9nZ2VkIGV4cHJlc3Npb24uXG4gKi9cbmZ1bmN0aW9uIGxvZyh2YWx1ZSA9ICh7XG4gIGNvbnRleHQsXG4gIGV2ZW50XG59KSA9PiAoe1xuICBjb250ZXh0LFxuICBldmVudFxufSksIGxhYmVsKSB7XG4gIGZ1bmN0aW9uIGxvZyhfYXJncywgX3BhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgbG9nLnR5cGUgPSAneHN0YXRlLmxvZyc7XG4gIGxvZy52YWx1ZSA9IHZhbHVlO1xuICBsb2cubGFiZWwgPSBsYWJlbDtcbiAgbG9nLnJlc29sdmUgPSByZXNvbHZlTG9nO1xuICBsb2cuZXhlY3V0ZSA9IGV4ZWN1dGVMb2c7XG4gIHJldHVybiBsb2c7XG59XG5cbmV4cG9ydCB7IFNwZWNpYWxUYXJnZXRzIGFzIFMsIGVtaXQgYXMgYSwgc2VuZFBhcmVudCBhcyBiLCBlbnF1ZXVlQWN0aW9ucyBhcyBlLCBmb3J3YXJkVG8gYXMgZiwgbG9nIGFzIGwsIHNlbmRUbyBhcyBzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/log-3eec9346.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/raise-235fa0c7.development.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/xstate/dist/raise-235fa0c7.development.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ $$ACTOR_TYPE),\n/* harmony export */   A: () => (/* binding */ Actor),\n/* harmony export */   B: () => (/* binding */ formatInitialTransition),\n/* harmony export */   C: () => (/* binding */ getCandidates),\n/* harmony export */   D: () => (/* binding */ resolveStateValue),\n/* harmony export */   E: () => (/* binding */ getAllStateNodes),\n/* harmony export */   F: () => (/* binding */ createMachineSnapshot),\n/* harmony export */   G: () => (/* binding */ isInFinalState),\n/* harmony export */   H: () => (/* binding */ macrostep),\n/* harmony export */   I: () => (/* binding */ transitionNode),\n/* harmony export */   J: () => (/* binding */ resolveActionsAndContext),\n/* harmony export */   K: () => (/* binding */ createInitEvent),\n/* harmony export */   L: () => (/* binding */ microstep),\n/* harmony export */   M: () => (/* binding */ getInitialStateNodes),\n/* harmony export */   N: () => (/* binding */ NULL_EVENT),\n/* harmony export */   O: () => (/* binding */ toStatePath),\n/* harmony export */   P: () => (/* binding */ isStateId),\n/* harmony export */   Q: () => (/* binding */ getStateNodeByPath),\n/* harmony export */   R: () => (/* binding */ getPersistedSnapshot),\n/* harmony export */   S: () => (/* binding */ STATE_DELIMITER),\n/* harmony export */   T: () => (/* binding */ resolveReferencedActor),\n/* harmony export */   U: () => (/* binding */ executingCustomAction),\n/* harmony export */   V: () => (/* binding */ XSTATE_ERROR),\n/* harmony export */   W: () => (/* binding */ createErrorActorEvent),\n/* harmony export */   X: () => (/* binding */ XSTATE_STOP),\n/* harmony export */   Y: () => (/* binding */ ProcessingStatus),\n/* harmony export */   Z: () => (/* binding */ cloneMachineSnapshot),\n/* harmony export */   a: () => (/* binding */ cancel),\n/* harmony export */   b: () => (/* binding */ spawnChild),\n/* harmony export */   c: () => (/* binding */ createActor),\n/* harmony export */   d: () => (/* binding */ and),\n/* harmony export */   e: () => (/* binding */ stateIn),\n/* harmony export */   f: () => (/* binding */ isMachineSnapshot),\n/* harmony export */   g: () => (/* binding */ getStateNodes),\n/* harmony export */   h: () => (/* binding */ getAllOwnEventDescriptors),\n/* harmony export */   i: () => (/* binding */ interpret),\n/* harmony export */   j: () => (/* binding */ matchesState),\n/* harmony export */   k: () => (/* binding */ toObserver),\n/* harmony export */   l: () => (/* binding */ stop),\n/* harmony export */   m: () => (/* binding */ matchesEventDescriptor),\n/* harmony export */   n: () => (/* binding */ not),\n/* harmony export */   o: () => (/* binding */ or),\n/* harmony export */   p: () => (/* binding */ pathToStateValue),\n/* harmony export */   q: () => (/* binding */ mapValues),\n/* harmony export */   r: () => (/* binding */ raise),\n/* harmony export */   s: () => (/* binding */ stopChild),\n/* harmony export */   t: () => (/* binding */ toArray),\n/* harmony export */   u: () => (/* binding */ formatTransitions),\n/* harmony export */   v: () => (/* binding */ toTransitionConfigArray),\n/* harmony export */   w: () => (/* binding */ formatTransition),\n/* harmony export */   x: () => (/* binding */ evaluateGuard),\n/* harmony export */   y: () => (/* binding */ createInvokeId),\n/* harmony export */   z: () => (/* binding */ getDelayedTransitions)\n/* harmony export */ });\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dev/dist/xstate-dev.development.esm.js */ \"(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\n\nclass Mailbox {\n  constructor(_process) {\n    this._process = _process;\n    this._active = false;\n    this._current = null;\n    this._last = null;\n  }\n  start() {\n    this._active = true;\n    this.flush();\n  }\n  clear() {\n    // we can't set _current to null because we might be currently processing\n    // and enqueue following clear shouldn't start processing the enqueued item immediately\n    if (this._current) {\n      this._current.next = null;\n      this._last = this._current;\n    }\n  }\n  enqueue(event) {\n    const enqueued = {\n      value: event,\n      next: null\n    };\n    if (this._current) {\n      this._last.next = enqueued;\n      this._last = enqueued;\n      return;\n    }\n    this._current = enqueued;\n    this._last = enqueued;\n    if (this._active) {\n      this.flush();\n    }\n  }\n  flush() {\n    while (this._current) {\n      // atm the given _process is responsible for implementing proper try/catch handling\n      // we assume here that this won't throw in a way that can affect this mailbox\n      const consumed = this._current;\n      this._process(consumed.value);\n      this._current = consumed.next;\n    }\n    this._last = null;\n  }\n}\n\nconst STATE_DELIMITER = '.';\nconst TARGETLESS_KEY = '';\nconst NULL_EVENT = '';\nconst STATE_IDENTIFIER = '#';\nconst WILDCARD = '*';\nconst XSTATE_INIT = 'xstate.init';\nconst XSTATE_ERROR = 'xstate.error';\nconst XSTATE_STOP = 'xstate.stop';\n\n/**\n * Returns an event that represents an implicit event that is sent after the\n * specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */\nfunction createAfterEvent(delayRef, id) {\n  return {\n    type: `xstate.after.${delayRef}.${id}`\n  };\n}\n\n/**\n * Returns an event that represents that a final state node has been reached in\n * the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param output The data to pass into the event\n */\nfunction createDoneStateEvent(id, output) {\n  return {\n    type: `xstate.done.state.${id}`,\n    output\n  };\n}\n\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state\n * node, but not when it is canceled.\n *\n * @param invokeId The invoked service ID\n * @param output The data to pass into the event\n */\nfunction createDoneActorEvent(invokeId, output) {\n  return {\n    type: `xstate.done.actor.${invokeId}`,\n    output,\n    actorId: invokeId\n  };\n}\nfunction createErrorActorEvent(id, error) {\n  return {\n    type: `xstate.error.actor.${id}`,\n    error,\n    actorId: id\n  };\n}\nfunction createInitEvent(input) {\n  return {\n    type: XSTATE_INIT,\n    input\n  };\n}\n\n/**\n * This function makes sure that unhandled errors are thrown in a separate\n * macrotask. It allows those errors to be detected by global error handlers and\n * reported to bug tracking services without interrupting our own stack of\n * execution.\n *\n * @param err Error to be thrown\n */\nfunction reportUnhandledError(err) {\n  setTimeout(() => {\n    throw err;\n  });\n}\n\nconst symbolObservable = (() => typeof Symbol === 'function' && Symbol.observable || '@@observable')();\n\nfunction matchesState(parentStateId, childStateId) {\n  const parentStateValue = toStateValue(parentStateId);\n  const childStateValue = toStateValue(childStateId);\n  if (typeof childStateValue === 'string') {\n    if (typeof parentStateValue === 'string') {\n      return childStateValue === parentStateValue;\n    }\n\n    // Parent more specific than child\n    return false;\n  }\n  if (typeof parentStateValue === 'string') {\n    return parentStateValue in childStateValue;\n  }\n  return Object.keys(parentStateValue).every(key => {\n    if (!(key in childStateValue)) {\n      return false;\n    }\n    return matchesState(parentStateValue[key], childStateValue[key]);\n  });\n}\nfunction toStatePath(stateId) {\n  if (isArray(stateId)) {\n    return stateId;\n  }\n  const result = [];\n  let segment = '';\n  for (let i = 0; i < stateId.length; i++) {\n    const char = stateId.charCodeAt(i);\n    switch (char) {\n      // \\\n      case 92:\n        // consume the next character\n        segment += stateId[i + 1];\n        // and skip over it\n        i++;\n        continue;\n      // .\n      case 46:\n        result.push(segment);\n        segment = '';\n        continue;\n    }\n    segment += stateId[i];\n  }\n  result.push(segment);\n  return result;\n}\nfunction toStateValue(stateValue) {\n  if (isMachineSnapshot(stateValue)) {\n    return stateValue.value;\n  }\n  if (typeof stateValue !== 'string') {\n    return stateValue;\n  }\n  const statePath = toStatePath(stateValue);\n  return pathToStateValue(statePath);\n}\nfunction pathToStateValue(statePath) {\n  if (statePath.length === 1) {\n    return statePath[0];\n  }\n  const value = {};\n  let marker = value;\n  for (let i = 0; i < statePath.length - 1; i++) {\n    if (i === statePath.length - 2) {\n      marker[statePath[i]] = statePath[i + 1];\n    } else {\n      const previous = marker;\n      marker = {};\n      previous[statePath[i]] = marker;\n    }\n  }\n  return value;\n}\nfunction mapValues(collection, iteratee) {\n  const result = {};\n  const collectionKeys = Object.keys(collection);\n  for (let i = 0; i < collectionKeys.length; i++) {\n    const key = collectionKeys[i];\n    result[key] = iteratee(collection[key], key, collection, i);\n  }\n  return result;\n}\nfunction toArrayStrict(value) {\n  if (isArray(value)) {\n    return value;\n  }\n  return [value];\n}\nfunction toArray(value) {\n  if (value === undefined) {\n    return [];\n  }\n  return toArrayStrict(value);\n}\nfunction resolveOutput(mapper, context, event, self) {\n  if (typeof mapper === 'function') {\n    return mapper({\n      context,\n      event,\n      self\n    });\n  }\n  if (!!mapper && typeof mapper === 'object' && Object.values(mapper).some(val => typeof val === 'function')) {\n    console.warn(`Dynamically mapping values to individual properties is deprecated. Use a single function that returns the mapped object instead.\\nFound object containing properties whose values are possibly mapping functions: ${Object.entries(mapper).filter(([, value]) => typeof value === 'function').map(([key, value]) => `\\n - ${key}: ${value.toString().replace(/\\n\\s*/g, '')}`).join('')}`);\n  }\n  return mapper;\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nfunction isErrorActorEvent(event) {\n  return event.type.startsWith('xstate.error.actor');\n}\nfunction toTransitionConfigArray(configLike) {\n  return toArrayStrict(configLike).map(transitionLike => {\n    if (typeof transitionLike === 'undefined' || typeof transitionLike === 'string') {\n      return {\n        target: transitionLike\n      };\n    }\n    return transitionLike;\n  });\n}\nfunction normalizeTarget(target) {\n  if (target === undefined || target === TARGETLESS_KEY) {\n    return undefined;\n  }\n  return toArray(target);\n}\nfunction toObserver(nextHandler, errorHandler, completionHandler) {\n  const isObserver = typeof nextHandler === 'object';\n  const self = isObserver ? nextHandler : undefined;\n  return {\n    next: (isObserver ? nextHandler.next : nextHandler)?.bind(self),\n    error: (isObserver ? nextHandler.error : errorHandler)?.bind(self),\n    complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(self)\n  };\n}\nfunction createInvokeId(stateNodeId, index) {\n  return `${index}.${stateNodeId}`;\n}\nfunction resolveReferencedActor(machine, src) {\n  const match = src.match(/^xstate\\.invoke\\.(\\d+)\\.(.*)/);\n  if (!match) {\n    return machine.implementations.actors[src];\n  }\n  const [, indexStr, nodeId] = match;\n  const node = machine.getStateNodeById(nodeId);\n  const invokeConfig = node.config.invoke;\n  return (Array.isArray(invokeConfig) ? invokeConfig[indexStr] : invokeConfig).src;\n}\nfunction getAllOwnEventDescriptors(snapshot) {\n  return [...new Set([...snapshot._nodes.flatMap(sn => sn.ownEvents)])];\n}\n\n/**\n * Checks if an event type matches an event descriptor, supporting wildcards.\n * Event descriptors can be:\n *\n * - Exact matches: \"event.type\"\n * - Wildcard: \"*\"\n * - Partial matches: \"event.*\"\n *\n * @param eventType - The actual event type string\n * @param descriptor - The event descriptor to match against\n * @returns True if the event type matches the descriptor\n */\nfunction matchesEventDescriptor(eventType, descriptor) {\n  if (descriptor === eventType) {\n    return true;\n  }\n  if (descriptor === WILDCARD) {\n    return true;\n  }\n  if (!descriptor.endsWith('.*')) {\n    return false;\n  }\n  if (/.*\\*.+/.test(descriptor)) {\n    console.warn(`Wildcards can only be the last token of an event descriptor (e.g., \"event.*\") or the entire event descriptor (\"*\"). Check the \"${descriptor}\" event.`);\n  }\n  const partialEventTokens = descriptor.split('.');\n  const eventTokens = eventType.split('.');\n  for (let tokenIndex = 0; tokenIndex < partialEventTokens.length; tokenIndex++) {\n    const partialEventToken = partialEventTokens[tokenIndex];\n    const eventToken = eventTokens[tokenIndex];\n    if (partialEventToken === '*') {\n      const isLastToken = tokenIndex === partialEventTokens.length - 1;\n      if (!isLastToken) {\n        console.warn(`Infix wildcards in transition events are not allowed. Check the \"${descriptor}\" transition.`);\n      }\n      return isLastToken;\n    }\n    if (partialEventToken !== eventToken) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction createScheduledEventId(actorRef, id) {\n  return `${actorRef.sessionId}.${id}`;\n}\nlet idCounter = 0;\nfunction createSystem(rootActor, options) {\n  const children = new Map();\n  const keyedActors = new Map();\n  const reverseKeyedActors = new WeakMap();\n  const inspectionObservers = new Set();\n  const timerMap = {};\n  const {\n    clock,\n    logger\n  } = options;\n  const scheduler = {\n    schedule: (source, target, event, delay, id = Math.random().toString(36).slice(2)) => {\n      const scheduledEvent = {\n        source,\n        target,\n        event,\n        delay,\n        id,\n        startedAt: Date.now()\n      };\n      const scheduledEventId = createScheduledEventId(source, id);\n      system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;\n      const timeout = clock.setTimeout(() => {\n        delete timerMap[scheduledEventId];\n        delete system._snapshot._scheduledEvents[scheduledEventId];\n        system._relay(source, target, event);\n      }, delay);\n      timerMap[scheduledEventId] = timeout;\n    },\n    cancel: (source, id) => {\n      const scheduledEventId = createScheduledEventId(source, id);\n      const timeout = timerMap[scheduledEventId];\n      delete timerMap[scheduledEventId];\n      delete system._snapshot._scheduledEvents[scheduledEventId];\n      if (timeout !== undefined) {\n        clock.clearTimeout(timeout);\n      }\n    },\n    cancelAll: actorRef => {\n      for (const scheduledEventId in system._snapshot._scheduledEvents) {\n        const scheduledEvent = system._snapshot._scheduledEvents[scheduledEventId];\n        if (scheduledEvent.source === actorRef) {\n          scheduler.cancel(actorRef, scheduledEvent.id);\n        }\n      }\n    }\n  };\n  const sendInspectionEvent = event => {\n    if (!inspectionObservers.size) {\n      return;\n    }\n    const resolvedInspectionEvent = {\n      ...event,\n      rootId: rootActor.sessionId\n    };\n    inspectionObservers.forEach(observer => observer.next?.(resolvedInspectionEvent));\n  };\n  const system = {\n    _snapshot: {\n      _scheduledEvents: (options?.snapshot && options.snapshot.scheduler) ?? {}\n    },\n    _bookId: () => `x:${idCounter++}`,\n    _register: (sessionId, actorRef) => {\n      children.set(sessionId, actorRef);\n      return sessionId;\n    },\n    _unregister: actorRef => {\n      children.delete(actorRef.sessionId);\n      const systemId = reverseKeyedActors.get(actorRef);\n      if (systemId !== undefined) {\n        keyedActors.delete(systemId);\n        reverseKeyedActors.delete(actorRef);\n      }\n    },\n    get: systemId => {\n      return keyedActors.get(systemId);\n    },\n    getAll: () => {\n      return Object.fromEntries(keyedActors.entries());\n    },\n    _set: (systemId, actorRef) => {\n      const existing = keyedActors.get(systemId);\n      if (existing && existing !== actorRef) {\n        throw new Error(`Actor with system ID '${systemId}' already exists.`);\n      }\n      keyedActors.set(systemId, actorRef);\n      reverseKeyedActors.set(actorRef, systemId);\n    },\n    inspect: observerOrFn => {\n      const observer = toObserver(observerOrFn);\n      inspectionObservers.add(observer);\n      return {\n        unsubscribe() {\n          inspectionObservers.delete(observer);\n        }\n      };\n    },\n    _sendInspectionEvent: sendInspectionEvent,\n    _relay: (source, target, event) => {\n      system._sendInspectionEvent({\n        type: '@xstate.event',\n        sourceRef: source,\n        actorRef: target,\n        event\n      });\n      target._send(event);\n    },\n    scheduler,\n    getSnapshot: () => {\n      return {\n        _scheduledEvents: {\n          ...system._snapshot._scheduledEvents\n        }\n      };\n    },\n    start: () => {\n      const scheduledEvents = system._snapshot._scheduledEvents;\n      system._snapshot._scheduledEvents = {};\n      for (const scheduledId in scheduledEvents) {\n        const {\n          source,\n          target,\n          event,\n          delay,\n          id\n        } = scheduledEvents[scheduledId];\n        scheduler.schedule(source, target, event, delay, id);\n      }\n    },\n    _clock: clock,\n    _logger: logger\n  };\n  return system;\n}\n\n// those are needed to make JSDoc `@link` work properly\n\nlet executingCustomAction = false;\nconst $$ACTOR_TYPE = 1;\n\n// those values are currently used by @xstate/react directly so it's important to keep the assigned values in sync\nlet ProcessingStatus = /*#__PURE__*/function (ProcessingStatus) {\n  ProcessingStatus[ProcessingStatus[\"NotStarted\"] = 0] = \"NotStarted\";\n  ProcessingStatus[ProcessingStatus[\"Running\"] = 1] = \"Running\";\n  ProcessingStatus[ProcessingStatus[\"Stopped\"] = 2] = \"Stopped\";\n  return ProcessingStatus;\n}({});\nconst defaultOptions = {\n  clock: {\n    setTimeout: (fn, ms) => {\n      return setTimeout(fn, ms);\n    },\n    clearTimeout: id => {\n      return clearTimeout(id);\n    }\n  },\n  logger: console.log.bind(console),\n  devTools: false\n};\n\n/**\n * An Actor is a running process that can receive events, send events and change\n * its behavior based on the events it receives, which can cause effects outside\n * of the actor. When you run a state machine, it becomes an actor.\n */\nclass Actor {\n  /**\n   * Creates a new actor instance for the given logic with the provided options,\n   * if any.\n   *\n   * @param logic The logic to create an actor from\n   * @param options Actor options\n   */\n  constructor(logic, options) {\n    this.logic = logic;\n    /** The current internal state of the actor. */\n    this._snapshot = void 0;\n    /**\n     * The clock that is responsible for setting and clearing timeouts, such as\n     * delayed events and transitions.\n     */\n    this.clock = void 0;\n    this.options = void 0;\n    /** The unique identifier for this actor relative to its parent. */\n    this.id = void 0;\n    this.mailbox = new Mailbox(this._process.bind(this));\n    this.observers = new Set();\n    this.eventListeners = new Map();\n    this.logger = void 0;\n    /** @internal */\n    this._processingStatus = ProcessingStatus.NotStarted;\n    // Actor Ref\n    this._parent = void 0;\n    /** @internal */\n    this._syncSnapshot = void 0;\n    this.ref = void 0;\n    // TODO: add typings for system\n    this._actorScope = void 0;\n    this.systemId = void 0;\n    /** The globally unique process ID for this invocation. */\n    this.sessionId = void 0;\n    /** The system to which this actor belongs. */\n    this.system = void 0;\n    this._doneEvent = void 0;\n    this.src = void 0;\n    // array of functions to defer\n    this._deferred = [];\n    const resolvedOptions = {\n      ...defaultOptions,\n      ...options\n    };\n    const {\n      clock,\n      logger,\n      parent,\n      syncSnapshot,\n      id,\n      systemId,\n      inspect\n    } = resolvedOptions;\n    this.system = parent ? parent.system : createSystem(this, {\n      clock,\n      logger\n    });\n    if (inspect && !parent) {\n      // Always inspect at the system-level\n      this.system.inspect(toObserver(inspect));\n    }\n    this.sessionId = this.system._bookId();\n    this.id = id ?? this.sessionId;\n    this.logger = options?.logger ?? this.system._logger;\n    this.clock = options?.clock ?? this.system._clock;\n    this._parent = parent;\n    this._syncSnapshot = syncSnapshot;\n    this.options = resolvedOptions;\n    this.src = resolvedOptions.src ?? logic;\n    this.ref = this;\n    this._actorScope = {\n      self: this,\n      id: this.id,\n      sessionId: this.sessionId,\n      logger: this.logger,\n      defer: fn => {\n        this._deferred.push(fn);\n      },\n      system: this.system,\n      stopChild: child => {\n        if (child._parent !== this) {\n          throw new Error(`Cannot stop child actor ${child.id} of ${this.id} because it is not a child`);\n        }\n        child._stop();\n      },\n      emit: emittedEvent => {\n        const listeners = this.eventListeners.get(emittedEvent.type);\n        const wildcardListener = this.eventListeners.get('*');\n        if (!listeners && !wildcardListener) {\n          return;\n        }\n        const allListeners = [...(listeners ? listeners.values() : []), ...(wildcardListener ? wildcardListener.values() : [])];\n        for (const handler of allListeners) {\n          try {\n            handler(emittedEvent);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n      },\n      actionExecutor: action => {\n        const exec = () => {\n          this._actorScope.system._sendInspectionEvent({\n            type: '@xstate.action',\n            actorRef: this,\n            action: {\n              type: action.type,\n              params: action.params\n            }\n          });\n          if (!action.exec) {\n            return;\n          }\n          const saveExecutingCustomAction = executingCustomAction;\n          try {\n            executingCustomAction = true;\n            action.exec(action.info, action.params);\n          } finally {\n            executingCustomAction = saveExecutingCustomAction;\n          }\n        };\n        if (this._processingStatus === ProcessingStatus.Running) {\n          exec();\n        } else {\n          this._deferred.push(exec);\n        }\n      }\n    };\n\n    // Ensure that the send method is bound to this Actor instance\n    // if destructured\n    this.send = this.send.bind(this);\n    this.system._sendInspectionEvent({\n      type: '@xstate.actor',\n      actorRef: this\n    });\n    if (systemId) {\n      this.systemId = systemId;\n      this.system._set(systemId, this);\n    }\n    this._initState(options?.snapshot ?? options?.state);\n    if (systemId && this._snapshot.status !== 'active') {\n      this.system._unregister(this);\n    }\n  }\n  _initState(persistedState) {\n    try {\n      this._snapshot = persistedState ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(persistedState, this._actorScope) : persistedState : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);\n    } catch (err) {\n      // if we get here then it means that we assign a value to this._snapshot that is not of the correct type\n      // we can't get the true `TSnapshot & { status: 'error'; }`, it's impossible\n      // so right now this is a lie of sorts\n      this._snapshot = {\n        status: 'error',\n        output: undefined,\n        error: err\n      };\n    }\n  }\n  update(snapshot, event) {\n    // Update state\n    this._snapshot = snapshot;\n\n    // Execute deferred effects\n    let deferredFn;\n    while (deferredFn = this._deferred.shift()) {\n      try {\n        deferredFn();\n      } catch (err) {\n        // this error can only be caught when executing *initial* actions\n        // it's the only time when we call actions provided by the user through those deferreds\n        // when the actor is already running we always execute them synchronously while transitioning\n        // no \"builtin deferred\" should actually throw an error since they are either safe\n        // or the control flow is passed through the mailbox and errors should be caught by the `_process` used by the mailbox\n        this._deferred.length = 0;\n        this._snapshot = {\n          ...snapshot,\n          status: 'error',\n          error: err\n        };\n      }\n    }\n    switch (this._snapshot.status) {\n      case 'active':\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n        break;\n      case 'done':\n        // next observers are meant to be notified about done snapshots\n        // this can be seen as something that is different from how observable work\n        // but with observables `complete` callback is called without any arguments\n        // it's more ergonomic for XState to treat a done snapshot as a \"next\" value\n        // and the completion event as something that is separate,\n        // something that merely follows emitting that done snapshot\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n        this._stopProcedure();\n        this._complete();\n        this._doneEvent = createDoneActorEvent(this.id, this._snapshot.output);\n        if (this._parent) {\n          this.system._relay(this, this._parent, this._doneEvent);\n        }\n        break;\n      case 'error':\n        this._error(this._snapshot.error);\n        break;\n    }\n    this.system._sendInspectionEvent({\n      type: '@xstate.snapshot',\n      actorRef: this,\n      event,\n      snapshot\n    });\n  }\n\n  /**\n   * Subscribe an observer to an actor’s snapshot values.\n   *\n   * @remarks\n   * The observer will receive the actor’s snapshot value when it is emitted.\n   * The observer can be:\n   *\n   * - A plain function that receives the latest snapshot, or\n   * - An observer object whose `.next(snapshot)` method receives the latest\n   *   snapshot\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as a plain function\n   * const subscription = actor.subscribe((snapshot) => {\n   *   console.log(snapshot);\n   * });\n   * ```\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as an object\n   * const subscription = actor.subscribe({\n   *   next(snapshot) {\n   *     console.log(snapshot);\n   *   },\n   *   error(err) {\n   *     // ...\n   *   },\n   *   complete() {\n   *     // ...\n   *   }\n   * });\n   * ```\n   *\n   * The return value of `actor.subscribe(observer)` is a subscription object\n   * that has an `.unsubscribe()` method. You can call\n   * `subscription.unsubscribe()` to unsubscribe the observer:\n   *\n   * @example\n   *\n   * ```ts\n   * const subscription = actor.subscribe((snapshot) => {\n   *   // ...\n   * });\n   *\n   * // Unsubscribe the observer\n   * subscription.unsubscribe();\n   * ```\n   *\n   * When the actor is stopped, all of its observers will automatically be\n   * unsubscribed.\n   *\n   * @param observer - Either a plain function that receives the latest\n   *   snapshot, or an observer object whose `.next(snapshot)` method receives\n   *   the latest snapshot\n   */\n\n  subscribe(nextListenerOrObserver, errorListener, completeListener) {\n    const observer = toObserver(nextListenerOrObserver, errorListener, completeListener);\n    if (this._processingStatus !== ProcessingStatus.Stopped) {\n      this.observers.add(observer);\n    } else {\n      switch (this._snapshot.status) {\n        case 'done':\n          try {\n            observer.complete?.();\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n          break;\n        case 'error':\n          {\n            const err = this._snapshot.error;\n            if (!observer.error) {\n              reportUnhandledError(err);\n            } else {\n              try {\n                observer.error(err);\n              } catch (err) {\n                reportUnhandledError(err);\n              }\n            }\n            break;\n          }\n      }\n    }\n    return {\n      unsubscribe: () => {\n        this.observers.delete(observer);\n      }\n    };\n  }\n  on(type, handler) {\n    let listeners = this.eventListeners.get(type);\n    if (!listeners) {\n      listeners = new Set();\n      this.eventListeners.set(type, listeners);\n    }\n    const wrappedHandler = handler.bind(undefined);\n    listeners.add(wrappedHandler);\n    return {\n      unsubscribe: () => {\n        listeners.delete(wrappedHandler);\n      }\n    };\n  }\n\n  /** Starts the Actor from the initial state */\n  start() {\n    if (this._processingStatus === ProcessingStatus.Running) {\n      // Do not restart the service if it is already started\n      return this;\n    }\n    if (this._syncSnapshot) {\n      this.subscribe({\n        next: snapshot => {\n          if (snapshot.status === 'active') {\n            this.system._relay(this, this._parent, {\n              type: `xstate.snapshot.${this.id}`,\n              snapshot\n            });\n          }\n        },\n        error: () => {}\n      });\n    }\n    this.system._register(this.sessionId, this);\n    if (this.systemId) {\n      this.system._set(this.systemId, this);\n    }\n    this._processingStatus = ProcessingStatus.Running;\n\n    // TODO: this isn't correct when rehydrating\n    const initEvent = createInitEvent(this.options.input);\n    this.system._sendInspectionEvent({\n      type: '@xstate.event',\n      sourceRef: this._parent,\n      actorRef: this,\n      event: initEvent\n    });\n    const status = this._snapshot.status;\n    switch (status) {\n      case 'done':\n        // a state machine can be \"done\" upon initialization (it could reach a final state using initial microsteps)\n        // we still need to complete observers, flush deferreds etc\n        this.update(this._snapshot, initEvent);\n        // TODO: rethink cleanup of observers, mailbox, etc\n        return this;\n      case 'error':\n        this._error(this._snapshot.error);\n        return this;\n    }\n    if (!this._parent) {\n      this.system.start();\n    }\n    if (this.logic.start) {\n      try {\n        this.logic.start(this._snapshot, this._actorScope);\n      } catch (err) {\n        this._snapshot = {\n          ...this._snapshot,\n          status: 'error',\n          error: err\n        };\n        this._error(err);\n        return this;\n      }\n    }\n\n    // TODO: this notifies all subscribers but usually this is redundant\n    // there is no real change happening here\n    // we need to rethink if this needs to be refactored\n    this.update(this._snapshot, initEvent);\n    if (this.options.devTools) {\n      this.attachDevTools();\n    }\n    this.mailbox.start();\n    return this;\n  }\n  _process(event) {\n    let nextState;\n    let caughtError;\n    try {\n      nextState = this.logic.transition(this._snapshot, event, this._actorScope);\n    } catch (err) {\n      // we wrap it in a box so we can rethrow it later even if falsy value gets caught here\n      caughtError = {\n        err\n      };\n    }\n    if (caughtError) {\n      const {\n        err\n      } = caughtError;\n      this._snapshot = {\n        ...this._snapshot,\n        status: 'error',\n        error: err\n      };\n      this._error(err);\n      return;\n    }\n    this.update(nextState, event);\n    if (event.type === XSTATE_STOP) {\n      this._stopProcedure();\n      this._complete();\n    }\n  }\n  _stop() {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      return this;\n    }\n    this.mailbox.clear();\n    if (this._processingStatus === ProcessingStatus.NotStarted) {\n      this._processingStatus = ProcessingStatus.Stopped;\n      return this;\n    }\n    this.mailbox.enqueue({\n      type: XSTATE_STOP\n    });\n    return this;\n  }\n\n  /** Stops the Actor and unsubscribe all listeners. */\n  stop() {\n    if (this._parent) {\n      throw new Error('A non-root actor cannot be stopped directly.');\n    }\n    return this._stop();\n  }\n  _complete() {\n    for (const observer of this.observers) {\n      try {\n        observer.complete?.();\n      } catch (err) {\n        reportUnhandledError(err);\n      }\n    }\n    this.observers.clear();\n  }\n  _reportError(err) {\n    if (!this.observers.size) {\n      if (!this._parent) {\n        reportUnhandledError(err);\n      }\n      return;\n    }\n    let reportError = false;\n    for (const observer of this.observers) {\n      const errorListener = observer.error;\n      reportError ||= !errorListener;\n      try {\n        errorListener?.(err);\n      } catch (err2) {\n        reportUnhandledError(err2);\n      }\n    }\n    this.observers.clear();\n    if (reportError) {\n      reportUnhandledError(err);\n    }\n  }\n  _error(err) {\n    this._stopProcedure();\n    this._reportError(err);\n    if (this._parent) {\n      this.system._relay(this, this._parent, createErrorActorEvent(this.id, err));\n    }\n  }\n  // TODO: atm children don't belong entirely to the actor so\n  // in a way - it's not even super aware of them\n  // so we can't stop them from here but we really should!\n  // right now, they are being stopped within the machine's transition\n  // but that could throw and leave us with \"orphaned\" active actors\n  _stopProcedure() {\n    if (this._processingStatus !== ProcessingStatus.Running) {\n      // Actor already stopped; do nothing\n      return this;\n    }\n\n    // Cancel all delayed events\n    this.system.scheduler.cancelAll(this);\n\n    // TODO: mailbox.reset\n    this.mailbox.clear();\n    // TODO: after `stop` we must prepare ourselves for receiving events again\n    // events sent *after* stop signal must be queued\n    // it seems like this should be the common behavior for all of our consumers\n    // so perhaps this should be unified somehow for all of them\n    this.mailbox = new Mailbox(this._process.bind(this));\n    this._processingStatus = ProcessingStatus.Stopped;\n    this.system._unregister(this);\n    return this;\n  }\n\n  /** @internal */\n  _send(event) {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      // do nothing\n      {\n        const eventString = JSON.stringify(event);\n        console.warn(`Event \"${event.type}\" was sent to stopped actor \"${this.id} (${this.sessionId})\". This actor has already reached its final state, and will not transition.\\nEvent: ${eventString}`);\n      }\n      return;\n    }\n    this.mailbox.enqueue(event);\n  }\n\n  /**\n   * Sends an event to the running Actor to trigger a transition.\n   *\n   * @param event The event to send\n   */\n  send(event) {\n    if (typeof event === 'string') {\n      throw new Error(`Only event objects may be sent to actors; use .send({ type: \"${event}\" }) instead`);\n    }\n    this.system._relay(undefined, this, event);\n  }\n  attachDevTools() {\n    const {\n      devTools\n    } = this.options;\n    if (devTools) {\n      const resolvedDevToolsAdapter = typeof devTools === 'function' ? devTools : _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.devToolsAdapter;\n      resolvedDevToolsAdapter(this);\n    }\n  }\n  toJSON() {\n    return {\n      xstate$$type: $$ACTOR_TYPE,\n      id: this.id\n    };\n  }\n\n  /**\n   * Obtain the internal state of the actor, which can be persisted.\n   *\n   * @remarks\n   * The internal state can be persisted from any actor, not only machines.\n   *\n   * Note that the persisted state is not the same as the snapshot from\n   * {@link Actor.getSnapshot}. Persisted state represents the internal state of\n   * the actor, while snapshots represent the actor's last emitted value.\n   *\n   * Can be restored with {@link ActorOptions.state}\n   * @see https://stately.ai/docs/persistence\n   */\n\n  getPersistedSnapshot(options) {\n    return this.logic.getPersistedSnapshot(this._snapshot, options);\n  }\n  [symbolObservable]() {\n    return this;\n  }\n\n  /**\n   * Read an actor’s snapshot synchronously.\n   *\n   * @remarks\n   * The snapshot represent an actor's last emitted value.\n   *\n   * When an actor receives an event, its internal state may change. An actor\n   * may emit a snapshot when a state transition occurs.\n   *\n   * Note that some actors, such as callback actors generated with\n   * `fromCallback`, will not emit snapshots.\n   * @see {@link Actor.subscribe} to subscribe to an actor’s snapshot values.\n   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).\n   */\n  getSnapshot() {\n    if (!this._snapshot) {\n      throw new Error(`Snapshot can't be read while the actor initializes itself`);\n    }\n    return this._snapshot;\n  }\n}\n/**\n * Creates a new actor instance for the given actor logic with the provided\n * options, if any.\n *\n * @remarks\n * When you create an actor from actor logic via `createActor(logic)`, you\n * implicitly create an actor system where the created actor is the root actor.\n * Any actors spawned from this root actor and its descendants are part of that\n * actor system.\n * @example\n *\n * ```ts\n * import { createActor } from 'xstate';\n * import { someActorLogic } from './someActorLogic.ts';\n *\n * // Creating the actor, which implicitly creates an actor system with itself as the root actor\n * const actor = createActor(someActorLogic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n *\n * // Actors must be started by calling `actor.start()`, which will also start the actor system.\n * actor.start();\n *\n * // Actors can receive events\n * actor.send({ type: 'someEvent' });\n *\n * // You can stop root actors by calling `actor.stop()`, which will also stop the actor system and all actors in that system.\n * actor.stop();\n * ```\n *\n * @param logic - The actor logic to create an actor from. For a state machine\n *   actor logic creator, see {@link createMachine}. Other actor logic creators\n *   include {@link fromCallback}, {@link fromEventObservable},\n *   {@link fromObservable}, {@link fromPromise}, and {@link fromTransition}.\n * @param options - Actor options\n */\nfunction createActor(logic, ...[options]) {\n  return new Actor(logic, options);\n}\n\n/**\n * Creates a new Interpreter instance for the given machine with the provided\n * options, if any.\n *\n * @deprecated Use `createActor` instead\n * @alias\n */\nconst interpret = createActor;\n\n/**\n * @deprecated Use `Actor` instead.\n * @alias\n */\n\nfunction resolveCancel(_, snapshot, actionArgs, actionParams, {\n  sendId\n}) {\n  const resolvedSendId = typeof sendId === 'function' ? sendId(actionArgs, actionParams) : sendId;\n  return [snapshot, {\n    sendId: resolvedSendId\n  }, undefined];\n}\nfunction executeCancel(actorScope, params) {\n  actorScope.defer(() => {\n    actorScope.system.scheduler.cancel(actorScope.self, params.sendId);\n  });\n}\n/**\n * Cancels a delayed `sendTo(...)` action that is waiting to be executed. The\n * canceled `sendTo(...)` action will not send its event or execute, unless the\n * `delay` has already elapsed before `cancel(...)` is called.\n *\n * @example\n *\n * ```ts\n * import { createMachine, sendTo, cancel } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     sendEvent: {\n *       actions: sendTo(\n *         'some-actor',\n *         { type: 'someEvent' },\n *         {\n *           id: 'some-id',\n *           delay: 1000\n *         }\n *       )\n *     },\n *     cancelEvent: {\n *       actions: cancel('some-id')\n *     }\n *   }\n * });\n * ```\n *\n * @param sendId The `id` of the `sendTo(...)` action to cancel.\n */\nfunction cancel(sendId) {\n  function cancel(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  cancel.type = 'xstate.cancel';\n  cancel.sendId = sendId;\n  cancel.resolve = resolveCancel;\n  cancel.execute = executeCancel;\n  return cancel;\n}\n\nfunction resolveSpawn(actorScope, snapshot, actionArgs, _actionParams, {\n  id,\n  systemId,\n  src,\n  input,\n  syncSnapshot\n}) {\n  const logic = typeof src === 'string' ? resolveReferencedActor(snapshot.machine, src) : src;\n  const resolvedId = typeof id === 'function' ? id(actionArgs) : id;\n  let actorRef;\n  let resolvedInput = undefined;\n  if (logic) {\n    resolvedInput = typeof input === 'function' ? input({\n      context: snapshot.context,\n      event: actionArgs.event,\n      self: actorScope.self\n    }) : input;\n    actorRef = createActor(logic, {\n      id: resolvedId,\n      src,\n      parent: actorScope.self,\n      syncSnapshot,\n      systemId,\n      input: resolvedInput\n    });\n  }\n  if (!actorRef) {\n    console.warn(\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-base-to-string\n    `Actor type '${src}' not found in machine '${actorScope.id}'.`);\n  }\n  return [cloneMachineSnapshot(snapshot, {\n    children: {\n      ...snapshot.children,\n      [resolvedId]: actorRef\n    }\n  }), {\n    id,\n    systemId,\n    actorRef,\n    src,\n    input: resolvedInput\n  }, undefined];\n}\nfunction executeSpawn(actorScope, {\n  actorRef\n}) {\n  if (!actorRef) {\n    return;\n  }\n  actorScope.defer(() => {\n    if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n      return;\n    }\n    actorRef.start();\n  });\n}\nfunction spawnChild(...[src, {\n  id,\n  systemId,\n  input,\n  syncSnapshot = false\n} = {}]) {\n  function spawnChild(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  spawnChild.type = 'xstate.spawnChild';\n  spawnChild.id = id;\n  spawnChild.systemId = systemId;\n  spawnChild.src = src;\n  spawnChild.input = input;\n  spawnChild.syncSnapshot = syncSnapshot;\n  spawnChild.resolve = resolveSpawn;\n  spawnChild.execute = executeSpawn;\n  return spawnChild;\n}\n\nfunction resolveStop(_, snapshot, args, actionParams, {\n  actorRef\n}) {\n  const actorRefOrString = typeof actorRef === 'function' ? actorRef(args, actionParams) : actorRef;\n  const resolvedActorRef = typeof actorRefOrString === 'string' ? snapshot.children[actorRefOrString] : actorRefOrString;\n  let children = snapshot.children;\n  if (resolvedActorRef) {\n    children = {\n      ...children\n    };\n    delete children[resolvedActorRef.id];\n  }\n  return [cloneMachineSnapshot(snapshot, {\n    children\n  }), resolvedActorRef, undefined];\n}\nfunction executeStop(actorScope, actorRef) {\n  if (!actorRef) {\n    return;\n  }\n\n  // we need to eagerly unregister it here so a new actor with the same systemId can be registered immediately\n  // since we defer actual stopping of the actor but we don't defer actor creations (and we can't do that)\n  // this could throw on `systemId` collision, for example, when dealing with reentering transitions\n  actorScope.system._unregister(actorRef);\n\n  // this allows us to prevent an actor from being started if it gets stopped within the same macrostep\n  // this can happen, for example, when the invoking state is being exited immediately by an always transition\n  if (actorRef._processingStatus !== ProcessingStatus.Running) {\n    actorScope.stopChild(actorRef);\n    return;\n  }\n  // stopping a child enqueues a stop event in the child actor's mailbox\n  // we need for all of the already enqueued events to be processed before we stop the child\n  // the parent itself might want to send some events to a child (for example from exit actions on the invoking state)\n  // and we don't want to ignore those events\n  actorScope.defer(() => {\n    actorScope.stopChild(actorRef);\n  });\n}\n/**\n * Stops a child actor.\n *\n * @param actorRef The actor to stop.\n */\nfunction stopChild(actorRef) {\n  function stop(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  stop.type = 'xstate.stopChild';\n  stop.actorRef = actorRef;\n  stop.resolve = resolveStop;\n  stop.execute = executeStop;\n  return stop;\n}\n\n/**\n * Stops a child actor.\n *\n * @deprecated Use `stopChild(...)` instead\n * @alias\n */\nconst stop = stopChild;\n\nfunction checkStateIn(snapshot, _, {\n  stateValue\n}) {\n  if (typeof stateValue === 'string' && isStateId(stateValue)) {\n    const target = snapshot.machine.getStateNodeById(stateValue);\n    return snapshot._nodes.some(sn => sn === target);\n  }\n  return snapshot.matches(stateValue);\n}\nfunction stateIn(stateValue) {\n  function stateIn() {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  stateIn.check = checkStateIn;\n  stateIn.stateValue = stateValue;\n  return stateIn;\n}\nfunction checkNot(snapshot, {\n  context,\n  event\n}, {\n  guards\n}) {\n  return !evaluateGuard(guards[0], context, event, snapshot);\n}\n\n/**\n * Higher-order guard that evaluates to `true` if the `guard` passed to it\n * evaluates to `false`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, not } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => false\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: not('someNamedGuard'),\n *       actions: () => {\n *         // will be executed if guard in `not(...)`\n *         // evaluates to `false`\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard\n */\nfunction not(guard) {\n  function not(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  not.check = checkNot;\n  not.guards = [guard];\n  return not;\n}\nfunction checkAnd(snapshot, {\n  context,\n  event\n}, {\n  guards\n}) {\n  return guards.every(guard => evaluateGuard(guard, context, event, snapshot));\n}\n\n/**\n * Higher-order guard that evaluates to `true` if all `guards` passed to it\n * evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, and } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: and([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if all guards in `and(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */\nfunction and(guards) {\n  function and(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  and.check = checkAnd;\n  and.guards = guards;\n  return and;\n}\nfunction checkOr(snapshot, {\n  context,\n  event\n}, {\n  guards\n}) {\n  return guards.some(guard => evaluateGuard(guard, context, event, snapshot));\n}\n\n/**\n * Higher-order guard that evaluates to `true` if any of the `guards` passed to\n * it evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, or } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: or([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if any of the guards in `or(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */\nfunction or(guards) {\n  function or(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  or.check = checkOr;\n  or.guards = guards;\n  return or;\n}\n\n// TODO: throw on cycles (depth check should be enough)\nfunction evaluateGuard(guard, context, event, snapshot) {\n  const {\n    machine\n  } = snapshot;\n  const isInline = typeof guard === 'function';\n  const resolved = isInline ? guard : machine.implementations.guards[typeof guard === 'string' ? guard : guard.type];\n  if (!isInline && !resolved) {\n    throw new Error(`Guard '${typeof guard === 'string' ? guard : guard.type}' is not implemented.'.`);\n  }\n  if (typeof resolved !== 'function') {\n    return evaluateGuard(resolved, context, event, snapshot);\n  }\n  const guardArgs = {\n    context,\n    event\n  };\n  const guardParams = isInline || typeof guard === 'string' ? undefined : 'params' in guard ? typeof guard.params === 'function' ? guard.params({\n    context,\n    event\n  }) : guard.params : undefined;\n  if (!('check' in resolved)) {\n    // the existing type of `.guards` assumes non-nullable `TExpressionGuard`\n    // inline guards expect `TExpressionGuard` to be set to `undefined`\n    // it's fine to cast this here, our logic makes sure that we call those 2 \"variants\" correctly\n    return resolved(guardArgs, guardParams);\n  }\n  const builtinGuard = resolved;\n  return builtinGuard.check(snapshot, guardArgs, resolved // this holds all params\n  );\n}\n\nconst isAtomicStateNode = stateNode => stateNode.type === 'atomic' || stateNode.type === 'final';\nfunction getChildren(stateNode) {\n  return Object.values(stateNode.states).filter(sn => sn.type !== 'history');\n}\nfunction getProperAncestors(stateNode, toStateNode) {\n  const ancestors = [];\n  if (toStateNode === stateNode) {\n    return ancestors;\n  }\n\n  // add all ancestors\n  let m = stateNode.parent;\n  while (m && m !== toStateNode) {\n    ancestors.push(m);\n    m = m.parent;\n  }\n  return ancestors;\n}\nfunction getAllStateNodes(stateNodes) {\n  const nodeSet = new Set(stateNodes);\n  const adjList = getAdjList(nodeSet);\n\n  // add descendants\n  for (const s of nodeSet) {\n    // if previously active, add existing child nodes\n    if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s).length)) {\n      getInitialStateNodesWithTheirAncestors(s).forEach(sn => nodeSet.add(sn));\n    } else {\n      if (s.type === 'parallel') {\n        for (const child of getChildren(s)) {\n          if (child.type === 'history') {\n            continue;\n          }\n          if (!nodeSet.has(child)) {\n            const initialStates = getInitialStateNodesWithTheirAncestors(child);\n            for (const initialStateNode of initialStates) {\n              nodeSet.add(initialStateNode);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // add all ancestors\n  for (const s of nodeSet) {\n    let m = s.parent;\n    while (m) {\n      nodeSet.add(m);\n      m = m.parent;\n    }\n  }\n  return nodeSet;\n}\nfunction getValueFromAdj(baseNode, adjList) {\n  const childStateNodes = adjList.get(baseNode);\n  if (!childStateNodes) {\n    return {}; // todo: fix?\n  }\n  if (baseNode.type === 'compound') {\n    const childStateNode = childStateNodes[0];\n    if (childStateNode) {\n      if (isAtomicStateNode(childStateNode)) {\n        return childStateNode.key;\n      }\n    } else {\n      return {};\n    }\n  }\n  const stateValue = {};\n  for (const childStateNode of childStateNodes) {\n    stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);\n  }\n  return stateValue;\n}\nfunction getAdjList(stateNodes) {\n  const adjList = new Map();\n  for (const s of stateNodes) {\n    if (!adjList.has(s)) {\n      adjList.set(s, []);\n    }\n    if (s.parent) {\n      if (!adjList.has(s.parent)) {\n        adjList.set(s.parent, []);\n      }\n      adjList.get(s.parent).push(s);\n    }\n  }\n  return adjList;\n}\nfunction getStateValue(rootNode, stateNodes) {\n  const config = getAllStateNodes(stateNodes);\n  return getValueFromAdj(rootNode, getAdjList(config));\n}\nfunction isInFinalState(stateNodeSet, stateNode) {\n  if (stateNode.type === 'compound') {\n    return getChildren(stateNode).some(s => s.type === 'final' && stateNodeSet.has(s));\n  }\n  if (stateNode.type === 'parallel') {\n    return getChildren(stateNode).every(sn => isInFinalState(stateNodeSet, sn));\n  }\n  return stateNode.type === 'final';\n}\nconst isStateId = str => str[0] === STATE_IDENTIFIER;\nfunction getCandidates(stateNode, receivedEventType) {\n  const candidates = stateNode.transitions.get(receivedEventType) || [...stateNode.transitions.keys()].filter(eventDescriptor => matchesEventDescriptor(receivedEventType, eventDescriptor)).sort((a, b) => b.length - a.length).flatMap(key => stateNode.transitions.get(key));\n  return candidates;\n}\n\n/** All delayed transitions from the config. */\nfunction getDelayedTransitions(stateNode) {\n  const afterConfig = stateNode.config.after;\n  if (!afterConfig) {\n    return [];\n  }\n  const mutateEntryExit = delay => {\n    const afterEvent = createAfterEvent(delay, stateNode.id);\n    const eventType = afterEvent.type;\n    stateNode.entry.push(raise(afterEvent, {\n      id: eventType,\n      delay\n    }));\n    stateNode.exit.push(cancel(eventType));\n    return eventType;\n  };\n  const delayedTransitions = Object.keys(afterConfig).flatMap(delay => {\n    const configTransition = afterConfig[delay];\n    const resolvedTransition = typeof configTransition === 'string' ? {\n      target: configTransition\n    } : configTransition;\n    const resolvedDelay = Number.isNaN(+delay) ? delay : +delay;\n    const eventType = mutateEntryExit(resolvedDelay);\n    return toArray(resolvedTransition).map(transition => ({\n      ...transition,\n      event: eventType,\n      delay: resolvedDelay\n    }));\n  });\n  return delayedTransitions.map(delayedTransition => {\n    const {\n      delay\n    } = delayedTransition;\n    return {\n      ...formatTransition(stateNode, delayedTransition.event, delayedTransition),\n      delay\n    };\n  });\n}\nfunction formatTransition(stateNode, descriptor, transitionConfig) {\n  const normalizedTarget = normalizeTarget(transitionConfig.target);\n  const reenter = transitionConfig.reenter ?? false;\n  const target = resolveTarget(stateNode, normalizedTarget);\n\n  // TODO: should this be part of a lint rule instead?\n  if (transitionConfig.cond) {\n    throw new Error(`State \"${stateNode.id}\" has declared \\`cond\\` for one of its transitions. This property has been renamed to \\`guard\\`. Please update your code.`);\n  }\n  const transition = {\n    ...transitionConfig,\n    actions: toArray(transitionConfig.actions),\n    guard: transitionConfig.guard,\n    target,\n    source: stateNode,\n    reenter,\n    eventType: descriptor,\n    toJSON: () => ({\n      ...transition,\n      source: `#${stateNode.id}`,\n      target: target ? target.map(t => `#${t.id}`) : undefined\n    })\n  };\n  return transition;\n}\nfunction formatTransitions(stateNode) {\n  const transitions = new Map();\n  if (stateNode.config.on) {\n    for (const descriptor of Object.keys(stateNode.config.on)) {\n      if (descriptor === NULL_EVENT) {\n        throw new Error('Null events (\"\") cannot be specified as a transition key. Use `always: { ... }` instead.');\n      }\n      const transitionsConfig = stateNode.config.on[descriptor];\n      transitions.set(descriptor, toTransitionConfigArray(transitionsConfig).map(t => formatTransition(stateNode, descriptor, t)));\n    }\n  }\n  if (stateNode.config.onDone) {\n    const descriptor = `xstate.done.state.${stateNode.id}`;\n    transitions.set(descriptor, toTransitionConfigArray(stateNode.config.onDone).map(t => formatTransition(stateNode, descriptor, t)));\n  }\n  for (const invokeDef of stateNode.invoke) {\n    if (invokeDef.onDone) {\n      const descriptor = `xstate.done.actor.${invokeDef.id}`;\n      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onDone).map(t => formatTransition(stateNode, descriptor, t)));\n    }\n    if (invokeDef.onError) {\n      const descriptor = `xstate.error.actor.${invokeDef.id}`;\n      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onError).map(t => formatTransition(stateNode, descriptor, t)));\n    }\n    if (invokeDef.onSnapshot) {\n      const descriptor = `xstate.snapshot.${invokeDef.id}`;\n      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onSnapshot).map(t => formatTransition(stateNode, descriptor, t)));\n    }\n  }\n  for (const delayedTransition of stateNode.after) {\n    let existing = transitions.get(delayedTransition.eventType);\n    if (!existing) {\n      existing = [];\n      transitions.set(delayedTransition.eventType, existing);\n    }\n    existing.push(delayedTransition);\n  }\n  return transitions;\n}\nfunction formatInitialTransition(stateNode, _target) {\n  const resolvedTarget = typeof _target === 'string' ? stateNode.states[_target] : _target ? stateNode.states[_target.target] : undefined;\n  if (!resolvedTarget && _target) {\n    throw new Error(\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string\n    `Initial state node \"${_target}\" not found on parent state node #${stateNode.id}`);\n  }\n  const transition = {\n    source: stateNode,\n    actions: !_target || typeof _target === 'string' ? [] : toArray(_target.actions),\n    eventType: null,\n    reenter: false,\n    target: resolvedTarget ? [resolvedTarget] : [],\n    toJSON: () => ({\n      ...transition,\n      source: `#${stateNode.id}`,\n      target: resolvedTarget ? [`#${resolvedTarget.id}`] : []\n    })\n  };\n  return transition;\n}\nfunction resolveTarget(stateNode, targets) {\n  if (targets === undefined) {\n    // an undefined target signals that the state node should not transition from that state when receiving that event\n    return undefined;\n  }\n  return targets.map(target => {\n    if (typeof target !== 'string') {\n      return target;\n    }\n    if (isStateId(target)) {\n      return stateNode.machine.getStateNodeById(target);\n    }\n    const isInternalTarget = target[0] === STATE_DELIMITER;\n    // If internal target is defined on machine,\n    // do not include machine key on target\n    if (isInternalTarget && !stateNode.parent) {\n      return getStateNodeByPath(stateNode, target.slice(1));\n    }\n    const resolvedTarget = isInternalTarget ? stateNode.key + target : target;\n    if (stateNode.parent) {\n      try {\n        const targetStateNode = getStateNodeByPath(stateNode.parent, resolvedTarget);\n        return targetStateNode;\n      } catch (err) {\n        throw new Error(`Invalid transition definition for state node '${stateNode.id}':\\n${err.message}`);\n      }\n    } else {\n      throw new Error(`Invalid target: \"${target}\" is not a valid target from the root node. Did you mean \".${target}\"?`);\n    }\n  });\n}\nfunction resolveHistoryDefaultTransition(stateNode) {\n  const normalizedTarget = normalizeTarget(stateNode.config.target);\n  if (!normalizedTarget) {\n    return stateNode.parent.initial;\n  }\n  return {\n    target: normalizedTarget.map(t => typeof t === 'string' ? getStateNodeByPath(stateNode.parent, t) : t)\n  };\n}\nfunction isHistoryNode(stateNode) {\n  return stateNode.type === 'history';\n}\nfunction getInitialStateNodesWithTheirAncestors(stateNode) {\n  const states = getInitialStateNodes(stateNode);\n  for (const initialState of states) {\n    for (const ancestor of getProperAncestors(initialState, stateNode)) {\n      states.add(ancestor);\n    }\n  }\n  return states;\n}\nfunction getInitialStateNodes(stateNode) {\n  const set = new Set();\n  function iter(descStateNode) {\n    if (set.has(descStateNode)) {\n      return;\n    }\n    set.add(descStateNode);\n    if (descStateNode.type === 'compound') {\n      iter(descStateNode.initial.target[0]);\n    } else if (descStateNode.type === 'parallel') {\n      for (const child of getChildren(descStateNode)) {\n        iter(child);\n      }\n    }\n  }\n  iter(stateNode);\n  return set;\n}\n/** Returns the child state node from its relative `stateKey`, or throws. */\nfunction getStateNode(stateNode, stateKey) {\n  if (isStateId(stateKey)) {\n    return stateNode.machine.getStateNodeById(stateKey);\n  }\n  if (!stateNode.states) {\n    throw new Error(`Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`);\n  }\n  const result = stateNode.states[stateKey];\n  if (!result) {\n    throw new Error(`Child state '${stateKey}' does not exist on '${stateNode.id}'`);\n  }\n  return result;\n}\n\n/**\n * Returns the relative state node from the given `statePath`, or throws.\n *\n * @param statePath The string or string array relative path to the state node.\n */\nfunction getStateNodeByPath(stateNode, statePath) {\n  if (typeof statePath === 'string' && isStateId(statePath)) {\n    try {\n      return stateNode.machine.getStateNodeById(statePath);\n    } catch {\n      // try individual paths\n      // throw e;\n    }\n  }\n  const arrayStatePath = toStatePath(statePath).slice();\n  let currentStateNode = stateNode;\n  while (arrayStatePath.length) {\n    const key = arrayStatePath.shift();\n    if (!key.length) {\n      break;\n    }\n    currentStateNode = getStateNode(currentStateNode, key);\n  }\n  return currentStateNode;\n}\n\n/**\n * Returns the state nodes represented by the current state value.\n *\n * @param stateValue The state value or State instance\n */\nfunction getStateNodes(stateNode, stateValue) {\n  if (typeof stateValue === 'string') {\n    const childStateNode = stateNode.states[stateValue];\n    if (!childStateNode) {\n      throw new Error(`State '${stateValue}' does not exist on '${stateNode.id}'`);\n    }\n    return [stateNode, childStateNode];\n  }\n  const childStateKeys = Object.keys(stateValue);\n  const childStateNodes = childStateKeys.map(subStateKey => getStateNode(stateNode, subStateKey)).filter(Boolean);\n  return [stateNode.machine.root, stateNode].concat(childStateNodes, childStateKeys.reduce((allSubStateNodes, subStateKey) => {\n    const subStateNode = getStateNode(stateNode, subStateKey);\n    if (!subStateNode) {\n      return allSubStateNodes;\n    }\n    const subStateNodes = getStateNodes(subStateNode, stateValue[subStateKey]);\n    return allSubStateNodes.concat(subStateNodes);\n  }, []));\n}\nfunction transitionAtomicNode(stateNode, stateValue, snapshot, event) {\n  const childStateNode = getStateNode(stateNode, stateValue);\n  const next = childStateNode.next(snapshot, event);\n  if (!next || !next.length) {\n    return stateNode.next(snapshot, event);\n  }\n  return next;\n}\nfunction transitionCompoundNode(stateNode, stateValue, snapshot, event) {\n  const subStateKeys = Object.keys(stateValue);\n  const childStateNode = getStateNode(stateNode, subStateKeys[0]);\n  const next = transitionNode(childStateNode, stateValue[subStateKeys[0]], snapshot, event);\n  if (!next || !next.length) {\n    return stateNode.next(snapshot, event);\n  }\n  return next;\n}\nfunction transitionParallelNode(stateNode, stateValue, snapshot, event) {\n  const allInnerTransitions = [];\n  for (const subStateKey of Object.keys(stateValue)) {\n    const subStateValue = stateValue[subStateKey];\n    if (!subStateValue) {\n      continue;\n    }\n    const subStateNode = getStateNode(stateNode, subStateKey);\n    const innerTransitions = transitionNode(subStateNode, subStateValue, snapshot, event);\n    if (innerTransitions) {\n      allInnerTransitions.push(...innerTransitions);\n    }\n  }\n  if (!allInnerTransitions.length) {\n    return stateNode.next(snapshot, event);\n  }\n  return allInnerTransitions;\n}\nfunction transitionNode(stateNode, stateValue, snapshot, event) {\n  // leaf node\n  if (typeof stateValue === 'string') {\n    return transitionAtomicNode(stateNode, stateValue, snapshot, event);\n  }\n\n  // compound node\n  if (Object.keys(stateValue).length === 1) {\n    return transitionCompoundNode(stateNode, stateValue, snapshot, event);\n  }\n\n  // parallel node\n  return transitionParallelNode(stateNode, stateValue, snapshot, event);\n}\nfunction getHistoryNodes(stateNode) {\n  return Object.keys(stateNode.states).map(key => stateNode.states[key]).filter(sn => sn.type === 'history');\n}\nfunction isDescendant(childStateNode, parentStateNode) {\n  let marker = childStateNode;\n  while (marker.parent && marker.parent !== parentStateNode) {\n    marker = marker.parent;\n  }\n  return marker.parent === parentStateNode;\n}\nfunction hasIntersection(s1, s2) {\n  const set1 = new Set(s1);\n  const set2 = new Set(s2);\n  for (const item of set1) {\n    if (set2.has(item)) {\n      return true;\n    }\n  }\n  for (const item of set2) {\n    if (set1.has(item)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction removeConflictingTransitions(enabledTransitions, stateNodeSet, historyValue) {\n  const filteredTransitions = new Set();\n  for (const t1 of enabledTransitions) {\n    let t1Preempted = false;\n    const transitionsToRemove = new Set();\n    for (const t2 of filteredTransitions) {\n      if (hasIntersection(computeExitSet([t1], stateNodeSet, historyValue), computeExitSet([t2], stateNodeSet, historyValue))) {\n        if (isDescendant(t1.source, t2.source)) {\n          transitionsToRemove.add(t2);\n        } else {\n          t1Preempted = true;\n          break;\n        }\n      }\n    }\n    if (!t1Preempted) {\n      for (const t3 of transitionsToRemove) {\n        filteredTransitions.delete(t3);\n      }\n      filteredTransitions.add(t1);\n    }\n  }\n  return Array.from(filteredTransitions);\n}\nfunction findLeastCommonAncestor(stateNodes) {\n  const [head, ...tail] = stateNodes;\n  for (const ancestor of getProperAncestors(head, undefined)) {\n    if (tail.every(sn => isDescendant(sn, ancestor))) {\n      return ancestor;\n    }\n  }\n}\nfunction getEffectiveTargetStates(transition, historyValue) {\n  if (!transition.target) {\n    return [];\n  }\n  const targets = new Set();\n  for (const targetNode of transition.target) {\n    if (isHistoryNode(targetNode)) {\n      if (historyValue[targetNode.id]) {\n        for (const node of historyValue[targetNode.id]) {\n          targets.add(node);\n        }\n      } else {\n        for (const node of getEffectiveTargetStates(resolveHistoryDefaultTransition(targetNode), historyValue)) {\n          targets.add(node);\n        }\n      }\n    } else {\n      targets.add(targetNode);\n    }\n  }\n  return [...targets];\n}\nfunction getTransitionDomain(transition, historyValue) {\n  const targetStates = getEffectiveTargetStates(transition, historyValue);\n  if (!targetStates) {\n    return;\n  }\n  if (!transition.reenter && targetStates.every(target => target === transition.source || isDescendant(target, transition.source))) {\n    return transition.source;\n  }\n  const lca = findLeastCommonAncestor(targetStates.concat(transition.source));\n  if (lca) {\n    return lca;\n  }\n\n  // at this point we know that it's a root transition since LCA couldn't be found\n  if (transition.reenter) {\n    return;\n  }\n  return transition.source.machine.root;\n}\nfunction computeExitSet(transitions, stateNodeSet, historyValue) {\n  const statesToExit = new Set();\n  for (const t of transitions) {\n    if (t.target?.length) {\n      const domain = getTransitionDomain(t, historyValue);\n      if (t.reenter && t.source === domain) {\n        statesToExit.add(domain);\n      }\n      for (const stateNode of stateNodeSet) {\n        if (isDescendant(stateNode, domain)) {\n          statesToExit.add(stateNode);\n        }\n      }\n    }\n  }\n  return [...statesToExit];\n}\nfunction areStateNodeCollectionsEqual(prevStateNodes, nextStateNodeSet) {\n  if (prevStateNodes.length !== nextStateNodeSet.size) {\n    return false;\n  }\n  for (const node of prevStateNodes) {\n    if (!nextStateNodeSet.has(node)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/** https://www.w3.org/TR/scxml/#microstepProcedure */\nfunction microstep(transitions, currentSnapshot, actorScope, event, isInitial, internalQueue) {\n  if (!transitions.length) {\n    return currentSnapshot;\n  }\n  const mutStateNodeSet = new Set(currentSnapshot._nodes);\n  let historyValue = currentSnapshot.historyValue;\n  const filteredTransitions = removeConflictingTransitions(transitions, mutStateNodeSet, historyValue);\n  let nextState = currentSnapshot;\n\n  // Exit states\n  if (!isInitial) {\n    [nextState, historyValue] = exitStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, historyValue, internalQueue, actorScope.actionExecutor);\n  }\n\n  // Execute transition content\n  nextState = resolveActionsAndContext(nextState, event, actorScope, filteredTransitions.flatMap(t => t.actions), internalQueue, undefined);\n\n  // Enter states\n  nextState = enterStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial);\n  const nextStateNodes = [...mutStateNodeSet];\n  if (nextState.status === 'done') {\n    nextState = resolveActionsAndContext(nextState, event, actorScope, nextStateNodes.sort((a, b) => b.order - a.order).flatMap(state => state.exit), internalQueue, undefined);\n  }\n\n  // eslint-disable-next-line no-useless-catch\n  try {\n    if (historyValue === currentSnapshot.historyValue && areStateNodeCollectionsEqual(currentSnapshot._nodes, mutStateNodeSet)) {\n      return nextState;\n    }\n    return cloneMachineSnapshot(nextState, {\n      _nodes: nextStateNodes,\n      historyValue\n    });\n  } catch (e) {\n    // TODO: Refactor this once proper error handling is implemented.\n    // See https://github.com/statelyai/rfcs/pull/4\n    throw e;\n  }\n}\nfunction getMachineOutput(snapshot, event, actorScope, rootNode, rootCompletionNode) {\n  if (rootNode.output === undefined) {\n    return;\n  }\n  const doneStateEvent = createDoneStateEvent(rootCompletionNode.id, rootCompletionNode.output !== undefined && rootCompletionNode.parent ? resolveOutput(rootCompletionNode.output, snapshot.context, event, actorScope.self) : undefined);\n  return resolveOutput(rootNode.output, snapshot.context, doneStateEvent, actorScope.self);\n}\nfunction enterStates(currentSnapshot, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial) {\n  let nextSnapshot = currentSnapshot;\n  const statesToEnter = new Set();\n  // those are states that were directly targeted or indirectly targeted by the explicit target\n  // in other words, those are states for which initial actions should be executed\n  // when we target `#deep_child` initial actions of its ancestors shouldn't be executed\n  const statesForDefaultEntry = new Set();\n  computeEntrySet(filteredTransitions, historyValue, statesForDefaultEntry, statesToEnter);\n\n  // In the initial state, the root state node is \"entered\".\n  if (isInitial) {\n    statesForDefaultEntry.add(currentSnapshot.machine.root);\n  }\n  const completedNodes = new Set();\n  for (const stateNodeToEnter of [...statesToEnter].sort((a, b) => a.order - b.order)) {\n    mutStateNodeSet.add(stateNodeToEnter);\n    const actions = [];\n\n    // Add entry actions\n    actions.push(...stateNodeToEnter.entry);\n    for (const invokeDef of stateNodeToEnter.invoke) {\n      actions.push(spawnChild(invokeDef.src, {\n        ...invokeDef,\n        syncSnapshot: !!invokeDef.onSnapshot\n      }));\n    }\n    if (statesForDefaultEntry.has(stateNodeToEnter)) {\n      const initialActions = stateNodeToEnter.initial.actions;\n      actions.push(...initialActions);\n    }\n    nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, actions, internalQueue, stateNodeToEnter.invoke.map(invokeDef => invokeDef.id));\n    if (stateNodeToEnter.type === 'final') {\n      const parent = stateNodeToEnter.parent;\n      let ancestorMarker = parent?.type === 'parallel' ? parent : parent?.parent;\n      let rootCompletionNode = ancestorMarker || stateNodeToEnter;\n      if (parent?.type === 'compound') {\n        internalQueue.push(createDoneStateEvent(parent.id, stateNodeToEnter.output !== undefined ? resolveOutput(stateNodeToEnter.output, nextSnapshot.context, event, actorScope.self) : undefined));\n      }\n      while (ancestorMarker?.type === 'parallel' && !completedNodes.has(ancestorMarker) && isInFinalState(mutStateNodeSet, ancestorMarker)) {\n        completedNodes.add(ancestorMarker);\n        internalQueue.push(createDoneStateEvent(ancestorMarker.id));\n        rootCompletionNode = ancestorMarker;\n        ancestorMarker = ancestorMarker.parent;\n      }\n      if (ancestorMarker) {\n        continue;\n      }\n      nextSnapshot = cloneMachineSnapshot(nextSnapshot, {\n        status: 'done',\n        output: getMachineOutput(nextSnapshot, event, actorScope, nextSnapshot.machine.root, rootCompletionNode)\n      });\n    }\n  }\n  return nextSnapshot;\n}\nfunction computeEntrySet(transitions, historyValue, statesForDefaultEntry, statesToEnter) {\n  for (const t of transitions) {\n    const domain = getTransitionDomain(t, historyValue);\n    for (const s of t.target || []) {\n      if (!isHistoryNode(s) && (\n      // if the target is different than the source then it will *definitely* be entered\n      t.source !== s ||\n      // we know that the domain can't lie within the source\n      // if it's different than the source then it's outside of it and it means that the target has to be entered as well\n      t.source !== domain ||\n      // reentering transitions always enter the target, even if it's the source itself\n      t.reenter)) {\n        statesToEnter.add(s);\n        statesForDefaultEntry.add(s);\n      }\n      addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n    }\n    const targetStates = getEffectiveTargetStates(t, historyValue);\n    for (const s of targetStates) {\n      const ancestors = getProperAncestors(s, domain);\n      if (domain?.type === 'parallel') {\n        ancestors.push(domain);\n      }\n      addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, !t.source.parent && t.reenter ? undefined : domain);\n    }\n  }\n}\nfunction addDescendantStatesToEnter(stateNode, historyValue, statesForDefaultEntry, statesToEnter) {\n  if (isHistoryNode(stateNode)) {\n    if (historyValue[stateNode.id]) {\n      const historyStateNodes = historyValue[stateNode.id];\n      for (const s of historyStateNodes) {\n        statesToEnter.add(s);\n        addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n      }\n      for (const s of historyStateNodes) {\n        addProperAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);\n      }\n    } else {\n      const historyDefaultTransition = resolveHistoryDefaultTransition(stateNode);\n      for (const s of historyDefaultTransition.target) {\n        statesToEnter.add(s);\n        if (historyDefaultTransition === stateNode.parent?.initial) {\n          statesForDefaultEntry.add(stateNode.parent);\n        }\n        addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n      }\n      for (const s of historyDefaultTransition.target) {\n        addProperAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);\n      }\n    }\n  } else {\n    if (stateNode.type === 'compound') {\n      const [initialState] = stateNode.initial.target;\n      if (!isHistoryNode(initialState)) {\n        statesToEnter.add(initialState);\n        statesForDefaultEntry.add(initialState);\n      }\n      addDescendantStatesToEnter(initialState, historyValue, statesForDefaultEntry, statesToEnter);\n      addProperAncestorStatesToEnter(initialState, stateNode, statesToEnter, historyValue, statesForDefaultEntry);\n    } else {\n      if (stateNode.type === 'parallel') {\n        for (const child of getChildren(stateNode).filter(sn => !isHistoryNode(sn))) {\n          if (![...statesToEnter].some(s => isDescendant(s, child))) {\n            if (!isHistoryNode(child)) {\n              statesToEnter.add(child);\n              statesForDefaultEntry.add(child);\n            }\n            addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);\n          }\n        }\n      }\n    }\n  }\n}\nfunction addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, reentrancyDomain) {\n  for (const anc of ancestors) {\n    if (!reentrancyDomain || isDescendant(anc, reentrancyDomain)) {\n      statesToEnter.add(anc);\n    }\n    if (anc.type === 'parallel') {\n      for (const child of getChildren(anc).filter(sn => !isHistoryNode(sn))) {\n        if (![...statesToEnter].some(s => isDescendant(s, child))) {\n          statesToEnter.add(child);\n          addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);\n        }\n      }\n    }\n  }\n}\nfunction addProperAncestorStatesToEnter(stateNode, toStateNode, statesToEnter, historyValue, statesForDefaultEntry) {\n  addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, getProperAncestors(stateNode, toStateNode));\n}\nfunction exitStates(currentSnapshot, event, actorScope, transitions, mutStateNodeSet, historyValue, internalQueue, _actionExecutor) {\n  let nextSnapshot = currentSnapshot;\n  const statesToExit = computeExitSet(transitions, mutStateNodeSet, historyValue);\n  statesToExit.sort((a, b) => b.order - a.order);\n  let changedHistory;\n\n  // From SCXML algorithm: https://www.w3.org/TR/scxml/#exitStates\n  for (const exitStateNode of statesToExit) {\n    for (const historyNode of getHistoryNodes(exitStateNode)) {\n      let predicate;\n      if (historyNode.history === 'deep') {\n        predicate = sn => isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);\n      } else {\n        predicate = sn => {\n          return sn.parent === exitStateNode;\n        };\n      }\n      changedHistory ??= {\n        ...historyValue\n      };\n      changedHistory[historyNode.id] = Array.from(mutStateNodeSet).filter(predicate);\n    }\n  }\n  for (const s of statesToExit) {\n    nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, [...s.exit, ...s.invoke.map(def => stopChild(def.id))], internalQueue, undefined);\n    mutStateNodeSet.delete(s);\n  }\n  return [nextSnapshot, changedHistory || historyValue];\n}\nfunction getAction(machine, actionType) {\n  return machine.implementations.actions[actionType];\n}\nfunction resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, extra, retries) {\n  const {\n    machine\n  } = currentSnapshot;\n  let intermediateSnapshot = currentSnapshot;\n  for (const action of actions) {\n    const isInline = typeof action === 'function';\n    const resolvedAction = isInline ? action :\n    // the existing type of `.actions` assumes non-nullable `TExpressionAction`\n    // it's fine to cast this here to get a common type and lack of errors in the rest of the code\n    // our logic below makes sure that we call those 2 \"variants\" correctly\n\n    getAction(machine, typeof action === 'string' ? action : action.type);\n    const actionArgs = {\n      context: intermediateSnapshot.context,\n      event,\n      self: actorScope.self,\n      system: actorScope.system\n    };\n    const actionParams = isInline || typeof action === 'string' ? undefined : 'params' in action ? typeof action.params === 'function' ? action.params({\n      context: intermediateSnapshot.context,\n      event\n    }) : action.params : undefined;\n    if (!resolvedAction || !('resolve' in resolvedAction)) {\n      actorScope.actionExecutor({\n        type: typeof action === 'string' ? action : typeof action === 'object' ? action.type : action.name || '(anonymous)',\n        info: actionArgs,\n        params: actionParams,\n        exec: resolvedAction\n      });\n      continue;\n    }\n    const builtinAction = resolvedAction;\n    const [nextState, params, actions] = builtinAction.resolve(actorScope, intermediateSnapshot, actionArgs, actionParams, resolvedAction,\n    // this holds all params\n    extra);\n    intermediateSnapshot = nextState;\n    if ('retryResolve' in builtinAction) {\n      retries?.push([builtinAction, params]);\n    }\n    if ('execute' in builtinAction) {\n      actorScope.actionExecutor({\n        type: builtinAction.type,\n        info: actionArgs,\n        params,\n        exec: builtinAction.execute.bind(null, actorScope, params)\n      });\n    }\n    if (actions) {\n      intermediateSnapshot = resolveAndExecuteActionsWithContext(intermediateSnapshot, event, actorScope, actions, extra, retries);\n    }\n  }\n  return intermediateSnapshot;\n}\nfunction resolveActionsAndContext(currentSnapshot, event, actorScope, actions, internalQueue, deferredActorIds) {\n  const retries = deferredActorIds ? [] : undefined;\n  const nextState = resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, {\n    internalQueue,\n    deferredActorIds\n  }, retries);\n  retries?.forEach(([builtinAction, params]) => {\n    builtinAction.retryResolve(actorScope, nextState, params);\n  });\n  return nextState;\n}\nfunction macrostep(snapshot, event, actorScope, internalQueue) {\n  if (event.type === WILDCARD) {\n    throw new Error(`An event cannot have the wildcard type ('${WILDCARD}')`);\n  }\n  let nextSnapshot = snapshot;\n  const microstates = [];\n  function addMicrostate(microstate, event, transitions) {\n    actorScope.system._sendInspectionEvent({\n      type: '@xstate.microstep',\n      actorRef: actorScope.self,\n      event,\n      snapshot: microstate,\n      _transitions: transitions\n    });\n    microstates.push(microstate);\n  }\n\n  // Handle stop event\n  if (event.type === XSTATE_STOP) {\n    nextSnapshot = cloneMachineSnapshot(stopChildren(nextSnapshot, event, actorScope), {\n      status: 'stopped'\n    });\n    addMicrostate(nextSnapshot, event, []);\n    return {\n      snapshot: nextSnapshot,\n      microstates\n    };\n  }\n  let nextEvent = event;\n\n  // Assume the state is at rest (no raised events)\n  // Determine the next state based on the next microstep\n  if (nextEvent.type !== XSTATE_INIT) {\n    const currentEvent = nextEvent;\n    const isErr = isErrorActorEvent(currentEvent);\n    const transitions = selectTransitions(currentEvent, nextSnapshot);\n    if (isErr && !transitions.length) {\n      // TODO: we should likely only allow transitions selected by very explicit descriptors\n      // `*` shouldn't be matched, likely `xstate.error.*` shouldn't be either\n      // similarly `xstate.error.actor.*` and `xstate.error.actor.todo.*` have to be considered too\n      nextSnapshot = cloneMachineSnapshot(snapshot, {\n        status: 'error',\n        error: currentEvent.error\n      });\n      addMicrostate(nextSnapshot, currentEvent, []);\n      return {\n        snapshot: nextSnapshot,\n        microstates\n      };\n    }\n    nextSnapshot = microstep(transitions, snapshot, actorScope, nextEvent, false,\n    // isInitial\n    internalQueue);\n    addMicrostate(nextSnapshot, currentEvent, transitions);\n  }\n  let shouldSelectEventlessTransitions = true;\n  while (nextSnapshot.status === 'active') {\n    let enabledTransitions = shouldSelectEventlessTransitions ? selectEventlessTransitions(nextSnapshot, nextEvent) : [];\n\n    // eventless transitions should always be selected after selecting *regular* transitions\n    // by assigning `undefined` to `previousState` we ensure that `shouldSelectEventlessTransitions` gets always computed to true in such a case\n    const previousState = enabledTransitions.length ? nextSnapshot : undefined;\n    if (!enabledTransitions.length) {\n      if (!internalQueue.length) {\n        break;\n      }\n      nextEvent = internalQueue.shift();\n      enabledTransitions = selectTransitions(nextEvent, nextSnapshot);\n    }\n    nextSnapshot = microstep(enabledTransitions, nextSnapshot, actorScope, nextEvent, false, internalQueue);\n    shouldSelectEventlessTransitions = nextSnapshot !== previousState;\n    addMicrostate(nextSnapshot, nextEvent, enabledTransitions);\n  }\n  if (nextSnapshot.status !== 'active') {\n    stopChildren(nextSnapshot, nextEvent, actorScope);\n  }\n  return {\n    snapshot: nextSnapshot,\n    microstates\n  };\n}\nfunction stopChildren(nextState, event, actorScope) {\n  return resolveActionsAndContext(nextState, event, actorScope, Object.values(nextState.children).map(child => stopChild(child)), [], undefined);\n}\nfunction selectTransitions(event, nextState) {\n  return nextState.machine.getTransitionData(nextState, event);\n}\nfunction selectEventlessTransitions(nextState, event) {\n  const enabledTransitionSet = new Set();\n  const atomicStates = nextState._nodes.filter(isAtomicStateNode);\n  for (const stateNode of atomicStates) {\n    loop: for (const s of [stateNode].concat(getProperAncestors(stateNode, undefined))) {\n      if (!s.always) {\n        continue;\n      }\n      for (const transition of s.always) {\n        if (transition.guard === undefined || evaluateGuard(transition.guard, nextState.context, event, nextState)) {\n          enabledTransitionSet.add(transition);\n          break loop;\n        }\n      }\n    }\n  }\n  return removeConflictingTransitions(Array.from(enabledTransitionSet), new Set(nextState._nodes), nextState.historyValue);\n}\n\n/**\n * Resolves a partial state value with its full representation in the state\n * node's machine.\n *\n * @param stateValue The partial state value to resolve.\n */\nfunction resolveStateValue(rootNode, stateValue) {\n  const allStateNodes = getAllStateNodes(getStateNodes(rootNode, stateValue));\n  return getStateValue(rootNode, [...allStateNodes]);\n}\n\nfunction isMachineSnapshot(value) {\n  return !!value && typeof value === 'object' && 'machine' in value && 'value' in value;\n}\nconst machineSnapshotMatches = function matches(testValue) {\n  return matchesState(testValue, this.value);\n};\nconst machineSnapshotHasTag = function hasTag(tag) {\n  return this.tags.has(tag);\n};\nconst machineSnapshotCan = function can(event) {\n  if (!this.machine) {\n    console.warn(`state.can(...) used outside of a machine-created State object; this will always return false.`);\n  }\n  const transitionData = this.machine.getTransitionData(this, event);\n  return !!transitionData?.length &&\n  // Check that at least one transition is not forbidden\n  transitionData.some(t => t.target !== undefined || t.actions.length);\n};\nconst machineSnapshotToJSON = function toJSON() {\n  const {\n    _nodes: nodes,\n    tags,\n    machine,\n    getMeta,\n    toJSON,\n    can,\n    hasTag,\n    matches,\n    ...jsonValues\n  } = this;\n  return {\n    ...jsonValues,\n    tags: Array.from(tags)\n  };\n};\nconst machineSnapshotGetMeta = function getMeta() {\n  return this._nodes.reduce((acc, stateNode) => {\n    if (stateNode.meta !== undefined) {\n      acc[stateNode.id] = stateNode.meta;\n    }\n    return acc;\n  }, {});\n};\nfunction createMachineSnapshot(config, machine) {\n  return {\n    status: config.status,\n    output: config.output,\n    error: config.error,\n    machine,\n    context: config.context,\n    _nodes: config._nodes,\n    value: getStateValue(machine.root, config._nodes),\n    tags: new Set(config._nodes.flatMap(sn => sn.tags)),\n    children: config.children,\n    historyValue: config.historyValue || {},\n    matches: machineSnapshotMatches,\n    hasTag: machineSnapshotHasTag,\n    can: machineSnapshotCan,\n    getMeta: machineSnapshotGetMeta,\n    toJSON: machineSnapshotToJSON\n  };\n}\nfunction cloneMachineSnapshot(snapshot, config = {}) {\n  return createMachineSnapshot({\n    ...snapshot,\n    ...config\n  }, snapshot.machine);\n}\nfunction serializeHistoryValue(historyValue) {\n  if (typeof historyValue !== 'object' || historyValue === null) {\n    return {};\n  }\n  const result = {};\n  for (const key in historyValue) {\n    const value = historyValue[key];\n    if (Array.isArray(value)) {\n      result[key] = value.map(item => ({\n        id: item.id\n      }));\n    }\n  }\n  return result;\n}\nfunction getPersistedSnapshot(snapshot, options) {\n  const {\n    _nodes: nodes,\n    tags,\n    machine,\n    children,\n    context,\n    can,\n    hasTag,\n    matches,\n    getMeta,\n    toJSON,\n    ...jsonValues\n  } = snapshot;\n  const childrenJson = {};\n  for (const id in children) {\n    const child = children[id];\n    if (typeof child.src !== 'string' && (!options || !('__unsafeAllowInlineActors' in options))) {\n      throw new Error('An inline child actor cannot be persisted.');\n    }\n    childrenJson[id] = {\n      snapshot: child.getPersistedSnapshot(options),\n      src: child.src,\n      systemId: child.systemId,\n      syncSnapshot: child._syncSnapshot\n    };\n  }\n  const persisted = {\n    ...jsonValues,\n    context: persistContext(context),\n    children: childrenJson,\n    historyValue: serializeHistoryValue(jsonValues.historyValue)\n  };\n  return persisted;\n}\nfunction persistContext(contextPart) {\n  let copy;\n  for (const key in contextPart) {\n    const value = contextPart[key];\n    if (value && typeof value === 'object') {\n      if ('sessionId' in value && 'send' in value && 'ref' in value) {\n        copy ??= Array.isArray(contextPart) ? contextPart.slice() : {\n          ...contextPart\n        };\n        copy[key] = {\n          xstate$$type: $$ACTOR_TYPE,\n          id: value.id\n        };\n      } else {\n        const result = persistContext(value);\n        if (result !== value) {\n          copy ??= Array.isArray(contextPart) ? contextPart.slice() : {\n            ...contextPart\n          };\n          copy[key] = result;\n        }\n      }\n    }\n  }\n  return copy ?? contextPart;\n}\n\nfunction resolveRaise(_, snapshot, args, actionParams, {\n  event: eventOrExpr,\n  id,\n  delay\n}, {\n  internalQueue\n}) {\n  const delaysMap = snapshot.machine.implementations.delays;\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    `Only event objects may be used with raise; use raise({ type: \"${eventOrExpr}\" }) instead`);\n  }\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\n  let resolvedDelay;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay = typeof configDelay === 'function' ? configDelay(args, actionParams) : configDelay;\n  } else {\n    resolvedDelay = typeof delay === 'function' ? delay(args, actionParams) : delay;\n  }\n  if (typeof resolvedDelay !== 'number') {\n    internalQueue.push(resolvedEvent);\n  }\n  return [snapshot, {\n    event: resolvedEvent,\n    id,\n    delay: resolvedDelay\n  }, undefined];\n}\nfunction executeRaise(actorScope, params) {\n  const {\n    event,\n    delay,\n    id\n  } = params;\n  if (typeof delay === 'number') {\n    actorScope.defer(() => {\n      const self = actorScope.self;\n      actorScope.system.scheduler.schedule(self, self, event, delay, id);\n    });\n    return;\n  }\n}\n/**\n * Raises an event. This places the event in the internal event queue, so that\n * the event is immediately consumed by the machine in the current step.\n *\n * @param eventType The event to raise.\n */\nfunction raise(eventOrExpr, options) {\n  if (executingCustomAction) {\n    console.warn('Custom actions should not call `raise()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.');\n  }\n  function raise(_args, _params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  raise.type = 'xstate.raise';\n  raise.event = eventOrExpr;\n  raise.id = options?.id;\n  raise.delay = options?.delay;\n  raise.resolve = resolveRaise;\n  raise.execute = executeRaise;\n  return raise;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvcmFpc2UtMjM1ZmEwYzcuZGV2ZWxvcG1lbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0RTs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUyxHQUFHLEdBQUc7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsR0FBRztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxHQUFHO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzT0FBc08sd0dBQXdHLElBQUksSUFBSSx1Q0FBdUMsWUFBWTtBQUN6WTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU0sR0FBRyxZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1KQUFtSixXQUFXO0FBQzlKO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3Q0FBd0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixXQUFXO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksbUJBQW1CLEdBQUcsR0FBRztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscURBQXFELFVBQVUsS0FBSyxTQUFTO0FBQzdFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw4Q0FBOEMsa0JBQWtCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXLCtCQUErQixTQUFTLEdBQUcsZUFBZSx1RkFBdUYsWUFBWTtBQUN2TTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFlBQVksU0FBUyxNQUFNLEdBQUc7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esa0ZBQWtGLG9GQUFlO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sd0JBQXdCO0FBQzlCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsa0NBQWtDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvQkFBb0I7QUFDbkQsY0FBYyxtQkFBbUIsR0FBRywwQkFBMEI7QUFDOUQsTUFBTSxxQkFBcUIsR0FBRyxrQkFBa0IsT0FBTyxxQkFBcUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLElBQUksMEJBQTBCLGNBQWM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQ0FBK0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQiwyQ0FBMkMsS0FBSztBQUNoRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyxLQUFLO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGFBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFFBQVEsb0NBQW9DLGFBQWE7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0Isb0NBQW9DLGtCQUFrQjtBQUN0RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix5RUFBeUUsYUFBYSxNQUFNLFlBQVk7QUFDeEc7QUFDQSxNQUFNO0FBQ04sMENBQTBDLE9BQU8sNkRBQTZELE9BQU87QUFDckg7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxTQUFTLFVBQVUsYUFBYSxHQUFHO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTLHVCQUF1QixhQUFhO0FBQ2pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxXQUFXLHVCQUF1QixhQUFhO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFNBQVM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVksU0FBUyxZQUFZLEdBQUc7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK2tDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3Jpc3AtY2xlYW5pbmcvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvcmFpc2UtMjM1ZmEwYzcuZGV2ZWxvcG1lbnQuZXNtLmpzPzQ3YTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGV2VG9vbHNBZGFwdGVyIH0gZnJvbSAnLi4vZGV2L2Rpc3QveHN0YXRlLWRldi5kZXZlbG9wbWVudC5lc20uanMnO1xuXG5jbGFzcyBNYWlsYm94IHtcbiAgY29uc3RydWN0b3IoX3Byb2Nlc3MpIHtcbiAgICB0aGlzLl9wcm9jZXNzID0gX3Byb2Nlc3M7XG4gICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5fY3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdCA9IG51bGw7XG4gIH1cbiAgc3RhcnQoKSB7XG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgLy8gd2UgY2FuJ3Qgc2V0IF9jdXJyZW50IHRvIG51bGwgYmVjYXVzZSB3ZSBtaWdodCBiZSBjdXJyZW50bHkgcHJvY2Vzc2luZ1xuICAgIC8vIGFuZCBlbnF1ZXVlIGZvbGxvd2luZyBjbGVhciBzaG91bGRuJ3Qgc3RhcnQgcHJvY2Vzc2luZyB0aGUgZW5xdWV1ZWQgaXRlbSBpbW1lZGlhdGVseVxuICAgIGlmICh0aGlzLl9jdXJyZW50KSB7XG4gICAgICB0aGlzLl9jdXJyZW50Lm5leHQgPSBudWxsO1xuICAgICAgdGhpcy5fbGFzdCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgfVxuICB9XG4gIGVucXVldWUoZXZlbnQpIHtcbiAgICBjb25zdCBlbnF1ZXVlZCA9IHtcbiAgICAgIHZhbHVlOiBldmVudCxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmICh0aGlzLl9jdXJyZW50KSB7XG4gICAgICB0aGlzLl9sYXN0Lm5leHQgPSBlbnF1ZXVlZDtcbiAgICAgIHRoaXMuX2xhc3QgPSBlbnF1ZXVlZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudCA9IGVucXVldWVkO1xuICAgIHRoaXMuX2xhc3QgPSBlbnF1ZXVlZDtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICB9XG4gIGZsdXNoKCkge1xuICAgIHdoaWxlICh0aGlzLl9jdXJyZW50KSB7XG4gICAgICAvLyBhdG0gdGhlIGdpdmVuIF9wcm9jZXNzIGlzIHJlc3BvbnNpYmxlIGZvciBpbXBsZW1lbnRpbmcgcHJvcGVyIHRyeS9jYXRjaCBoYW5kbGluZ1xuICAgICAgLy8gd2UgYXNzdW1lIGhlcmUgdGhhdCB0aGlzIHdvbid0IHRocm93IGluIGEgd2F5IHRoYXQgY2FuIGFmZmVjdCB0aGlzIG1haWxib3hcbiAgICAgIGNvbnN0IGNvbnN1bWVkID0gdGhpcy5fY3VycmVudDtcbiAgICAgIHRoaXMuX3Byb2Nlc3MoY29uc3VtZWQudmFsdWUpO1xuICAgICAgdGhpcy5fY3VycmVudCA9IGNvbnN1bWVkLm5leHQ7XG4gICAgfVxuICAgIHRoaXMuX2xhc3QgPSBudWxsO1xuICB9XG59XG5cbmNvbnN0IFNUQVRFX0RFTElNSVRFUiA9ICcuJztcbmNvbnN0IFRBUkdFVExFU1NfS0VZID0gJyc7XG5jb25zdCBOVUxMX0VWRU5UID0gJyc7XG5jb25zdCBTVEFURV9JREVOVElGSUVSID0gJyMnO1xuY29uc3QgV0lMRENBUkQgPSAnKic7XG5jb25zdCBYU1RBVEVfSU5JVCA9ICd4c3RhdGUuaW5pdCc7XG5jb25zdCBYU1RBVEVfRVJST1IgPSAneHN0YXRlLmVycm9yJztcbmNvbnN0IFhTVEFURV9TVE9QID0gJ3hzdGF0ZS5zdG9wJztcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGV2ZW50IHRoYXQgcmVwcmVzZW50cyBhbiBpbXBsaWNpdCBldmVudCB0aGF0IGlzIHNlbnQgYWZ0ZXIgdGhlXG4gKiBzcGVjaWZpZWQgYGRlbGF5YC5cbiAqXG4gKiBAcGFyYW0gZGVsYXlSZWYgVGhlIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICogQHBhcmFtIGlkIFRoZSBzdGF0ZSBub2RlIElEIHdoZXJlIHRoaXMgZXZlbnQgaXMgaGFuZGxlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVBZnRlckV2ZW50KGRlbGF5UmVmLCBpZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGB4c3RhdGUuYWZ0ZXIuJHtkZWxheVJlZn0uJHtpZH1gXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBldmVudCB0aGF0IHJlcHJlc2VudHMgdGhhdCBhIGZpbmFsIHN0YXRlIG5vZGUgaGFzIGJlZW4gcmVhY2hlZCBpblxuICogdGhlIHBhcmVudCBzdGF0ZSBub2RlLlxuICpcbiAqIEBwYXJhbSBpZCBUaGUgZmluYWwgc3RhdGUgbm9kZSdzIHBhcmVudCBzdGF0ZSBub2RlIGBpZGBcbiAqIEBwYXJhbSBvdXRwdXQgVGhlIGRhdGEgdG8gcGFzcyBpbnRvIHRoZSBldmVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVEb25lU3RhdGVFdmVudChpZCwgb3V0cHV0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogYHhzdGF0ZS5kb25lLnN0YXRlLiR7aWR9YCxcbiAgICBvdXRwdXRcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGV2ZW50IHRoYXQgcmVwcmVzZW50cyB0aGF0IGFuIGludm9rZWQgc2VydmljZSBoYXMgdGVybWluYXRlZC5cbiAqXG4gKiBBbiBpbnZva2VkIHNlcnZpY2UgaXMgdGVybWluYXRlZCB3aGVuIGl0IGhhcyByZWFjaGVkIGEgdG9wLWxldmVsIGZpbmFsIHN0YXRlXG4gKiBub2RlLCBidXQgbm90IHdoZW4gaXQgaXMgY2FuY2VsZWQuXG4gKlxuICogQHBhcmFtIGludm9rZUlkIFRoZSBpbnZva2VkIHNlcnZpY2UgSURcbiAqIEBwYXJhbSBvdXRwdXQgVGhlIGRhdGEgdG8gcGFzcyBpbnRvIHRoZSBldmVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVEb25lQWN0b3JFdmVudChpbnZva2VJZCwgb3V0cHV0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogYHhzdGF0ZS5kb25lLmFjdG9yLiR7aW52b2tlSWR9YCxcbiAgICBvdXRwdXQsXG4gICAgYWN0b3JJZDogaW52b2tlSWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yQWN0b3JFdmVudChpZCwgZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBgeHN0YXRlLmVycm9yLmFjdG9yLiR7aWR9YCxcbiAgICBlcnJvcixcbiAgICBhY3RvcklkOiBpZFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW5pdEV2ZW50KGlucHV0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogWFNUQVRFX0lOSVQsXG4gICAgaW5wdXRcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIG1ha2VzIHN1cmUgdGhhdCB1bmhhbmRsZWQgZXJyb3JzIGFyZSB0aHJvd24gaW4gYSBzZXBhcmF0ZVxuICogbWFjcm90YXNrLiBJdCBhbGxvd3MgdGhvc2UgZXJyb3JzIHRvIGJlIGRldGVjdGVkIGJ5IGdsb2JhbCBlcnJvciBoYW5kbGVycyBhbmRcbiAqIHJlcG9ydGVkIHRvIGJ1ZyB0cmFja2luZyBzZXJ2aWNlcyB3aXRob3V0IGludGVycnVwdGluZyBvdXIgb3duIHN0YWNrIG9mXG4gKiBleGVjdXRpb24uXG4gKlxuICogQHBhcmFtIGVyciBFcnJvciB0byBiZSB0aHJvd25cbiAqL1xuZnVuY3Rpb24gcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKSB7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHRocm93IGVycjtcbiAgfSk7XG59XG5cbmNvbnN0IHN5bWJvbE9ic2VydmFibGUgPSAoKCkgPT4gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wub2JzZXJ2YWJsZSB8fCAnQEBvYnNlcnZhYmxlJykoKTtcblxuZnVuY3Rpb24gbWF0Y2hlc1N0YXRlKHBhcmVudFN0YXRlSWQsIGNoaWxkU3RhdGVJZCkge1xuICBjb25zdCBwYXJlbnRTdGF0ZVZhbHVlID0gdG9TdGF0ZVZhbHVlKHBhcmVudFN0YXRlSWQpO1xuICBjb25zdCBjaGlsZFN0YXRlVmFsdWUgPSB0b1N0YXRlVmFsdWUoY2hpbGRTdGF0ZUlkKTtcbiAgaWYgKHR5cGVvZiBjaGlsZFN0YXRlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJlbnRTdGF0ZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGNoaWxkU3RhdGVWYWx1ZSA9PT0gcGFyZW50U3RhdGVWYWx1ZTtcbiAgICB9XG5cbiAgICAvLyBQYXJlbnQgbW9yZSBzcGVjaWZpYyB0aGFuIGNoaWxkXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgcGFyZW50U3RhdGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyZW50U3RhdGVWYWx1ZSBpbiBjaGlsZFN0YXRlVmFsdWU7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcmVudFN0YXRlVmFsdWUpLmV2ZXJ5KGtleSA9PiB7XG4gICAgaWYgKCEoa2V5IGluIGNoaWxkU3RhdGVWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXNTdGF0ZShwYXJlbnRTdGF0ZVZhbHVlW2tleV0sIGNoaWxkU3RhdGVWYWx1ZVtrZXldKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB0b1N0YXRlUGF0aChzdGF0ZUlkKSB7XG4gIGlmIChpc0FycmF5KHN0YXRlSWQpKSB7XG4gICAgcmV0dXJuIHN0YXRlSWQ7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBzZWdtZW50ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGVJZC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBzdGF0ZUlkLmNoYXJDb2RlQXQoaSk7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAvLyBcXFxuICAgICAgY2FzZSA5MjpcbiAgICAgICAgLy8gY29uc3VtZSB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgc2VnbWVudCArPSBzdGF0ZUlkW2kgKyAxXTtcbiAgICAgICAgLy8gYW5kIHNraXAgb3ZlciBpdFxuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgLy8gLlxuICAgICAgY2FzZSA0NjpcbiAgICAgICAgcmVzdWx0LnB1c2goc2VnbWVudCk7XG4gICAgICAgIHNlZ21lbnQgPSAnJztcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHNlZ21lbnQgKz0gc3RhdGVJZFtpXTtcbiAgfVxuICByZXN1bHQucHVzaChzZWdtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvU3RhdGVWYWx1ZShzdGF0ZVZhbHVlKSB7XG4gIGlmIChpc01hY2hpbmVTbmFwc2hvdChzdGF0ZVZhbHVlKSkge1xuICAgIHJldHVybiBzdGF0ZVZhbHVlLnZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2Ygc3RhdGVWYWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RhdGVWYWx1ZTtcbiAgfVxuICBjb25zdCBzdGF0ZVBhdGggPSB0b1N0YXRlUGF0aChzdGF0ZVZhbHVlKTtcbiAgcmV0dXJuIHBhdGhUb1N0YXRlVmFsdWUoc3RhdGVQYXRoKTtcbn1cbmZ1bmN0aW9uIHBhdGhUb1N0YXRlVmFsdWUoc3RhdGVQYXRoKSB7XG4gIGlmIChzdGF0ZVBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHN0YXRlUGF0aFswXTtcbiAgfVxuICBjb25zdCB2YWx1ZSA9IHt9O1xuICBsZXQgbWFya2VyID0gdmFsdWU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGVQYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmIChpID09PSBzdGF0ZVBhdGgubGVuZ3RoIC0gMikge1xuICAgICAgbWFya2VyW3N0YXRlUGF0aFtpXV0gPSBzdGF0ZVBhdGhbaSArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcmV2aW91cyA9IG1hcmtlcjtcbiAgICAgIG1hcmtlciA9IHt9O1xuICAgICAgcHJldmlvdXNbc3RhdGVQYXRoW2ldXSA9IG1hcmtlcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gbWFwVmFsdWVzKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBjb2xsZWN0aW9uS2V5cyA9IE9iamVjdC5rZXlzKGNvbGxlY3Rpb24pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbGxlY3Rpb25LZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gY29sbGVjdGlvbktleXNbaV07XG4gICAgcmVzdWx0W2tleV0gPSBpdGVyYXRlZShjb2xsZWN0aW9uW2tleV0sIGtleSwgY29sbGVjdGlvbiwgaSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvQXJyYXlTdHJpY3QodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBbdmFsdWVdO1xufVxuZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gdG9BcnJheVN0cmljdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiByZXNvbHZlT3V0cHV0KG1hcHBlciwgY29udGV4dCwgZXZlbnQsIHNlbGYpIHtcbiAgaWYgKHR5cGVvZiBtYXBwZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWFwcGVyKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBldmVudCxcbiAgICAgIHNlbGZcbiAgICB9KTtcbiAgfVxuICBpZiAoISFtYXBwZXIgJiYgdHlwZW9mIG1hcHBlciA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnZhbHVlcyhtYXBwZXIpLnNvbWUodmFsID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgY29uc29sZS53YXJuKGBEeW5hbWljYWxseSBtYXBwaW5nIHZhbHVlcyB0byBpbmRpdmlkdWFsIHByb3BlcnRpZXMgaXMgZGVwcmVjYXRlZC4gVXNlIGEgc2luZ2xlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbWFwcGVkIG9iamVjdCBpbnN0ZWFkLlxcbkZvdW5kIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgd2hvc2UgdmFsdWVzIGFyZSBwb3NzaWJseSBtYXBwaW5nIGZ1bmN0aW9uczogJHtPYmplY3QuZW50cmllcyhtYXBwZXIpLmZpbHRlcigoWywgdmFsdWVdKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgXFxuIC0gJHtrZXl9OiAke3ZhbHVlLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxuXFxzKi9nLCAnJyl9YCkuam9pbignJyl9YCk7XG4gIH1cbiAgcmV0dXJuIG1hcHBlcjtcbn1cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNFcnJvckFjdG9yRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUuc3RhcnRzV2l0aCgneHN0YXRlLmVycm9yLmFjdG9yJyk7XG59XG5mdW5jdGlvbiB0b1RyYW5zaXRpb25Db25maWdBcnJheShjb25maWdMaWtlKSB7XG4gIHJldHVybiB0b0FycmF5U3RyaWN0KGNvbmZpZ0xpa2UpLm1hcCh0cmFuc2l0aW9uTGlrZSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0cmFuc2l0aW9uTGlrZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHRyYW5zaXRpb25MaWtlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiB0cmFuc2l0aW9uTGlrZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zaXRpb25MaWtlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gVEFSR0VUTEVTU19LRVkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB0b0FycmF5KHRhcmdldCk7XG59XG5mdW5jdGlvbiB0b09ic2VydmVyKG5leHRIYW5kbGVyLCBlcnJvckhhbmRsZXIsIGNvbXBsZXRpb25IYW5kbGVyKSB7XG4gIGNvbnN0IGlzT2JzZXJ2ZXIgPSB0eXBlb2YgbmV4dEhhbmRsZXIgPT09ICdvYmplY3QnO1xuICBjb25zdCBzZWxmID0gaXNPYnNlcnZlciA/IG5leHRIYW5kbGVyIDogdW5kZWZpbmVkO1xuICByZXR1cm4ge1xuICAgIG5leHQ6IChpc09ic2VydmVyID8gbmV4dEhhbmRsZXIubmV4dCA6IG5leHRIYW5kbGVyKT8uYmluZChzZWxmKSxcbiAgICBlcnJvcjogKGlzT2JzZXJ2ZXIgPyBuZXh0SGFuZGxlci5lcnJvciA6IGVycm9ySGFuZGxlcik/LmJpbmQoc2VsZiksXG4gICAgY29tcGxldGU6IChpc09ic2VydmVyID8gbmV4dEhhbmRsZXIuY29tcGxldGUgOiBjb21wbGV0aW9uSGFuZGxlcik/LmJpbmQoc2VsZilcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludm9rZUlkKHN0YXRlTm9kZUlkLCBpbmRleCkge1xuICByZXR1cm4gYCR7aW5kZXh9LiR7c3RhdGVOb2RlSWR9YDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVSZWZlcmVuY2VkQWN0b3IobWFjaGluZSwgc3JjKSB7XG4gIGNvbnN0IG1hdGNoID0gc3JjLm1hdGNoKC9eeHN0YXRlXFwuaW52b2tlXFwuKFxcZCspXFwuKC4qKS8pO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG1hY2hpbmUuaW1wbGVtZW50YXRpb25zLmFjdG9yc1tzcmNdO1xuICB9XG4gIGNvbnN0IFssIGluZGV4U3RyLCBub2RlSWRdID0gbWF0Y2g7XG4gIGNvbnN0IG5vZGUgPSBtYWNoaW5lLmdldFN0YXRlTm9kZUJ5SWQobm9kZUlkKTtcbiAgY29uc3QgaW52b2tlQ29uZmlnID0gbm9kZS5jb25maWcuaW52b2tlO1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkoaW52b2tlQ29uZmlnKSA/IGludm9rZUNvbmZpZ1tpbmRleFN0cl0gOiBpbnZva2VDb25maWcpLnNyYztcbn1cbmZ1bmN0aW9uIGdldEFsbE93bkV2ZW50RGVzY3JpcHRvcnMoc25hcHNob3QpIHtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KFsuLi5zbmFwc2hvdC5fbm9kZXMuZmxhdE1hcChzbiA9PiBzbi5vd25FdmVudHMpXSldO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCB0eXBlIG1hdGNoZXMgYW4gZXZlbnQgZGVzY3JpcHRvciwgc3VwcG9ydGluZyB3aWxkY2FyZHMuXG4gKiBFdmVudCBkZXNjcmlwdG9ycyBjYW4gYmU6XG4gKlxuICogLSBFeGFjdCBtYXRjaGVzOiBcImV2ZW50LnR5cGVcIlxuICogLSBXaWxkY2FyZDogXCIqXCJcbiAqIC0gUGFydGlhbCBtYXRjaGVzOiBcImV2ZW50LipcIlxuICpcbiAqIEBwYXJhbSBldmVudFR5cGUgLSBUaGUgYWN0dWFsIGV2ZW50IHR5cGUgc3RyaW5nXG4gKiBAcGFyYW0gZGVzY3JpcHRvciAtIFRoZSBldmVudCBkZXNjcmlwdG9yIHRvIG1hdGNoIGFnYWluc3RcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGV2ZW50IHR5cGUgbWF0Y2hlcyB0aGUgZGVzY3JpcHRvclxuICovXG5mdW5jdGlvbiBtYXRjaGVzRXZlbnREZXNjcmlwdG9yKGV2ZW50VHlwZSwgZGVzY3JpcHRvcikge1xuICBpZiAoZGVzY3JpcHRvciA9PT0gZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGRlc2NyaXB0b3IgPT09IFdJTERDQVJEKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFkZXNjcmlwdG9yLmVuZHNXaXRoKCcuKicpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgvLipcXCouKy8udGVzdChkZXNjcmlwdG9yKSkge1xuICAgIGNvbnNvbGUud2FybihgV2lsZGNhcmRzIGNhbiBvbmx5IGJlIHRoZSBsYXN0IHRva2VuIG9mIGFuIGV2ZW50IGRlc2NyaXB0b3IgKGUuZy4sIFwiZXZlbnQuKlwiKSBvciB0aGUgZW50aXJlIGV2ZW50IGRlc2NyaXB0b3IgKFwiKlwiKS4gQ2hlY2sgdGhlIFwiJHtkZXNjcmlwdG9yfVwiIGV2ZW50LmApO1xuICB9XG4gIGNvbnN0IHBhcnRpYWxFdmVudFRva2VucyA9IGRlc2NyaXB0b3Iuc3BsaXQoJy4nKTtcbiAgY29uc3QgZXZlbnRUb2tlbnMgPSBldmVudFR5cGUuc3BsaXQoJy4nKTtcbiAgZm9yIChsZXQgdG9rZW5JbmRleCA9IDA7IHRva2VuSW5kZXggPCBwYXJ0aWFsRXZlbnRUb2tlbnMubGVuZ3RoOyB0b2tlbkluZGV4KyspIHtcbiAgICBjb25zdCBwYXJ0aWFsRXZlbnRUb2tlbiA9IHBhcnRpYWxFdmVudFRva2Vuc1t0b2tlbkluZGV4XTtcbiAgICBjb25zdCBldmVudFRva2VuID0gZXZlbnRUb2tlbnNbdG9rZW5JbmRleF07XG4gICAgaWYgKHBhcnRpYWxFdmVudFRva2VuID09PSAnKicpIHtcbiAgICAgIGNvbnN0IGlzTGFzdFRva2VuID0gdG9rZW5JbmRleCA9PT0gcGFydGlhbEV2ZW50VG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICBpZiAoIWlzTGFzdFRva2VuKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgSW5maXggd2lsZGNhcmRzIGluIHRyYW5zaXRpb24gZXZlbnRzIGFyZSBub3QgYWxsb3dlZC4gQ2hlY2sgdGhlIFwiJHtkZXNjcmlwdG9yfVwiIHRyYW5zaXRpb24uYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNMYXN0VG9rZW47XG4gICAgfVxuICAgIGlmIChwYXJ0aWFsRXZlbnRUb2tlbiAhPT0gZXZlbnRUb2tlbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2NoZWR1bGVkRXZlbnRJZChhY3RvclJlZiwgaWQpIHtcbiAgcmV0dXJuIGAke2FjdG9yUmVmLnNlc3Npb25JZH0uJHtpZH1gO1xufVxubGV0IGlkQ291bnRlciA9IDA7XG5mdW5jdGlvbiBjcmVhdGVTeXN0ZW0ocm9vdEFjdG9yLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gbmV3IE1hcCgpO1xuICBjb25zdCBrZXllZEFjdG9ycyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgcmV2ZXJzZUtleWVkQWN0b3JzID0gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3QgaW5zcGVjdGlvbk9ic2VydmVycyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgdGltZXJNYXAgPSB7fTtcbiAgY29uc3Qge1xuICAgIGNsb2NrLFxuICAgIGxvZ2dlclxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc2NoZWR1bGVyID0ge1xuICAgIHNjaGVkdWxlOiAoc291cmNlLCB0YXJnZXQsIGV2ZW50LCBkZWxheSwgaWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSkgPT4ge1xuICAgICAgY29uc3Qgc2NoZWR1bGVkRXZlbnQgPSB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBldmVudCxcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGlkLFxuICAgICAgICBzdGFydGVkQXQ6IERhdGUubm93KClcbiAgICAgIH07XG4gICAgICBjb25zdCBzY2hlZHVsZWRFdmVudElkID0gY3JlYXRlU2NoZWR1bGVkRXZlbnRJZChzb3VyY2UsIGlkKTtcbiAgICAgIHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50c1tzY2hlZHVsZWRFdmVudElkXSA9IHNjaGVkdWxlZEV2ZW50O1xuICAgICAgY29uc3QgdGltZW91dCA9IGNsb2NrLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkZWxldGUgdGltZXJNYXBbc2NoZWR1bGVkRXZlbnRJZF07XG4gICAgICAgIGRlbGV0ZSBzeXN0ZW0uX3NuYXBzaG90Ll9zY2hlZHVsZWRFdmVudHNbc2NoZWR1bGVkRXZlbnRJZF07XG4gICAgICAgIHN5c3RlbS5fcmVsYXkoc291cmNlLCB0YXJnZXQsIGV2ZW50KTtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICAgIHRpbWVyTWFwW3NjaGVkdWxlZEV2ZW50SWRdID0gdGltZW91dDtcbiAgICB9LFxuICAgIGNhbmNlbDogKHNvdXJjZSwgaWQpID0+IHtcbiAgICAgIGNvbnN0IHNjaGVkdWxlZEV2ZW50SWQgPSBjcmVhdGVTY2hlZHVsZWRFdmVudElkKHNvdXJjZSwgaWQpO1xuICAgICAgY29uc3QgdGltZW91dCA9IHRpbWVyTWFwW3NjaGVkdWxlZEV2ZW50SWRdO1xuICAgICAgZGVsZXRlIHRpbWVyTWFwW3NjaGVkdWxlZEV2ZW50SWRdO1xuICAgICAgZGVsZXRlIHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50c1tzY2hlZHVsZWRFdmVudElkXTtcbiAgICAgIGlmICh0aW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2xvY2suY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2FuY2VsQWxsOiBhY3RvclJlZiA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHNjaGVkdWxlZEV2ZW50SWQgaW4gc3lzdGVtLl9zbmFwc2hvdC5fc2NoZWR1bGVkRXZlbnRzKSB7XG4gICAgICAgIGNvbnN0IHNjaGVkdWxlZEV2ZW50ID0gc3lzdGVtLl9zbmFwc2hvdC5fc2NoZWR1bGVkRXZlbnRzW3NjaGVkdWxlZEV2ZW50SWRdO1xuICAgICAgICBpZiAoc2NoZWR1bGVkRXZlbnQuc291cmNlID09PSBhY3RvclJlZikge1xuICAgICAgICAgIHNjaGVkdWxlci5jYW5jZWwoYWN0b3JSZWYsIHNjaGVkdWxlZEV2ZW50LmlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2VuZEluc3BlY3Rpb25FdmVudCA9IGV2ZW50ID0+IHtcbiAgICBpZiAoIWluc3BlY3Rpb25PYnNlcnZlcnMuc2l6ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZEluc3BlY3Rpb25FdmVudCA9IHtcbiAgICAgIC4uLmV2ZW50LFxuICAgICAgcm9vdElkOiByb290QWN0b3Iuc2Vzc2lvbklkXG4gICAgfTtcbiAgICBpbnNwZWN0aW9uT2JzZXJ2ZXJzLmZvckVhY2gob2JzZXJ2ZXIgPT4gb2JzZXJ2ZXIubmV4dD8uKHJlc29sdmVkSW5zcGVjdGlvbkV2ZW50KSk7XG4gIH07XG4gIGNvbnN0IHN5c3RlbSA9IHtcbiAgICBfc25hcHNob3Q6IHtcbiAgICAgIF9zY2hlZHVsZWRFdmVudHM6IChvcHRpb25zPy5zbmFwc2hvdCAmJiBvcHRpb25zLnNuYXBzaG90LnNjaGVkdWxlcikgPz8ge31cbiAgICB9LFxuICAgIF9ib29rSWQ6ICgpID0+IGB4OiR7aWRDb3VudGVyKyt9YCxcbiAgICBfcmVnaXN0ZXI6IChzZXNzaW9uSWQsIGFjdG9yUmVmKSA9PiB7XG4gICAgICBjaGlsZHJlbi5zZXQoc2Vzc2lvbklkLCBhY3RvclJlZik7XG4gICAgICByZXR1cm4gc2Vzc2lvbklkO1xuICAgIH0sXG4gICAgX3VucmVnaXN0ZXI6IGFjdG9yUmVmID0+IHtcbiAgICAgIGNoaWxkcmVuLmRlbGV0ZShhY3RvclJlZi5zZXNzaW9uSWQpO1xuICAgICAgY29uc3Qgc3lzdGVtSWQgPSByZXZlcnNlS2V5ZWRBY3RvcnMuZ2V0KGFjdG9yUmVmKTtcbiAgICAgIGlmIChzeXN0ZW1JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtleWVkQWN0b3JzLmRlbGV0ZShzeXN0ZW1JZCk7XG4gICAgICAgIHJldmVyc2VLZXllZEFjdG9ycy5kZWxldGUoYWN0b3JSZWYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0OiBzeXN0ZW1JZCA9PiB7XG4gICAgICByZXR1cm4ga2V5ZWRBY3RvcnMuZ2V0KHN5c3RlbUlkKTtcbiAgICB9LFxuICAgIGdldEFsbDogKCkgPT4ge1xuICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhrZXllZEFjdG9ycy5lbnRyaWVzKCkpO1xuICAgIH0sXG4gICAgX3NldDogKHN5c3RlbUlkLCBhY3RvclJlZikgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBrZXllZEFjdG9ycy5nZXQoc3lzdGVtSWQpO1xuICAgICAgaWYgKGV4aXN0aW5nICYmIGV4aXN0aW5nICE9PSBhY3RvclJlZikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFjdG9yIHdpdGggc3lzdGVtIElEICcke3N5c3RlbUlkfScgYWxyZWFkeSBleGlzdHMuYCk7XG4gICAgICB9XG4gICAgICBrZXllZEFjdG9ycy5zZXQoc3lzdGVtSWQsIGFjdG9yUmVmKTtcbiAgICAgIHJldmVyc2VLZXllZEFjdG9ycy5zZXQoYWN0b3JSZWYsIHN5c3RlbUlkKTtcbiAgICB9LFxuICAgIGluc3BlY3Q6IG9ic2VydmVyT3JGbiA9PiB7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IHRvT2JzZXJ2ZXIob2JzZXJ2ZXJPckZuKTtcbiAgICAgIGluc3BlY3Rpb25PYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgIGluc3BlY3Rpb25PYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIF9zZW5kSW5zcGVjdGlvbkV2ZW50OiBzZW5kSW5zcGVjdGlvbkV2ZW50LFxuICAgIF9yZWxheTogKHNvdXJjZSwgdGFyZ2V0LCBldmVudCkgPT4ge1xuICAgICAgc3lzdGVtLl9zZW5kSW5zcGVjdGlvbkV2ZW50KHtcbiAgICAgICAgdHlwZTogJ0B4c3RhdGUuZXZlbnQnLFxuICAgICAgICBzb3VyY2VSZWY6IHNvdXJjZSxcbiAgICAgICAgYWN0b3JSZWY6IHRhcmdldCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pO1xuICAgICAgdGFyZ2V0Ll9zZW5kKGV2ZW50KTtcbiAgICB9LFxuICAgIHNjaGVkdWxlcixcbiAgICBnZXRTbmFwc2hvdDogKCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3NjaGVkdWxlZEV2ZW50czoge1xuICAgICAgICAgIC4uLnN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50c1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgc3RhcnQ6ICgpID0+IHtcbiAgICAgIGNvbnN0IHNjaGVkdWxlZEV2ZW50cyA9IHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50cztcbiAgICAgIHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50cyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBzY2hlZHVsZWRJZCBpbiBzY2hlZHVsZWRFdmVudHMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgZGVsYXksXG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IHNjaGVkdWxlZEV2ZW50c1tzY2hlZHVsZWRJZF07XG4gICAgICAgIHNjaGVkdWxlci5zY2hlZHVsZShzb3VyY2UsIHRhcmdldCwgZXZlbnQsIGRlbGF5LCBpZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfY2xvY2s6IGNsb2NrLFxuICAgIF9sb2dnZXI6IGxvZ2dlclxuICB9O1xuICByZXR1cm4gc3lzdGVtO1xufVxuXG4vLyB0aG9zZSBhcmUgbmVlZGVkIHRvIG1ha2UgSlNEb2MgYEBsaW5rYCB3b3JrIHByb3Blcmx5XG5cbmxldCBleGVjdXRpbmdDdXN0b21BY3Rpb24gPSBmYWxzZTtcbmNvbnN0ICQkQUNUT1JfVFlQRSA9IDE7XG5cbi8vIHRob3NlIHZhbHVlcyBhcmUgY3VycmVudGx5IHVzZWQgYnkgQHhzdGF0ZS9yZWFjdCBkaXJlY3RseSBzbyBpdCdzIGltcG9ydGFudCB0byBrZWVwIHRoZSBhc3NpZ25lZCB2YWx1ZXMgaW4gc3luY1xubGV0IFByb2Nlc3NpbmdTdGF0dXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKFByb2Nlc3NpbmdTdGF0dXMpIHtcbiAgUHJvY2Vzc2luZ1N0YXR1c1tQcm9jZXNzaW5nU3RhdHVzW1wiTm90U3RhcnRlZFwiXSA9IDBdID0gXCJOb3RTdGFydGVkXCI7XG4gIFByb2Nlc3NpbmdTdGF0dXNbUHJvY2Vzc2luZ1N0YXR1c1tcIlJ1bm5pbmdcIl0gPSAxXSA9IFwiUnVubmluZ1wiO1xuICBQcm9jZXNzaW5nU3RhdHVzW1Byb2Nlc3NpbmdTdGF0dXNbXCJTdG9wcGVkXCJdID0gMl0gPSBcIlN0b3BwZWRcIjtcbiAgcmV0dXJuIFByb2Nlc3NpbmdTdGF0dXM7XG59KHt9KTtcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBjbG9jazoge1xuICAgIHNldFRpbWVvdXQ6IChmbiwgbXMpID0+IHtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZuLCBtcyk7XG4gICAgfSxcbiAgICBjbGVhclRpbWVvdXQ6IGlkID0+IHtcbiAgICAgIHJldHVybiBjbGVhclRpbWVvdXQoaWQpO1xuICAgIH1cbiAgfSxcbiAgbG9nZ2VyOiBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFxuICBkZXZUb29sczogZmFsc2Vcbn07XG5cbi8qKlxuICogQW4gQWN0b3IgaXMgYSBydW5uaW5nIHByb2Nlc3MgdGhhdCBjYW4gcmVjZWl2ZSBldmVudHMsIHNlbmQgZXZlbnRzIGFuZCBjaGFuZ2VcbiAqIGl0cyBiZWhhdmlvciBiYXNlZCBvbiB0aGUgZXZlbnRzIGl0IHJlY2VpdmVzLCB3aGljaCBjYW4gY2F1c2UgZWZmZWN0cyBvdXRzaWRlXG4gKiBvZiB0aGUgYWN0b3IuIFdoZW4geW91IHJ1biBhIHN0YXRlIG1hY2hpbmUsIGl0IGJlY29tZXMgYW4gYWN0b3IuXG4gKi9cbmNsYXNzIEFjdG9yIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYWN0b3IgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBsb2dpYyB3aXRoIHRoZSBwcm92aWRlZCBvcHRpb25zLFxuICAgKiBpZiBhbnkuXG4gICAqXG4gICAqIEBwYXJhbSBsb2dpYyBUaGUgbG9naWMgdG8gY3JlYXRlIGFuIGFjdG9yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgQWN0b3Igb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IobG9naWMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmxvZ2ljID0gbG9naWM7XG4gICAgLyoqIFRoZSBjdXJyZW50IGludGVybmFsIHN0YXRlIG9mIHRoZSBhY3Rvci4gKi9cbiAgICB0aGlzLl9zbmFwc2hvdCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xvY2sgdGhhdCBpcyByZXNwb25zaWJsZSBmb3Igc2V0dGluZyBhbmQgY2xlYXJpbmcgdGltZW91dHMsIHN1Y2ggYXNcbiAgICAgKiBkZWxheWVkIGV2ZW50cyBhbmQgdHJhbnNpdGlvbnMuXG4gICAgICovXG4gICAgdGhpcy5jbG9jayA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBhY3RvciByZWxhdGl2ZSB0byBpdHMgcGFyZW50LiAqL1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5tYWlsYm94ID0gbmV3IE1haWxib3godGhpcy5fcHJvY2Vzcy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLm9ic2VydmVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID0gUHJvY2Vzc2luZ1N0YXR1cy5Ob3RTdGFydGVkO1xuICAgIC8vIEFjdG9yIFJlZlxuICAgIHRoaXMuX3BhcmVudCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3luY1NuYXBzaG90ID0gdm9pZCAwO1xuICAgIHRoaXMucmVmID0gdm9pZCAwO1xuICAgIC8vIFRPRE86IGFkZCB0eXBpbmdzIGZvciBzeXN0ZW1cbiAgICB0aGlzLl9hY3RvclNjb3BlID0gdm9pZCAwO1xuICAgIHRoaXMuc3lzdGVtSWQgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBnbG9iYWxseSB1bmlxdWUgcHJvY2VzcyBJRCBmb3IgdGhpcyBpbnZvY2F0aW9uLiAqL1xuICAgIHRoaXMuc2Vzc2lvbklkID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgc3lzdGVtIHRvIHdoaWNoIHRoaXMgYWN0b3IgYmVsb25ncy4gKi9cbiAgICB0aGlzLnN5c3RlbSA9IHZvaWQgMDtcbiAgICB0aGlzLl9kb25lRXZlbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5zcmMgPSB2b2lkIDA7XG4gICAgLy8gYXJyYXkgb2YgZnVuY3Rpb25zIHRvIGRlZmVyXG4gICAgdGhpcy5fZGVmZXJyZWQgPSBbXTtcbiAgICBjb25zdCByZXNvbHZlZE9wdGlvbnMgPSB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIGNsb2NrLFxuICAgICAgbG9nZ2VyLFxuICAgICAgcGFyZW50LFxuICAgICAgc3luY1NuYXBzaG90LFxuICAgICAgaWQsXG4gICAgICBzeXN0ZW1JZCxcbiAgICAgIGluc3BlY3RcbiAgICB9ID0gcmVzb2x2ZWRPcHRpb25zO1xuICAgIHRoaXMuc3lzdGVtID0gcGFyZW50ID8gcGFyZW50LnN5c3RlbSA6IGNyZWF0ZVN5c3RlbSh0aGlzLCB7XG4gICAgICBjbG9jayxcbiAgICAgIGxvZ2dlclxuICAgIH0pO1xuICAgIGlmIChpbnNwZWN0ICYmICFwYXJlbnQpIHtcbiAgICAgIC8vIEFsd2F5cyBpbnNwZWN0IGF0IHRoZSBzeXN0ZW0tbGV2ZWxcbiAgICAgIHRoaXMuc3lzdGVtLmluc3BlY3QodG9PYnNlcnZlcihpbnNwZWN0KSk7XG4gICAgfVxuICAgIHRoaXMuc2Vzc2lvbklkID0gdGhpcy5zeXN0ZW0uX2Jvb2tJZCgpO1xuICAgIHRoaXMuaWQgPSBpZCA/PyB0aGlzLnNlc3Npb25JZDtcbiAgICB0aGlzLmxvZ2dlciA9IG9wdGlvbnM/LmxvZ2dlciA/PyB0aGlzLnN5c3RlbS5fbG9nZ2VyO1xuICAgIHRoaXMuY2xvY2sgPSBvcHRpb25zPy5jbG9jayA/PyB0aGlzLnN5c3RlbS5fY2xvY2s7XG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuX3N5bmNTbmFwc2hvdCA9IHN5bmNTbmFwc2hvdDtcbiAgICB0aGlzLm9wdGlvbnMgPSByZXNvbHZlZE9wdGlvbnM7XG4gICAgdGhpcy5zcmMgPSByZXNvbHZlZE9wdGlvbnMuc3JjID8/IGxvZ2ljO1xuICAgIHRoaXMucmVmID0gdGhpcztcbiAgICB0aGlzLl9hY3RvclNjb3BlID0ge1xuICAgICAgc2VsZjogdGhpcyxcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgc2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZCxcbiAgICAgIGxvZ2dlcjogdGhpcy5sb2dnZXIsXG4gICAgICBkZWZlcjogZm4gPT4ge1xuICAgICAgICB0aGlzLl9kZWZlcnJlZC5wdXNoKGZuKTtcbiAgICAgIH0sXG4gICAgICBzeXN0ZW06IHRoaXMuc3lzdGVtLFxuICAgICAgc3RvcENoaWxkOiBjaGlsZCA9PiB7XG4gICAgICAgIGlmIChjaGlsZC5fcGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc3RvcCBjaGlsZCBhY3RvciAke2NoaWxkLmlkfSBvZiAke3RoaXMuaWR9IGJlY2F1c2UgaXQgaXMgbm90IGEgY2hpbGRgKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZC5fc3RvcCgpO1xuICAgICAgfSxcbiAgICAgIGVtaXQ6IGVtaXR0ZWRFdmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMuZ2V0KGVtaXR0ZWRFdmVudC50eXBlKTtcbiAgICAgICAgY29uc3Qgd2lsZGNhcmRMaXN0ZW5lciA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMuZ2V0KCcqJyk7XG4gICAgICAgIGlmICghbGlzdGVuZXJzICYmICF3aWxkY2FyZExpc3RlbmVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbExpc3RlbmVycyA9IFsuLi4obGlzdGVuZXJzID8gbGlzdGVuZXJzLnZhbHVlcygpIDogW10pLCAuLi4od2lsZGNhcmRMaXN0ZW5lciA/IHdpbGRjYXJkTGlzdGVuZXIudmFsdWVzKCkgOiBbXSldO1xuICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgYWxsTGlzdGVuZXJzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGhhbmRsZXIoZW1pdHRlZEV2ZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWN0aW9uRXhlY3V0b3I6IGFjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IGV4ZWMgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fYWN0b3JTY29wZS5zeXN0ZW0uX3NlbmRJbnNwZWN0aW9uRXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogJ0B4c3RhdGUuYWN0aW9uJyxcbiAgICAgICAgICAgIGFjdG9yUmVmOiB0aGlzLFxuICAgICAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgICAgIHR5cGU6IGFjdGlvbi50eXBlLFxuICAgICAgICAgICAgICBwYXJhbXM6IGFjdGlvbi5wYXJhbXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWFjdGlvbi5leGVjKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNhdmVFeGVjdXRpbmdDdXN0b21BY3Rpb24gPSBleGVjdXRpbmdDdXN0b21BY3Rpb247XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV4ZWN1dGluZ0N1c3RvbUFjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICBhY3Rpb24uZXhlYyhhY3Rpb24uaW5mbywgYWN0aW9uLnBhcmFtcyk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGV4ZWN1dGluZ0N1c3RvbUFjdGlvbiA9IHNhdmVFeGVjdXRpbmdDdXN0b21BY3Rpb247XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9PT0gUHJvY2Vzc2luZ1N0YXR1cy5SdW5uaW5nKSB7XG4gICAgICAgICAgZXhlYygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2RlZmVycmVkLnB1c2goZXhlYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIHNlbmQgbWV0aG9kIGlzIGJvdW5kIHRvIHRoaXMgQWN0b3IgaW5zdGFuY2VcbiAgICAvLyBpZiBkZXN0cnVjdHVyZWRcbiAgICB0aGlzLnNlbmQgPSB0aGlzLnNlbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnN5c3RlbS5fc2VuZEluc3BlY3Rpb25FdmVudCh7XG4gICAgICB0eXBlOiAnQHhzdGF0ZS5hY3RvcicsXG4gICAgICBhY3RvclJlZjogdGhpc1xuICAgIH0pO1xuICAgIGlmIChzeXN0ZW1JZCkge1xuICAgICAgdGhpcy5zeXN0ZW1JZCA9IHN5c3RlbUlkO1xuICAgICAgdGhpcy5zeXN0ZW0uX3NldChzeXN0ZW1JZCwgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRTdGF0ZShvcHRpb25zPy5zbmFwc2hvdCA/PyBvcHRpb25zPy5zdGF0ZSk7XG4gICAgaWYgKHN5c3RlbUlkICYmIHRoaXMuX3NuYXBzaG90LnN0YXR1cyAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgIHRoaXMuc3lzdGVtLl91bnJlZ2lzdGVyKHRoaXMpO1xuICAgIH1cbiAgfVxuICBfaW5pdFN0YXRlKHBlcnNpc3RlZFN0YXRlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3NuYXBzaG90ID0gcGVyc2lzdGVkU3RhdGUgPyB0aGlzLmxvZ2ljLnJlc3RvcmVTbmFwc2hvdCA/IHRoaXMubG9naWMucmVzdG9yZVNuYXBzaG90KHBlcnNpc3RlZFN0YXRlLCB0aGlzLl9hY3RvclNjb3BlKSA6IHBlcnNpc3RlZFN0YXRlIDogdGhpcy5sb2dpYy5nZXRJbml0aWFsU25hcHNob3QodGhpcy5fYWN0b3JTY29wZSwgdGhpcy5vcHRpb25zPy5pbnB1dCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBpZiB3ZSBnZXQgaGVyZSB0aGVuIGl0IG1lYW5zIHRoYXQgd2UgYXNzaWduIGEgdmFsdWUgdG8gdGhpcy5fc25hcHNob3QgdGhhdCBpcyBub3Qgb2YgdGhlIGNvcnJlY3QgdHlwZVxuICAgICAgLy8gd2UgY2FuJ3QgZ2V0IHRoZSB0cnVlIGBUU25hcHNob3QgJiB7IHN0YXR1czogJ2Vycm9yJzsgfWAsIGl0J3MgaW1wb3NzaWJsZVxuICAgICAgLy8gc28gcmlnaHQgbm93IHRoaXMgaXMgYSBsaWUgb2Ygc29ydHNcbiAgICAgIHRoaXMuX3NuYXBzaG90ID0ge1xuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICB1cGRhdGUoc25hcHNob3QsIGV2ZW50KSB7XG4gICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgdGhpcy5fc25hcHNob3QgPSBzbmFwc2hvdDtcblxuICAgIC8vIEV4ZWN1dGUgZGVmZXJyZWQgZWZmZWN0c1xuICAgIGxldCBkZWZlcnJlZEZuO1xuICAgIHdoaWxlIChkZWZlcnJlZEZuID0gdGhpcy5fZGVmZXJyZWQuc2hpZnQoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGVmZXJyZWRGbigpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIHRoaXMgZXJyb3IgY2FuIG9ubHkgYmUgY2F1Z2h0IHdoZW4gZXhlY3V0aW5nICppbml0aWFsKiBhY3Rpb25zXG4gICAgICAgIC8vIGl0J3MgdGhlIG9ubHkgdGltZSB3aGVuIHdlIGNhbGwgYWN0aW9ucyBwcm92aWRlZCBieSB0aGUgdXNlciB0aHJvdWdoIHRob3NlIGRlZmVycmVkc1xuICAgICAgICAvLyB3aGVuIHRoZSBhY3RvciBpcyBhbHJlYWR5IHJ1bm5pbmcgd2UgYWx3YXlzIGV4ZWN1dGUgdGhlbSBzeW5jaHJvbm91c2x5IHdoaWxlIHRyYW5zaXRpb25pbmdcbiAgICAgICAgLy8gbm8gXCJidWlsdGluIGRlZmVycmVkXCIgc2hvdWxkIGFjdHVhbGx5IHRocm93IGFuIGVycm9yIHNpbmNlIHRoZXkgYXJlIGVpdGhlciBzYWZlXG4gICAgICAgIC8vIG9yIHRoZSBjb250cm9sIGZsb3cgaXMgcGFzc2VkIHRocm91Z2ggdGhlIG1haWxib3ggYW5kIGVycm9ycyBzaG91bGQgYmUgY2F1Z2h0IGJ5IHRoZSBgX3Byb2Nlc3NgIHVzZWQgYnkgdGhlIG1haWxib3hcbiAgICAgICAgdGhpcy5fZGVmZXJyZWQubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fc25hcHNob3QgPSB7XG4gICAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLl9zbmFwc2hvdC5zdGF0dXMpIHtcbiAgICAgIGNhc2UgJ2FjdGl2ZSc6XG4gICAgICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2YgdGhpcy5vYnNlcnZlcnMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dD8uKHNuYXBzaG90KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgIC8vIG5leHQgb2JzZXJ2ZXJzIGFyZSBtZWFudCB0byBiZSBub3RpZmllZCBhYm91dCBkb25lIHNuYXBzaG90c1xuICAgICAgICAvLyB0aGlzIGNhbiBiZSBzZWVuIGFzIHNvbWV0aGluZyB0aGF0IGlzIGRpZmZlcmVudCBmcm9tIGhvdyBvYnNlcnZhYmxlIHdvcmtcbiAgICAgICAgLy8gYnV0IHdpdGggb2JzZXJ2YWJsZXMgYGNvbXBsZXRlYCBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aG91dCBhbnkgYXJndW1lbnRzXG4gICAgICAgIC8vIGl0J3MgbW9yZSBlcmdvbm9taWMgZm9yIFhTdGF0ZSB0byB0cmVhdCBhIGRvbmUgc25hcHNob3QgYXMgYSBcIm5leHRcIiB2YWx1ZVxuICAgICAgICAvLyBhbmQgdGhlIGNvbXBsZXRpb24gZXZlbnQgYXMgc29tZXRoaW5nIHRoYXQgaXMgc2VwYXJhdGUsXG4gICAgICAgIC8vIHNvbWV0aGluZyB0aGF0IG1lcmVseSBmb2xsb3dzIGVtaXR0aW5nIHRoYXQgZG9uZSBzbmFwc2hvdFxuICAgICAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIHRoaXMub2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQ/LihzbmFwc2hvdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdG9wUHJvY2VkdXJlKCk7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuX2RvbmVFdmVudCA9IGNyZWF0ZURvbmVBY3RvckV2ZW50KHRoaXMuaWQsIHRoaXMuX3NuYXBzaG90Lm91dHB1dCk7XG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgICB0aGlzLnN5c3RlbS5fcmVsYXkodGhpcywgdGhpcy5fcGFyZW50LCB0aGlzLl9kb25lRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICB0aGlzLl9lcnJvcih0aGlzLl9zbmFwc2hvdC5lcnJvcik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLnN5c3RlbS5fc2VuZEluc3BlY3Rpb25FdmVudCh7XG4gICAgICB0eXBlOiAnQHhzdGF0ZS5zbmFwc2hvdCcsXG4gICAgICBhY3RvclJlZjogdGhpcyxcbiAgICAgIGV2ZW50LFxuICAgICAgc25hcHNob3RcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgYW4gb2JzZXJ2ZXIgdG8gYW4gYWN0b3LigJlzIHNuYXBzaG90IHZhbHVlcy5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhlIG9ic2VydmVyIHdpbGwgcmVjZWl2ZSB0aGUgYWN0b3LigJlzIHNuYXBzaG90IHZhbHVlIHdoZW4gaXQgaXMgZW1pdHRlZC5cbiAgICogVGhlIG9ic2VydmVyIGNhbiBiZTpcbiAgICpcbiAgICogLSBBIHBsYWluIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGxhdGVzdCBzbmFwc2hvdCwgb3JcbiAgICogLSBBbiBvYnNlcnZlciBvYmplY3Qgd2hvc2UgYC5uZXh0KHNuYXBzaG90KWAgbWV0aG9kIHJlY2VpdmVzIHRoZSBsYXRlc3RcbiAgICogICBzbmFwc2hvdFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiAvLyBPYnNlcnZlciBhcyBhIHBsYWluIGZ1bmN0aW9uXG4gICAqIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGFjdG9yLnN1YnNjcmliZSgoc25hcHNob3QpID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhzbmFwc2hvdCk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBgdHNcbiAgICogLy8gT2JzZXJ2ZXIgYXMgYW4gb2JqZWN0XG4gICAqIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGFjdG9yLnN1YnNjcmliZSh7XG4gICAqICAgbmV4dChzbmFwc2hvdCkge1xuICAgKiAgICAgY29uc29sZS5sb2coc25hcHNob3QpO1xuICAgKiAgIH0sXG4gICAqICAgZXJyb3IoZXJyKSB7XG4gICAqICAgICAvLyAuLi5cbiAgICogICB9LFxuICAgKiAgIGNvbXBsZXRlKCkge1xuICAgKiAgICAgLy8gLi4uXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIFRoZSByZXR1cm4gdmFsdWUgb2YgYGFjdG9yLnN1YnNjcmliZShvYnNlcnZlcilgIGlzIGEgc3Vic2NyaXB0aW9uIG9iamVjdFxuICAgKiB0aGF0IGhhcyBhbiBgLnVuc3Vic2NyaWJlKClgIG1ldGhvZC4gWW91IGNhbiBjYWxsXG4gICAqIGBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKWAgdG8gdW5zdWJzY3JpYmUgdGhlIG9ic2VydmVyOlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBzdWJzY3JpcHRpb24gPSBhY3Rvci5zdWJzY3JpYmUoKHNuYXBzaG90KSA9PiB7XG4gICAqICAgLy8gLi4uXG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBVbnN1YnNjcmliZSB0aGUgb2JzZXJ2ZXJcbiAgICogc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBXaGVuIHRoZSBhY3RvciBpcyBzdG9wcGVkLCBhbGwgb2YgaXRzIG9ic2VydmVycyB3aWxsIGF1dG9tYXRpY2FsbHkgYmVcbiAgICogdW5zdWJzY3JpYmVkLlxuICAgKlxuICAgKiBAcGFyYW0gb2JzZXJ2ZXIgLSBFaXRoZXIgYSBwbGFpbiBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIHRoZSBsYXRlc3RcbiAgICogICBzbmFwc2hvdCwgb3IgYW4gb2JzZXJ2ZXIgb2JqZWN0IHdob3NlIGAubmV4dChzbmFwc2hvdClgIG1ldGhvZCByZWNlaXZlc1xuICAgKiAgIHRoZSBsYXRlc3Qgc25hcHNob3RcbiAgICovXG5cbiAgc3Vic2NyaWJlKG5leHRMaXN0ZW5lck9yT2JzZXJ2ZXIsIGVycm9yTGlzdGVuZXIsIGNvbXBsZXRlTGlzdGVuZXIpIHtcbiAgICBjb25zdCBvYnNlcnZlciA9IHRvT2JzZXJ2ZXIobmV4dExpc3RlbmVyT3JPYnNlcnZlciwgZXJyb3JMaXN0ZW5lciwgY29tcGxldGVMaXN0ZW5lcik7XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgIT09IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZCkge1xuICAgICAgdGhpcy5vYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoICh0aGlzLl9zbmFwc2hvdC5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlPy4oKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gdGhpcy5fc25hcHNob3QuZXJyb3I7XG4gICAgICAgICAgICBpZiAoIW9ic2VydmVyLmVycm9yKSB7XG4gICAgICAgICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlcik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBvbih0eXBlLCBoYW5kbGVyKSB7XG4gICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMuZ2V0KHR5cGUpO1xuICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLnNldCh0eXBlLCBsaXN0ZW5lcnMpO1xuICAgIH1cbiAgICBjb25zdCB3cmFwcGVkSGFuZGxlciA9IGhhbmRsZXIuYmluZCh1bmRlZmluZWQpO1xuICAgIGxpc3RlbmVycy5hZGQod3JhcHBlZEhhbmRsZXIpO1xuICAgIHJldHVybiB7XG4gICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKHdyYXBwZWRIYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqIFN0YXJ0cyB0aGUgQWN0b3IgZnJvbSB0aGUgaW5pdGlhbCBzdGF0ZSAqL1xuICBzdGFydCgpIHtcbiAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9PT0gUHJvY2Vzc2luZ1N0YXR1cy5SdW5uaW5nKSB7XG4gICAgICAvLyBEbyBub3QgcmVzdGFydCB0aGUgc2VydmljZSBpZiBpdCBpcyBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3luY1NuYXBzaG90KSB7XG4gICAgICB0aGlzLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IHNuYXBzaG90ID0+IHtcbiAgICAgICAgICBpZiAoc25hcHNob3Quc3RhdHVzID09PSAnYWN0aXZlJykge1xuICAgICAgICAgICAgdGhpcy5zeXN0ZW0uX3JlbGF5KHRoaXMsIHRoaXMuX3BhcmVudCwge1xuICAgICAgICAgICAgICB0eXBlOiBgeHN0YXRlLnNuYXBzaG90LiR7dGhpcy5pZH1gLFxuICAgICAgICAgICAgICBzbmFwc2hvdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogKCkgPT4ge31cbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnN5c3RlbS5fcmVnaXN0ZXIodGhpcy5zZXNzaW9uSWQsIHRoaXMpO1xuICAgIGlmICh0aGlzLnN5c3RlbUlkKSB7XG4gICAgICB0aGlzLnN5c3RlbS5fc2V0KHRoaXMuc3lzdGVtSWQsIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID0gUHJvY2Vzc2luZ1N0YXR1cy5SdW5uaW5nO1xuXG4gICAgLy8gVE9ETzogdGhpcyBpc24ndCBjb3JyZWN0IHdoZW4gcmVoeWRyYXRpbmdcbiAgICBjb25zdCBpbml0RXZlbnQgPSBjcmVhdGVJbml0RXZlbnQodGhpcy5vcHRpb25zLmlucHV0KTtcbiAgICB0aGlzLnN5c3RlbS5fc2VuZEluc3BlY3Rpb25FdmVudCh7XG4gICAgICB0eXBlOiAnQHhzdGF0ZS5ldmVudCcsXG4gICAgICBzb3VyY2VSZWY6IHRoaXMuX3BhcmVudCxcbiAgICAgIGFjdG9yUmVmOiB0aGlzLFxuICAgICAgZXZlbnQ6IGluaXRFdmVudFxuICAgIH0pO1xuICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuX3NuYXBzaG90LnN0YXR1cztcbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgIC8vIGEgc3RhdGUgbWFjaGluZSBjYW4gYmUgXCJkb25lXCIgdXBvbiBpbml0aWFsaXphdGlvbiAoaXQgY291bGQgcmVhY2ggYSBmaW5hbCBzdGF0ZSB1c2luZyBpbml0aWFsIG1pY3Jvc3RlcHMpXG4gICAgICAgIC8vIHdlIHN0aWxsIG5lZWQgdG8gY29tcGxldGUgb2JzZXJ2ZXJzLCBmbHVzaCBkZWZlcnJlZHMgZXRjXG4gICAgICAgIHRoaXMudXBkYXRlKHRoaXMuX3NuYXBzaG90LCBpbml0RXZlbnQpO1xuICAgICAgICAvLyBUT0RPOiByZXRoaW5rIGNsZWFudXAgb2Ygb2JzZXJ2ZXJzLCBtYWlsYm94LCBldGNcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHRoaXMuX2Vycm9yKHRoaXMuX3NuYXBzaG90LmVycm9yKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICghdGhpcy5fcGFyZW50KSB7XG4gICAgICB0aGlzLnN5c3RlbS5zdGFydCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5sb2dpYy5zdGFydCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5sb2dpYy5zdGFydCh0aGlzLl9zbmFwc2hvdCwgdGhpcy5fYWN0b3JTY29wZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5fc25hcHNob3QgPSB7XG4gICAgICAgICAgLi4udGhpcy5fc25hcHNob3QsXG4gICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZXJyb3IoZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogdGhpcyBub3RpZmllcyBhbGwgc3Vic2NyaWJlcnMgYnV0IHVzdWFsbHkgdGhpcyBpcyByZWR1bmRhbnRcbiAgICAvLyB0aGVyZSBpcyBubyByZWFsIGNoYW5nZSBoYXBwZW5pbmcgaGVyZVxuICAgIC8vIHdlIG5lZWQgdG8gcmV0aGluayBpZiB0aGlzIG5lZWRzIHRvIGJlIHJlZmFjdG9yZWRcbiAgICB0aGlzLnVwZGF0ZSh0aGlzLl9zbmFwc2hvdCwgaW5pdEV2ZW50KTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmRldlRvb2xzKSB7XG4gICAgICB0aGlzLmF0dGFjaERldlRvb2xzKCk7XG4gICAgfVxuICAgIHRoaXMubWFpbGJveC5zdGFydCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9wcm9jZXNzKGV2ZW50KSB7XG4gICAgbGV0IG5leHRTdGF0ZTtcbiAgICBsZXQgY2F1Z2h0RXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgIG5leHRTdGF0ZSA9IHRoaXMubG9naWMudHJhbnNpdGlvbih0aGlzLl9zbmFwc2hvdCwgZXZlbnQsIHRoaXMuX2FjdG9yU2NvcGUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gd2Ugd3JhcCBpdCBpbiBhIGJveCBzbyB3ZSBjYW4gcmV0aHJvdyBpdCBsYXRlciBldmVuIGlmIGZhbHN5IHZhbHVlIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgIGNhdWdodEVycm9yID0ge1xuICAgICAgICBlcnJcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChjYXVnaHRFcnJvcikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlcnJcbiAgICAgIH0gPSBjYXVnaHRFcnJvcjtcbiAgICAgIHRoaXMuX3NuYXBzaG90ID0ge1xuICAgICAgICAuLi50aGlzLl9zbmFwc2hvdCxcbiAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgICB9O1xuICAgICAgdGhpcy5fZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGUobmV4dFN0YXRlLCBldmVudCk7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IFhTVEFURV9TVE9QKSB7XG4gICAgICB0aGlzLl9zdG9wUHJvY2VkdXJlKCk7XG4gICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxuICBfc3RvcCgpIHtcbiAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9PT0gUHJvY2Vzc2luZ1N0YXR1cy5TdG9wcGVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5tYWlsYm94LmNsZWFyKCk7XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgPT09IFByb2Nlc3NpbmdTdGF0dXMuTm90U3RhcnRlZCkge1xuICAgICAgdGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLm1haWxib3guZW5xdWV1ZSh7XG4gICAgICB0eXBlOiBYU1RBVEVfU1RPUFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIFN0b3BzIHRoZSBBY3RvciBhbmQgdW5zdWJzY3JpYmUgYWxsIGxpc3RlbmVycy4gKi9cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Egbm9uLXJvb3QgYWN0b3IgY2Fubm90IGJlIHN0b3BwZWQgZGlyZWN0bHkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdG9wKCk7XG4gIH1cbiAgX2NvbXBsZXRlKCkge1xuICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2YgdGhpcy5vYnNlcnZlcnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG9ic2VydmVyLmNvbXBsZXRlPy4oKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm9ic2VydmVycy5jbGVhcigpO1xuICB9XG4gIF9yZXBvcnRFcnJvcihlcnIpIHtcbiAgICBpZiAoIXRoaXMub2JzZXJ2ZXJzLnNpemUpIHtcbiAgICAgIGlmICghdGhpcy5fcGFyZW50KSB7XG4gICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCByZXBvcnRFcnJvciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2YgdGhpcy5vYnNlcnZlcnMpIHtcbiAgICAgIGNvbnN0IGVycm9yTGlzdGVuZXIgPSBvYnNlcnZlci5lcnJvcjtcbiAgICAgIHJlcG9ydEVycm9yIHx8PSAhZXJyb3JMaXN0ZW5lcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVycm9yTGlzdGVuZXI/LihlcnIpO1xuICAgICAgfSBjYXRjaCAoZXJyMikge1xuICAgICAgICByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnIyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5vYnNlcnZlcnMuY2xlYXIoKTtcbiAgICBpZiAocmVwb3J0RXJyb3IpIHtcbiAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgfVxuICB9XG4gIF9lcnJvcihlcnIpIHtcbiAgICB0aGlzLl9zdG9wUHJvY2VkdXJlKCk7XG4gICAgdGhpcy5fcmVwb3J0RXJyb3IoZXJyKTtcbiAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICB0aGlzLnN5c3RlbS5fcmVsYXkodGhpcywgdGhpcy5fcGFyZW50LCBjcmVhdGVFcnJvckFjdG9yRXZlbnQodGhpcy5pZCwgZXJyKSk7XG4gICAgfVxuICB9XG4gIC8vIFRPRE86IGF0bSBjaGlsZHJlbiBkb24ndCBiZWxvbmcgZW50aXJlbHkgdG8gdGhlIGFjdG9yIHNvXG4gIC8vIGluIGEgd2F5IC0gaXQncyBub3QgZXZlbiBzdXBlciBhd2FyZSBvZiB0aGVtXG4gIC8vIHNvIHdlIGNhbid0IHN0b3AgdGhlbSBmcm9tIGhlcmUgYnV0IHdlIHJlYWxseSBzaG91bGQhXG4gIC8vIHJpZ2h0IG5vdywgdGhleSBhcmUgYmVpbmcgc3RvcHBlZCB3aXRoaW4gdGhlIG1hY2hpbmUncyB0cmFuc2l0aW9uXG4gIC8vIGJ1dCB0aGF0IGNvdWxkIHRocm93IGFuZCBsZWF2ZSB1cyB3aXRoIFwib3JwaGFuZWRcIiBhY3RpdmUgYWN0b3JzXG4gIF9zdG9wUHJvY2VkdXJlKCkge1xuICAgIGlmICh0aGlzLl9wcm9jZXNzaW5nU3RhdHVzICE9PSBQcm9jZXNzaW5nU3RhdHVzLlJ1bm5pbmcpIHtcbiAgICAgIC8vIEFjdG9yIGFscmVhZHkgc3RvcHBlZDsgZG8gbm90aGluZ1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQ2FuY2VsIGFsbCBkZWxheWVkIGV2ZW50c1xuICAgIHRoaXMuc3lzdGVtLnNjaGVkdWxlci5jYW5jZWxBbGwodGhpcyk7XG5cbiAgICAvLyBUT0RPOiBtYWlsYm94LnJlc2V0XG4gICAgdGhpcy5tYWlsYm94LmNsZWFyKCk7XG4gICAgLy8gVE9ETzogYWZ0ZXIgYHN0b3BgIHdlIG11c3QgcHJlcGFyZSBvdXJzZWx2ZXMgZm9yIHJlY2VpdmluZyBldmVudHMgYWdhaW5cbiAgICAvLyBldmVudHMgc2VudCAqYWZ0ZXIqIHN0b3Agc2lnbmFsIG11c3QgYmUgcXVldWVkXG4gICAgLy8gaXQgc2VlbXMgbGlrZSB0aGlzIHNob3VsZCBiZSB0aGUgY29tbW9uIGJlaGF2aW9yIGZvciBhbGwgb2Ygb3VyIGNvbnN1bWVyc1xuICAgIC8vIHNvIHBlcmhhcHMgdGhpcyBzaG91bGQgYmUgdW5pZmllZCBzb21laG93IGZvciBhbGwgb2YgdGhlbVxuICAgIHRoaXMubWFpbGJveCA9IG5ldyBNYWlsYm94KHRoaXMuX3Byb2Nlc3MuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZDtcbiAgICB0aGlzLnN5c3RlbS5fdW5yZWdpc3Rlcih0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlbmQoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9PT0gUHJvY2Vzc2luZ1N0YXR1cy5TdG9wcGVkKSB7XG4gICAgICAvLyBkbyBub3RoaW5nXG4gICAgICB7XG4gICAgICAgIGNvbnN0IGV2ZW50U3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXZlbnQpO1xuICAgICAgICBjb25zb2xlLndhcm4oYEV2ZW50IFwiJHtldmVudC50eXBlfVwiIHdhcyBzZW50IHRvIHN0b3BwZWQgYWN0b3IgXCIke3RoaXMuaWR9ICgke3RoaXMuc2Vzc2lvbklkfSlcIi4gVGhpcyBhY3RvciBoYXMgYWxyZWFkeSByZWFjaGVkIGl0cyBmaW5hbCBzdGF0ZSwgYW5kIHdpbGwgbm90IHRyYW5zaXRpb24uXFxuRXZlbnQ6ICR7ZXZlbnRTdHJpbmd9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubWFpbGJveC5lbnF1ZXVlKGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhbiBldmVudCB0byB0aGUgcnVubmluZyBBY3RvciB0byB0cmlnZ2VyIGEgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byBzZW5kXG4gICAqL1xuICBzZW5kKGV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT25seSBldmVudCBvYmplY3RzIG1heSBiZSBzZW50IHRvIGFjdG9yczsgdXNlIC5zZW5kKHsgdHlwZTogXCIke2V2ZW50fVwiIH0pIGluc3RlYWRgKTtcbiAgICB9XG4gICAgdGhpcy5zeXN0ZW0uX3JlbGF5KHVuZGVmaW5lZCwgdGhpcywgZXZlbnQpO1xuICB9XG4gIGF0dGFjaERldlRvb2xzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRldlRvb2xzXG4gICAgfSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoZGV2VG9vbHMpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVkRGV2VG9vbHNBZGFwdGVyID0gdHlwZW9mIGRldlRvb2xzID09PSAnZnVuY3Rpb24nID8gZGV2VG9vbHMgOiBkZXZUb29sc0FkYXB0ZXI7XG4gICAgICByZXNvbHZlZERldlRvb2xzQWRhcHRlcih0aGlzKTtcbiAgICB9XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4c3RhdGUkJHR5cGU6ICQkQUNUT1JfVFlQRSxcbiAgICAgIGlkOiB0aGlzLmlkXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnRhaW4gdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBhY3Rvciwgd2hpY2ggY2FuIGJlIHBlcnNpc3RlZC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhlIGludGVybmFsIHN0YXRlIGNhbiBiZSBwZXJzaXN0ZWQgZnJvbSBhbnkgYWN0b3IsIG5vdCBvbmx5IG1hY2hpbmVzLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIHBlcnNpc3RlZCBzdGF0ZSBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIHNuYXBzaG90IGZyb21cbiAgICoge0BsaW5rIEFjdG9yLmdldFNuYXBzaG90fS4gUGVyc2lzdGVkIHN0YXRlIHJlcHJlc2VudHMgdGhlIGludGVybmFsIHN0YXRlIG9mXG4gICAqIHRoZSBhY3Rvciwgd2hpbGUgc25hcHNob3RzIHJlcHJlc2VudCB0aGUgYWN0b3IncyBsYXN0IGVtaXR0ZWQgdmFsdWUuXG4gICAqXG4gICAqIENhbiBiZSByZXN0b3JlZCB3aXRoIHtAbGluayBBY3Rvck9wdGlvbnMuc3RhdGV9XG4gICAqIEBzZWUgaHR0cHM6Ly9zdGF0ZWx5LmFpL2RvY3MvcGVyc2lzdGVuY2VcbiAgICovXG5cbiAgZ2V0UGVyc2lzdGVkU25hcHNob3Qob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmxvZ2ljLmdldFBlcnNpc3RlZFNuYXBzaG90KHRoaXMuX3NuYXBzaG90LCBvcHRpb25zKTtcbiAgfVxuICBbc3ltYm9sT2JzZXJ2YWJsZV0oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhbiBhY3RvcuKAmXMgc25hcHNob3Qgc3luY2hyb25vdXNseS5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhlIHNuYXBzaG90IHJlcHJlc2VudCBhbiBhY3RvcidzIGxhc3QgZW1pdHRlZCB2YWx1ZS5cbiAgICpcbiAgICogV2hlbiBhbiBhY3RvciByZWNlaXZlcyBhbiBldmVudCwgaXRzIGludGVybmFsIHN0YXRlIG1heSBjaGFuZ2UuIEFuIGFjdG9yXG4gICAqIG1heSBlbWl0IGEgc25hcHNob3Qgd2hlbiBhIHN0YXRlIHRyYW5zaXRpb24gb2NjdXJzLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgc29tZSBhY3RvcnMsIHN1Y2ggYXMgY2FsbGJhY2sgYWN0b3JzIGdlbmVyYXRlZCB3aXRoXG4gICAqIGBmcm9tQ2FsbGJhY2tgLCB3aWxsIG5vdCBlbWl0IHNuYXBzaG90cy5cbiAgICogQHNlZSB7QGxpbmsgQWN0b3Iuc3Vic2NyaWJlfSB0byBzdWJzY3JpYmUgdG8gYW4gYWN0b3LigJlzIHNuYXBzaG90IHZhbHVlcy5cbiAgICogQHNlZSB7QGxpbmsgQWN0b3IuZ2V0UGVyc2lzdGVkU25hcHNob3R9IHRvIHBlcnNpc3QgdGhlIGludGVybmFsIHN0YXRlIG9mIGFuIGFjdG9yICh3aGljaCBpcyBtb3JlIHRoYW4ganVzdCBhIHNuYXBzaG90KS5cbiAgICovXG4gIGdldFNuYXBzaG90KCkge1xuICAgIGlmICghdGhpcy5fc25hcHNob3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU25hcHNob3QgY2FuJ3QgYmUgcmVhZCB3aGlsZSB0aGUgYWN0b3IgaW5pdGlhbGl6ZXMgaXRzZWxmYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zbmFwc2hvdDtcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGFjdG9yIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gYWN0b3IgbG9naWMgd2l0aCB0aGUgcHJvdmlkZWRcbiAqIG9wdGlvbnMsIGlmIGFueS5cbiAqXG4gKiBAcmVtYXJrc1xuICogV2hlbiB5b3UgY3JlYXRlIGFuIGFjdG9yIGZyb20gYWN0b3IgbG9naWMgdmlhIGBjcmVhdGVBY3Rvcihsb2dpYylgLCB5b3VcbiAqIGltcGxpY2l0bHkgY3JlYXRlIGFuIGFjdG9yIHN5c3RlbSB3aGVyZSB0aGUgY3JlYXRlZCBhY3RvciBpcyB0aGUgcm9vdCBhY3Rvci5cbiAqIEFueSBhY3RvcnMgc3Bhd25lZCBmcm9tIHRoaXMgcm9vdCBhY3RvciBhbmQgaXRzIGRlc2NlbmRhbnRzIGFyZSBwYXJ0IG9mIHRoYXRcbiAqIGFjdG9yIHN5c3RlbS5cbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNyZWF0ZUFjdG9yIH0gZnJvbSAneHN0YXRlJztcbiAqIGltcG9ydCB7IHNvbWVBY3RvckxvZ2ljIH0gZnJvbSAnLi9zb21lQWN0b3JMb2dpYy50cyc7XG4gKlxuICogLy8gQ3JlYXRpbmcgdGhlIGFjdG9yLCB3aGljaCBpbXBsaWNpdGx5IGNyZWF0ZXMgYW4gYWN0b3Igc3lzdGVtIHdpdGggaXRzZWxmIGFzIHRoZSByb290IGFjdG9yXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKHNvbWVBY3RvckxvZ2ljKTtcbiAqXG4gKiBhY3Rvci5zdWJzY3JpYmUoKHNuYXBzaG90KSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKHNuYXBzaG90KTtcbiAqIH0pO1xuICpcbiAqIC8vIEFjdG9ycyBtdXN0IGJlIHN0YXJ0ZWQgYnkgY2FsbGluZyBgYWN0b3Iuc3RhcnQoKWAsIHdoaWNoIHdpbGwgYWxzbyBzdGFydCB0aGUgYWN0b3Igc3lzdGVtLlxuICogYWN0b3Iuc3RhcnQoKTtcbiAqXG4gKiAvLyBBY3RvcnMgY2FuIHJlY2VpdmUgZXZlbnRzXG4gKiBhY3Rvci5zZW5kKHsgdHlwZTogJ3NvbWVFdmVudCcgfSk7XG4gKlxuICogLy8gWW91IGNhbiBzdG9wIHJvb3QgYWN0b3JzIGJ5IGNhbGxpbmcgYGFjdG9yLnN0b3AoKWAsIHdoaWNoIHdpbGwgYWxzbyBzdG9wIHRoZSBhY3RvciBzeXN0ZW0gYW5kIGFsbCBhY3RvcnMgaW4gdGhhdCBzeXN0ZW0uXG4gKiBhY3Rvci5zdG9wKCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbG9naWMgLSBUaGUgYWN0b3IgbG9naWMgdG8gY3JlYXRlIGFuIGFjdG9yIGZyb20uIEZvciBhIHN0YXRlIG1hY2hpbmVcbiAqICAgYWN0b3IgbG9naWMgY3JlYXRvciwgc2VlIHtAbGluayBjcmVhdGVNYWNoaW5lfS4gT3RoZXIgYWN0b3IgbG9naWMgY3JlYXRvcnNcbiAqICAgaW5jbHVkZSB7QGxpbmsgZnJvbUNhbGxiYWNrfSwge0BsaW5rIGZyb21FdmVudE9ic2VydmFibGV9LFxuICogICB7QGxpbmsgZnJvbU9ic2VydmFibGV9LCB7QGxpbmsgZnJvbVByb21pc2V9LCBhbmQge0BsaW5rIGZyb21UcmFuc2l0aW9ufS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQWN0b3Igb3B0aW9uc1xuICovXG5mdW5jdGlvbiBjcmVhdGVBY3Rvcihsb2dpYywgLi4uW29wdGlvbnNdKSB7XG4gIHJldHVybiBuZXcgQWN0b3IobG9naWMsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgSW50ZXJwcmV0ZXIgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBtYWNoaW5lIHdpdGggdGhlIHByb3ZpZGVkXG4gKiBvcHRpb25zLCBpZiBhbnkuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBjcmVhdGVBY3RvcmAgaW5zdGVhZFxuICogQGFsaWFzXG4gKi9cbmNvbnN0IGludGVycHJldCA9IGNyZWF0ZUFjdG9yO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBgQWN0b3JgIGluc3RlYWQuXG4gKiBAYWxpYXNcbiAqL1xuXG5mdW5jdGlvbiByZXNvbHZlQ2FuY2VsKF8sIHNuYXBzaG90LCBhY3Rpb25BcmdzLCBhY3Rpb25QYXJhbXMsIHtcbiAgc2VuZElkXG59KSB7XG4gIGNvbnN0IHJlc29sdmVkU2VuZElkID0gdHlwZW9mIHNlbmRJZCA9PT0gJ2Z1bmN0aW9uJyA/IHNlbmRJZChhY3Rpb25BcmdzLCBhY3Rpb25QYXJhbXMpIDogc2VuZElkO1xuICByZXR1cm4gW3NuYXBzaG90LCB7XG4gICAgc2VuZElkOiByZXNvbHZlZFNlbmRJZFxuICB9LCB1bmRlZmluZWRdO1xufVxuZnVuY3Rpb24gZXhlY3V0ZUNhbmNlbChhY3RvclNjb3BlLCBwYXJhbXMpIHtcbiAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiB7XG4gICAgYWN0b3JTY29wZS5zeXN0ZW0uc2NoZWR1bGVyLmNhbmNlbChhY3RvclNjb3BlLnNlbGYsIHBhcmFtcy5zZW5kSWQpO1xuICB9KTtcbn1cbi8qKlxuICogQ2FuY2VscyBhIGRlbGF5ZWQgYHNlbmRUbyguLi4pYCBhY3Rpb24gdGhhdCBpcyB3YWl0aW5nIHRvIGJlIGV4ZWN1dGVkLiBUaGVcbiAqIGNhbmNlbGVkIGBzZW5kVG8oLi4uKWAgYWN0aW9uIHdpbGwgbm90IHNlbmQgaXRzIGV2ZW50IG9yIGV4ZWN1dGUsIHVubGVzcyB0aGVcbiAqIGBkZWxheWAgaGFzIGFscmVhZHkgZWxhcHNlZCBiZWZvcmUgYGNhbmNlbCguLi4pYCBpcyBjYWxsZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgY3JlYXRlTWFjaGluZSwgc2VuZFRvLCBjYW5jZWwgfSBmcm9tICd4c3RhdGUnO1xuICpcbiAqIGNvbnN0IG1hY2hpbmUgPSBjcmVhdGVNYWNoaW5lKHtcbiAqICAgLy8gLi4uXG4gKiAgIG9uOiB7XG4gKiAgICAgc2VuZEV2ZW50OiB7XG4gKiAgICAgICBhY3Rpb25zOiBzZW5kVG8oXG4gKiAgICAgICAgICdzb21lLWFjdG9yJyxcbiAqICAgICAgICAgeyB0eXBlOiAnc29tZUV2ZW50JyB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgaWQ6ICdzb21lLWlkJyxcbiAqICAgICAgICAgICBkZWxheTogMTAwMFxuICogICAgICAgICB9XG4gKiAgICAgICApXG4gKiAgICAgfSxcbiAqICAgICBjYW5jZWxFdmVudDoge1xuICogICAgICAgYWN0aW9uczogY2FuY2VsKCdzb21lLWlkJylcbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHNlbmRJZCBUaGUgYGlkYCBvZiB0aGUgYHNlbmRUbyguLi4pYCBhY3Rpb24gdG8gY2FuY2VsLlxuICovXG5mdW5jdGlvbiBjYW5jZWwoc2VuZElkKSB7XG4gIGZ1bmN0aW9uIGNhbmNlbChfYXJncywgX3BhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgY2FuY2VsLnR5cGUgPSAneHN0YXRlLmNhbmNlbCc7XG4gIGNhbmNlbC5zZW5kSWQgPSBzZW5kSWQ7XG4gIGNhbmNlbC5yZXNvbHZlID0gcmVzb2x2ZUNhbmNlbDtcbiAgY2FuY2VsLmV4ZWN1dGUgPSBleGVjdXRlQ2FuY2VsO1xuICByZXR1cm4gY2FuY2VsO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU3Bhd24oYWN0b3JTY29wZSwgc25hcHNob3QsIGFjdGlvbkFyZ3MsIF9hY3Rpb25QYXJhbXMsIHtcbiAgaWQsXG4gIHN5c3RlbUlkLFxuICBzcmMsXG4gIGlucHV0LFxuICBzeW5jU25hcHNob3Rcbn0pIHtcbiAgY29uc3QgbG9naWMgPSB0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyA/IHJlc29sdmVSZWZlcmVuY2VkQWN0b3Ioc25hcHNob3QubWFjaGluZSwgc3JjKSA6IHNyYztcbiAgY29uc3QgcmVzb2x2ZWRJZCA9IHR5cGVvZiBpZCA9PT0gJ2Z1bmN0aW9uJyA/IGlkKGFjdGlvbkFyZ3MpIDogaWQ7XG4gIGxldCBhY3RvclJlZjtcbiAgbGV0IHJlc29sdmVkSW5wdXQgPSB1bmRlZmluZWQ7XG4gIGlmIChsb2dpYykge1xuICAgIHJlc29sdmVkSW5wdXQgPSB0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicgPyBpbnB1dCh7XG4gICAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgICAgZXZlbnQ6IGFjdGlvbkFyZ3MuZXZlbnQsXG4gICAgICBzZWxmOiBhY3RvclNjb3BlLnNlbGZcbiAgICB9KSA6IGlucHV0O1xuICAgIGFjdG9yUmVmID0gY3JlYXRlQWN0b3IobG9naWMsIHtcbiAgICAgIGlkOiByZXNvbHZlZElkLFxuICAgICAgc3JjLFxuICAgICAgcGFyZW50OiBhY3RvclNjb3BlLnNlbGYsXG4gICAgICBzeW5jU25hcHNob3QsXG4gICAgICBzeXN0ZW1JZCxcbiAgICAgIGlucHV0OiByZXNvbHZlZElucHV0XG4gICAgfSk7XG4gIH1cbiAgaWYgKCFhY3RvclJlZikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zLEB0eXBlc2NyaXB0LWVzbGludC9uby1iYXNlLXRvLXN0cmluZ1xuICAgIGBBY3RvciB0eXBlICcke3NyY30nIG5vdCBmb3VuZCBpbiBtYWNoaW5lICcke2FjdG9yU2NvcGUuaWR9Jy5gKTtcbiAgfVxuICByZXR1cm4gW2Nsb25lTWFjaGluZVNuYXBzaG90KHNuYXBzaG90LCB7XG4gICAgY2hpbGRyZW46IHtcbiAgICAgIC4uLnNuYXBzaG90LmNoaWxkcmVuLFxuICAgICAgW3Jlc29sdmVkSWRdOiBhY3RvclJlZlxuICAgIH1cbiAgfSksIHtcbiAgICBpZCxcbiAgICBzeXN0ZW1JZCxcbiAgICBhY3RvclJlZixcbiAgICBzcmMsXG4gICAgaW5wdXQ6IHJlc29sdmVkSW5wdXRcbiAgfSwgdW5kZWZpbmVkXTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVTcGF3bihhY3RvclNjb3BlLCB7XG4gIGFjdG9yUmVmXG59KSB7XG4gIGlmICghYWN0b3JSZWYpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiB7XG4gICAgaWYgKGFjdG9yUmVmLl9wcm9jZXNzaW5nU3RhdHVzID09PSBQcm9jZXNzaW5nU3RhdHVzLlN0b3BwZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWN0b3JSZWYuc3RhcnQoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzcGF3bkNoaWxkKC4uLltzcmMsIHtcbiAgaWQsXG4gIHN5c3RlbUlkLFxuICBpbnB1dCxcbiAgc3luY1NuYXBzaG90ID0gZmFsc2Vcbn0gPSB7fV0pIHtcbiAgZnVuY3Rpb24gc3Bhd25DaGlsZChfYXJncywgX3BhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgc3Bhd25DaGlsZC50eXBlID0gJ3hzdGF0ZS5zcGF3bkNoaWxkJztcbiAgc3Bhd25DaGlsZC5pZCA9IGlkO1xuICBzcGF3bkNoaWxkLnN5c3RlbUlkID0gc3lzdGVtSWQ7XG4gIHNwYXduQ2hpbGQuc3JjID0gc3JjO1xuICBzcGF3bkNoaWxkLmlucHV0ID0gaW5wdXQ7XG4gIHNwYXduQ2hpbGQuc3luY1NuYXBzaG90ID0gc3luY1NuYXBzaG90O1xuICBzcGF3bkNoaWxkLnJlc29sdmUgPSByZXNvbHZlU3Bhd247XG4gIHNwYXduQ2hpbGQuZXhlY3V0ZSA9IGV4ZWN1dGVTcGF3bjtcbiAgcmV0dXJuIHNwYXduQ2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTdG9wKF8sIHNuYXBzaG90LCBhcmdzLCBhY3Rpb25QYXJhbXMsIHtcbiAgYWN0b3JSZWZcbn0pIHtcbiAgY29uc3QgYWN0b3JSZWZPclN0cmluZyA9IHR5cGVvZiBhY3RvclJlZiA9PT0gJ2Z1bmN0aW9uJyA/IGFjdG9yUmVmKGFyZ3MsIGFjdGlvblBhcmFtcykgOiBhY3RvclJlZjtcbiAgY29uc3QgcmVzb2x2ZWRBY3RvclJlZiA9IHR5cGVvZiBhY3RvclJlZk9yU3RyaW5nID09PSAnc3RyaW5nJyA/IHNuYXBzaG90LmNoaWxkcmVuW2FjdG9yUmVmT3JTdHJpbmddIDogYWN0b3JSZWZPclN0cmluZztcbiAgbGV0IGNoaWxkcmVuID0gc25hcHNob3QuY2hpbGRyZW47XG4gIGlmIChyZXNvbHZlZEFjdG9yUmVmKSB7XG4gICAgY2hpbGRyZW4gPSB7XG4gICAgICAuLi5jaGlsZHJlblxuICAgIH07XG4gICAgZGVsZXRlIGNoaWxkcmVuW3Jlc29sdmVkQWN0b3JSZWYuaWRdO1xuICB9XG4gIHJldHVybiBbY2xvbmVNYWNoaW5lU25hcHNob3Qoc25hcHNob3QsIHtcbiAgICBjaGlsZHJlblxuICB9KSwgcmVzb2x2ZWRBY3RvclJlZiwgdW5kZWZpbmVkXTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVTdG9wKGFjdG9yU2NvcGUsIGFjdG9yUmVmKSB7XG4gIGlmICghYWN0b3JSZWYpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyB3ZSBuZWVkIHRvIGVhZ2VybHkgdW5yZWdpc3RlciBpdCBoZXJlIHNvIGEgbmV3IGFjdG9yIHdpdGggdGhlIHNhbWUgc3lzdGVtSWQgY2FuIGJlIHJlZ2lzdGVyZWQgaW1tZWRpYXRlbHlcbiAgLy8gc2luY2Ugd2UgZGVmZXIgYWN0dWFsIHN0b3BwaW5nIG9mIHRoZSBhY3RvciBidXQgd2UgZG9uJ3QgZGVmZXIgYWN0b3IgY3JlYXRpb25zIChhbmQgd2UgY2FuJ3QgZG8gdGhhdClcbiAgLy8gdGhpcyBjb3VsZCB0aHJvdyBvbiBgc3lzdGVtSWRgIGNvbGxpc2lvbiwgZm9yIGV4YW1wbGUsIHdoZW4gZGVhbGluZyB3aXRoIHJlZW50ZXJpbmcgdHJhbnNpdGlvbnNcbiAgYWN0b3JTY29wZS5zeXN0ZW0uX3VucmVnaXN0ZXIoYWN0b3JSZWYpO1xuXG4gIC8vIHRoaXMgYWxsb3dzIHVzIHRvIHByZXZlbnQgYW4gYWN0b3IgZnJvbSBiZWluZyBzdGFydGVkIGlmIGl0IGdldHMgc3RvcHBlZCB3aXRoaW4gdGhlIHNhbWUgbWFjcm9zdGVwXG4gIC8vIHRoaXMgY2FuIGhhcHBlbiwgZm9yIGV4YW1wbGUsIHdoZW4gdGhlIGludm9raW5nIHN0YXRlIGlzIGJlaW5nIGV4aXRlZCBpbW1lZGlhdGVseSBieSBhbiBhbHdheXMgdHJhbnNpdGlvblxuICBpZiAoYWN0b3JSZWYuX3Byb2Nlc3NpbmdTdGF0dXMgIT09IFByb2Nlc3NpbmdTdGF0dXMuUnVubmluZykge1xuICAgIGFjdG9yU2NvcGUuc3RvcENoaWxkKGFjdG9yUmVmKTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gc3RvcHBpbmcgYSBjaGlsZCBlbnF1ZXVlcyBhIHN0b3AgZXZlbnQgaW4gdGhlIGNoaWxkIGFjdG9yJ3MgbWFpbGJveFxuICAvLyB3ZSBuZWVkIGZvciBhbGwgb2YgdGhlIGFscmVhZHkgZW5xdWV1ZWQgZXZlbnRzIHRvIGJlIHByb2Nlc3NlZCBiZWZvcmUgd2Ugc3RvcCB0aGUgY2hpbGRcbiAgLy8gdGhlIHBhcmVudCBpdHNlbGYgbWlnaHQgd2FudCB0byBzZW5kIHNvbWUgZXZlbnRzIHRvIGEgY2hpbGQgKGZvciBleGFtcGxlIGZyb20gZXhpdCBhY3Rpb25zIG9uIHRoZSBpbnZva2luZyBzdGF0ZSlcbiAgLy8gYW5kIHdlIGRvbid0IHdhbnQgdG8gaWdub3JlIHRob3NlIGV2ZW50c1xuICBhY3RvclNjb3BlLmRlZmVyKCgpID0+IHtcbiAgICBhY3RvclNjb3BlLnN0b3BDaGlsZChhY3RvclJlZik7XG4gIH0pO1xufVxuLyoqXG4gKiBTdG9wcyBhIGNoaWxkIGFjdG9yLlxuICpcbiAqIEBwYXJhbSBhY3RvclJlZiBUaGUgYWN0b3IgdG8gc3RvcC5cbiAqL1xuZnVuY3Rpb24gc3RvcENoaWxkKGFjdG9yUmVmKSB7XG4gIGZ1bmN0aW9uIHN0b3AoX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIHN0b3AudHlwZSA9ICd4c3RhdGUuc3RvcENoaWxkJztcbiAgc3RvcC5hY3RvclJlZiA9IGFjdG9yUmVmO1xuICBzdG9wLnJlc29sdmUgPSByZXNvbHZlU3RvcDtcbiAgc3RvcC5leGVjdXRlID0gZXhlY3V0ZVN0b3A7XG4gIHJldHVybiBzdG9wO1xufVxuXG4vKipcbiAqIFN0b3BzIGEgY2hpbGQgYWN0b3IuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBzdG9wQ2hpbGQoLi4uKWAgaW5zdGVhZFxuICogQGFsaWFzXG4gKi9cbmNvbnN0IHN0b3AgPSBzdG9wQ2hpbGQ7XG5cbmZ1bmN0aW9uIGNoZWNrU3RhdGVJbihzbmFwc2hvdCwgXywge1xuICBzdGF0ZVZhbHVlXG59KSB7XG4gIGlmICh0eXBlb2Ygc3RhdGVWYWx1ZSA9PT0gJ3N0cmluZycgJiYgaXNTdGF0ZUlkKHN0YXRlVmFsdWUpKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gc25hcHNob3QubWFjaGluZS5nZXRTdGF0ZU5vZGVCeUlkKHN0YXRlVmFsdWUpO1xuICAgIHJldHVybiBzbmFwc2hvdC5fbm9kZXMuc29tZShzbiA9PiBzbiA9PT0gdGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gc25hcHNob3QubWF0Y2hlcyhzdGF0ZVZhbHVlKTtcbn1cbmZ1bmN0aW9uIHN0YXRlSW4oc3RhdGVWYWx1ZSkge1xuICBmdW5jdGlvbiBzdGF0ZUluKCkge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgc3RhdGVJbi5jaGVjayA9IGNoZWNrU3RhdGVJbjtcbiAgc3RhdGVJbi5zdGF0ZVZhbHVlID0gc3RhdGVWYWx1ZTtcbiAgcmV0dXJuIHN0YXRlSW47XG59XG5mdW5jdGlvbiBjaGVja05vdChzbmFwc2hvdCwge1xuICBjb250ZXh0LFxuICBldmVudFxufSwge1xuICBndWFyZHNcbn0pIHtcbiAgcmV0dXJuICFldmFsdWF0ZUd1YXJkKGd1YXJkc1swXSwgY29udGV4dCwgZXZlbnQsIHNuYXBzaG90KTtcbn1cblxuLyoqXG4gKiBIaWdoZXItb3JkZXIgZ3VhcmQgdGhhdCBldmFsdWF0ZXMgdG8gYHRydWVgIGlmIHRoZSBgZ3VhcmRgIHBhc3NlZCB0byBpdFxuICogZXZhbHVhdGVzIHRvIGBmYWxzZWAuXG4gKlxuICogQGNhdGVnb3J5IEd1YXJkc1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgc2V0dXAsIG5vdCB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgbWFjaGluZSA9IHNldHVwKHtcbiAqICAgZ3VhcmRzOiB7XG4gKiAgICAgc29tZU5hbWVkR3VhcmQ6ICgpID0+IGZhbHNlXG4gKiAgIH1cbiAqIH0pLmNyZWF0ZU1hY2hpbmUoe1xuICogICBvbjoge1xuICogICAgIHNvbWVFdmVudDoge1xuICogICAgICAgZ3VhcmQ6IG5vdCgnc29tZU5hbWVkR3VhcmQnKSxcbiAqICAgICAgIGFjdGlvbnM6ICgpID0+IHtcbiAqICAgICAgICAgLy8gd2lsbCBiZSBleGVjdXRlZCBpZiBndWFyZCBpbiBgbm90KC4uLilgXG4gKiAgICAgICAgIC8vIGV2YWx1YXRlcyB0byBgZmFsc2VgXG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEByZXR1cm5zIEEgZ3VhcmRcbiAqL1xuZnVuY3Rpb24gbm90KGd1YXJkKSB7XG4gIGZ1bmN0aW9uIG5vdChfYXJncywgX3BhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgbm90LmNoZWNrID0gY2hlY2tOb3Q7XG4gIG5vdC5ndWFyZHMgPSBbZ3VhcmRdO1xuICByZXR1cm4gbm90O1xufVxuZnVuY3Rpb24gY2hlY2tBbmQoc25hcHNob3QsIHtcbiAgY29udGV4dCxcbiAgZXZlbnRcbn0sIHtcbiAgZ3VhcmRzXG59KSB7XG4gIHJldHVybiBndWFyZHMuZXZlcnkoZ3VhcmQgPT4gZXZhbHVhdGVHdWFyZChndWFyZCwgY29udGV4dCwgZXZlbnQsIHNuYXBzaG90KSk7XG59XG5cbi8qKlxuICogSGlnaGVyLW9yZGVyIGd1YXJkIHRoYXQgZXZhbHVhdGVzIHRvIGB0cnVlYCBpZiBhbGwgYGd1YXJkc2AgcGFzc2VkIHRvIGl0XG4gKiBldmFsdWF0ZSB0byBgdHJ1ZWAuXG4gKlxuICogQGNhdGVnb3J5IEd1YXJkc1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgc2V0dXAsIGFuZCB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgbWFjaGluZSA9IHNldHVwKHtcbiAqICAgZ3VhcmRzOiB7XG4gKiAgICAgc29tZU5hbWVkR3VhcmQ6ICgpID0+IHRydWVcbiAqICAgfVxuICogfSkuY3JlYXRlTWFjaGluZSh7XG4gKiAgIG9uOiB7XG4gKiAgICAgc29tZUV2ZW50OiB7XG4gKiAgICAgICBndWFyZDogYW5kKFsoeyBjb250ZXh0IH0pID0+IGNvbnRleHQudmFsdWUgPiAwLCAnc29tZU5hbWVkR3VhcmQnXSksXG4gKiAgICAgICBhY3Rpb25zOiAoKSA9PiB7XG4gKiAgICAgICAgIC8vIHdpbGwgYmUgZXhlY3V0ZWQgaWYgYWxsIGd1YXJkcyBpbiBgYW5kKC4uLilgXG4gKiAgICAgICAgIC8vIGV2YWx1YXRlIHRvIHRydWVcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHJldHVybnMgQSBndWFyZCBhY3Rpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGFuZChndWFyZHMpIHtcbiAgZnVuY3Rpb24gYW5kKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBhbmQuY2hlY2sgPSBjaGVja0FuZDtcbiAgYW5kLmd1YXJkcyA9IGd1YXJkcztcbiAgcmV0dXJuIGFuZDtcbn1cbmZ1bmN0aW9uIGNoZWNrT3Ioc25hcHNob3QsIHtcbiAgY29udGV4dCxcbiAgZXZlbnRcbn0sIHtcbiAgZ3VhcmRzXG59KSB7XG4gIHJldHVybiBndWFyZHMuc29tZShndWFyZCA9PiBldmFsdWF0ZUd1YXJkKGd1YXJkLCBjb250ZXh0LCBldmVudCwgc25hcHNob3QpKTtcbn1cblxuLyoqXG4gKiBIaWdoZXItb3JkZXIgZ3VhcmQgdGhhdCBldmFsdWF0ZXMgdG8gYHRydWVgIGlmIGFueSBvZiB0aGUgYGd1YXJkc2AgcGFzc2VkIHRvXG4gKiBpdCBldmFsdWF0ZSB0byBgdHJ1ZWAuXG4gKlxuICogQGNhdGVnb3J5IEd1YXJkc1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgc2V0dXAsIG9yIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiBjb25zdCBtYWNoaW5lID0gc2V0dXAoe1xuICogICBndWFyZHM6IHtcbiAqICAgICBzb21lTmFtZWRHdWFyZDogKCkgPT4gdHJ1ZVxuICogICB9XG4gKiB9KS5jcmVhdGVNYWNoaW5lKHtcbiAqICAgb246IHtcbiAqICAgICBzb21lRXZlbnQ6IHtcbiAqICAgICAgIGd1YXJkOiBvcihbKHsgY29udGV4dCB9KSA9PiBjb250ZXh0LnZhbHVlID4gMCwgJ3NvbWVOYW1lZEd1YXJkJ10pLFxuICogICAgICAgYWN0aW9uczogKCkgPT4ge1xuICogICAgICAgICAvLyB3aWxsIGJlIGV4ZWN1dGVkIGlmIGFueSBvZiB0aGUgZ3VhcmRzIGluIGBvciguLi4pYFxuICogICAgICAgICAvLyBldmFsdWF0ZSB0byB0cnVlXG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEByZXR1cm5zIEEgZ3VhcmQgYWN0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBvcihndWFyZHMpIHtcbiAgZnVuY3Rpb24gb3IoX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIG9yLmNoZWNrID0gY2hlY2tPcjtcbiAgb3IuZ3VhcmRzID0gZ3VhcmRzO1xuICByZXR1cm4gb3I7XG59XG5cbi8vIFRPRE86IHRocm93IG9uIGN5Y2xlcyAoZGVwdGggY2hlY2sgc2hvdWxkIGJlIGVub3VnaClcbmZ1bmN0aW9uIGV2YWx1YXRlR3VhcmQoZ3VhcmQsIGNvbnRleHQsIGV2ZW50LCBzbmFwc2hvdCkge1xuICBjb25zdCB7XG4gICAgbWFjaGluZVxuICB9ID0gc25hcHNob3Q7XG4gIGNvbnN0IGlzSW5saW5lID0gdHlwZW9mIGd1YXJkID09PSAnZnVuY3Rpb24nO1xuICBjb25zdCByZXNvbHZlZCA9IGlzSW5saW5lID8gZ3VhcmQgOiBtYWNoaW5lLmltcGxlbWVudGF0aW9ucy5ndWFyZHNbdHlwZW9mIGd1YXJkID09PSAnc3RyaW5nJyA/IGd1YXJkIDogZ3VhcmQudHlwZV07XG4gIGlmICghaXNJbmxpbmUgJiYgIXJlc29sdmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBHdWFyZCAnJHt0eXBlb2YgZ3VhcmQgPT09ICdzdHJpbmcnID8gZ3VhcmQgOiBndWFyZC50eXBlfScgaXMgbm90IGltcGxlbWVudGVkLicuYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiByZXNvbHZlZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBldmFsdWF0ZUd1YXJkKHJlc29sdmVkLCBjb250ZXh0LCBldmVudCwgc25hcHNob3QpO1xuICB9XG4gIGNvbnN0IGd1YXJkQXJncyA9IHtcbiAgICBjb250ZXh0LFxuICAgIGV2ZW50XG4gIH07XG4gIGNvbnN0IGd1YXJkUGFyYW1zID0gaXNJbmxpbmUgfHwgdHlwZW9mIGd1YXJkID09PSAnc3RyaW5nJyA/IHVuZGVmaW5lZCA6ICdwYXJhbXMnIGluIGd1YXJkID8gdHlwZW9mIGd1YXJkLnBhcmFtcyA9PT0gJ2Z1bmN0aW9uJyA/IGd1YXJkLnBhcmFtcyh7XG4gICAgY29udGV4dCxcbiAgICBldmVudFxuICB9KSA6IGd1YXJkLnBhcmFtcyA6IHVuZGVmaW5lZDtcbiAgaWYgKCEoJ2NoZWNrJyBpbiByZXNvbHZlZCkpIHtcbiAgICAvLyB0aGUgZXhpc3RpbmcgdHlwZSBvZiBgLmd1YXJkc2AgYXNzdW1lcyBub24tbnVsbGFibGUgYFRFeHByZXNzaW9uR3VhcmRgXG4gICAgLy8gaW5saW5lIGd1YXJkcyBleHBlY3QgYFRFeHByZXNzaW9uR3VhcmRgIHRvIGJlIHNldCB0byBgdW5kZWZpbmVkYFxuICAgIC8vIGl0J3MgZmluZSB0byBjYXN0IHRoaXMgaGVyZSwgb3VyIGxvZ2ljIG1ha2VzIHN1cmUgdGhhdCB3ZSBjYWxsIHRob3NlIDIgXCJ2YXJpYW50c1wiIGNvcnJlY3RseVxuICAgIHJldHVybiByZXNvbHZlZChndWFyZEFyZ3MsIGd1YXJkUGFyYW1zKTtcbiAgfVxuICBjb25zdCBidWlsdGluR3VhcmQgPSByZXNvbHZlZDtcbiAgcmV0dXJuIGJ1aWx0aW5HdWFyZC5jaGVjayhzbmFwc2hvdCwgZ3VhcmRBcmdzLCByZXNvbHZlZCAvLyB0aGlzIGhvbGRzIGFsbCBwYXJhbXNcbiAgKTtcbn1cblxuY29uc3QgaXNBdG9taWNTdGF0ZU5vZGUgPSBzdGF0ZU5vZGUgPT4gc3RhdGVOb2RlLnR5cGUgPT09ICdhdG9taWMnIHx8IHN0YXRlTm9kZS50eXBlID09PSAnZmluYWwnO1xuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4oc3RhdGVOb2RlKSB7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKHN0YXRlTm9kZS5zdGF0ZXMpLmZpbHRlcihzbiA9PiBzbi50eXBlICE9PSAnaGlzdG9yeScpO1xufVxuZnVuY3Rpb24gZ2V0UHJvcGVyQW5jZXN0b3JzKHN0YXRlTm9kZSwgdG9TdGF0ZU5vZGUpIHtcbiAgY29uc3QgYW5jZXN0b3JzID0gW107XG4gIGlmICh0b1N0YXRlTm9kZSA9PT0gc3RhdGVOb2RlKSB7XG4gICAgcmV0dXJuIGFuY2VzdG9ycztcbiAgfVxuXG4gIC8vIGFkZCBhbGwgYW5jZXN0b3JzXG4gIGxldCBtID0gc3RhdGVOb2RlLnBhcmVudDtcbiAgd2hpbGUgKG0gJiYgbSAhPT0gdG9TdGF0ZU5vZGUpIHtcbiAgICBhbmNlc3RvcnMucHVzaChtKTtcbiAgICBtID0gbS5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGFuY2VzdG9ycztcbn1cbmZ1bmN0aW9uIGdldEFsbFN0YXRlTm9kZXMoc3RhdGVOb2Rlcykge1xuICBjb25zdCBub2RlU2V0ID0gbmV3IFNldChzdGF0ZU5vZGVzKTtcbiAgY29uc3QgYWRqTGlzdCA9IGdldEFkakxpc3Qobm9kZVNldCk7XG5cbiAgLy8gYWRkIGRlc2NlbmRhbnRzXG4gIGZvciAoY29uc3QgcyBvZiBub2RlU2V0KSB7XG4gICAgLy8gaWYgcHJldmlvdXNseSBhY3RpdmUsIGFkZCBleGlzdGluZyBjaGlsZCBub2Rlc1xuICAgIGlmIChzLnR5cGUgPT09ICdjb21wb3VuZCcgJiYgKCFhZGpMaXN0LmdldChzKSB8fCAhYWRqTGlzdC5nZXQocykubGVuZ3RoKSkge1xuICAgICAgZ2V0SW5pdGlhbFN0YXRlTm9kZXNXaXRoVGhlaXJBbmNlc3RvcnMocykuZm9yRWFjaChzbiA9PiBub2RlU2V0LmFkZChzbikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocy50eXBlID09PSAncGFyYWxsZWwnKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgZ2V0Q2hpbGRyZW4ocykpIHtcbiAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2hpc3RvcnknKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFub2RlU2V0LmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxTdGF0ZXMgPSBnZXRJbml0aWFsU3RhdGVOb2Rlc1dpdGhUaGVpckFuY2VzdG9ycyhjaGlsZCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluaXRpYWxTdGF0ZU5vZGUgb2YgaW5pdGlhbFN0YXRlcykge1xuICAgICAgICAgICAgICBub2RlU2V0LmFkZChpbml0aWFsU3RhdGVOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBhZGQgYWxsIGFuY2VzdG9yc1xuICBmb3IgKGNvbnN0IHMgb2Ygbm9kZVNldCkge1xuICAgIGxldCBtID0gcy5wYXJlbnQ7XG4gICAgd2hpbGUgKG0pIHtcbiAgICAgIG5vZGVTZXQuYWRkKG0pO1xuICAgICAgbSA9IG0ucGFyZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZVNldDtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlRnJvbUFkaihiYXNlTm9kZSwgYWRqTGlzdCkge1xuICBjb25zdCBjaGlsZFN0YXRlTm9kZXMgPSBhZGpMaXN0LmdldChiYXNlTm9kZSk7XG4gIGlmICghY2hpbGRTdGF0ZU5vZGVzKSB7XG4gICAgcmV0dXJuIHt9OyAvLyB0b2RvOiBmaXg/XG4gIH1cbiAgaWYgKGJhc2VOb2RlLnR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICBjb25zdCBjaGlsZFN0YXRlTm9kZSA9IGNoaWxkU3RhdGVOb2Rlc1swXTtcbiAgICBpZiAoY2hpbGRTdGF0ZU5vZGUpIHtcbiAgICAgIGlmIChpc0F0b21pY1N0YXRlTm9kZShjaGlsZFN0YXRlTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkU3RhdGVOb2RlLmtleTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfVxuICBjb25zdCBzdGF0ZVZhbHVlID0ge307XG4gIGZvciAoY29uc3QgY2hpbGRTdGF0ZU5vZGUgb2YgY2hpbGRTdGF0ZU5vZGVzKSB7XG4gICAgc3RhdGVWYWx1ZVtjaGlsZFN0YXRlTm9kZS5rZXldID0gZ2V0VmFsdWVGcm9tQWRqKGNoaWxkU3RhdGVOb2RlLCBhZGpMaXN0KTtcbiAgfVxuICByZXR1cm4gc3RhdGVWYWx1ZTtcbn1cbmZ1bmN0aW9uIGdldEFkakxpc3Qoc3RhdGVOb2Rlcykge1xuICBjb25zdCBhZGpMaXN0ID0gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IHMgb2Ygc3RhdGVOb2Rlcykge1xuICAgIGlmICghYWRqTGlzdC5oYXMocykpIHtcbiAgICAgIGFkakxpc3Quc2V0KHMsIFtdKTtcbiAgICB9XG4gICAgaWYgKHMucGFyZW50KSB7XG4gICAgICBpZiAoIWFkakxpc3QuaGFzKHMucGFyZW50KSkge1xuICAgICAgICBhZGpMaXN0LnNldChzLnBhcmVudCwgW10pO1xuICAgICAgfVxuICAgICAgYWRqTGlzdC5nZXQocy5wYXJlbnQpLnB1c2gocyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhZGpMaXN0O1xufVxuZnVuY3Rpb24gZ2V0U3RhdGVWYWx1ZShyb290Tm9kZSwgc3RhdGVOb2Rlcykge1xuICBjb25zdCBjb25maWcgPSBnZXRBbGxTdGF0ZU5vZGVzKHN0YXRlTm9kZXMpO1xuICByZXR1cm4gZ2V0VmFsdWVGcm9tQWRqKHJvb3ROb2RlLCBnZXRBZGpMaXN0KGNvbmZpZykpO1xufVxuZnVuY3Rpb24gaXNJbkZpbmFsU3RhdGUoc3RhdGVOb2RlU2V0LCBzdGF0ZU5vZGUpIHtcbiAgaWYgKHN0YXRlTm9kZS50eXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgcmV0dXJuIGdldENoaWxkcmVuKHN0YXRlTm9kZSkuc29tZShzID0+IHMudHlwZSA9PT0gJ2ZpbmFsJyAmJiBzdGF0ZU5vZGVTZXQuaGFzKHMpKTtcbiAgfVxuICBpZiAoc3RhdGVOb2RlLnR5cGUgPT09ICdwYXJhbGxlbCcpIHtcbiAgICByZXR1cm4gZ2V0Q2hpbGRyZW4oc3RhdGVOb2RlKS5ldmVyeShzbiA9PiBpc0luRmluYWxTdGF0ZShzdGF0ZU5vZGVTZXQsIHNuKSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlTm9kZS50eXBlID09PSAnZmluYWwnO1xufVxuY29uc3QgaXNTdGF0ZUlkID0gc3RyID0+IHN0clswXSA9PT0gU1RBVEVfSURFTlRJRklFUjtcbmZ1bmN0aW9uIGdldENhbmRpZGF0ZXMoc3RhdGVOb2RlLCByZWNlaXZlZEV2ZW50VHlwZSkge1xuICBjb25zdCBjYW5kaWRhdGVzID0gc3RhdGVOb2RlLnRyYW5zaXRpb25zLmdldChyZWNlaXZlZEV2ZW50VHlwZSkgfHwgWy4uLnN0YXRlTm9kZS50cmFuc2l0aW9ucy5rZXlzKCldLmZpbHRlcihldmVudERlc2NyaXB0b3IgPT4gbWF0Y2hlc0V2ZW50RGVzY3JpcHRvcihyZWNlaXZlZEV2ZW50VHlwZSwgZXZlbnREZXNjcmlwdG9yKSkuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aCkuZmxhdE1hcChrZXkgPT4gc3RhdGVOb2RlLnRyYW5zaXRpb25zLmdldChrZXkpKTtcbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59XG5cbi8qKiBBbGwgZGVsYXllZCB0cmFuc2l0aW9ucyBmcm9tIHRoZSBjb25maWcuICovXG5mdW5jdGlvbiBnZXREZWxheWVkVHJhbnNpdGlvbnMoc3RhdGVOb2RlKSB7XG4gIGNvbnN0IGFmdGVyQ29uZmlnID0gc3RhdGVOb2RlLmNvbmZpZy5hZnRlcjtcbiAgaWYgKCFhZnRlckNvbmZpZykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBtdXRhdGVFbnRyeUV4aXQgPSBkZWxheSA9PiB7XG4gICAgY29uc3QgYWZ0ZXJFdmVudCA9IGNyZWF0ZUFmdGVyRXZlbnQoZGVsYXksIHN0YXRlTm9kZS5pZCk7XG4gICAgY29uc3QgZXZlbnRUeXBlID0gYWZ0ZXJFdmVudC50eXBlO1xuICAgIHN0YXRlTm9kZS5lbnRyeS5wdXNoKHJhaXNlKGFmdGVyRXZlbnQsIHtcbiAgICAgIGlkOiBldmVudFR5cGUsXG4gICAgICBkZWxheVxuICAgIH0pKTtcbiAgICBzdGF0ZU5vZGUuZXhpdC5wdXNoKGNhbmNlbChldmVudFR5cGUpKTtcbiAgICByZXR1cm4gZXZlbnRUeXBlO1xuICB9O1xuICBjb25zdCBkZWxheWVkVHJhbnNpdGlvbnMgPSBPYmplY3Qua2V5cyhhZnRlckNvbmZpZykuZmxhdE1hcChkZWxheSA9PiB7XG4gICAgY29uc3QgY29uZmlnVHJhbnNpdGlvbiA9IGFmdGVyQ29uZmlnW2RlbGF5XTtcbiAgICBjb25zdCByZXNvbHZlZFRyYW5zaXRpb24gPSB0eXBlb2YgY29uZmlnVHJhbnNpdGlvbiA9PT0gJ3N0cmluZycgPyB7XG4gICAgICB0YXJnZXQ6IGNvbmZpZ1RyYW5zaXRpb25cbiAgICB9IDogY29uZmlnVHJhbnNpdGlvbjtcbiAgICBjb25zdCByZXNvbHZlZERlbGF5ID0gTnVtYmVyLmlzTmFOKCtkZWxheSkgPyBkZWxheSA6ICtkZWxheTtcbiAgICBjb25zdCBldmVudFR5cGUgPSBtdXRhdGVFbnRyeUV4aXQocmVzb2x2ZWREZWxheSk7XG4gICAgcmV0dXJuIHRvQXJyYXkocmVzb2x2ZWRUcmFuc2l0aW9uKS5tYXAodHJhbnNpdGlvbiA9PiAoe1xuICAgICAgLi4udHJhbnNpdGlvbixcbiAgICAgIGV2ZW50OiBldmVudFR5cGUsXG4gICAgICBkZWxheTogcmVzb2x2ZWREZWxheVxuICAgIH0pKTtcbiAgfSk7XG4gIHJldHVybiBkZWxheWVkVHJhbnNpdGlvbnMubWFwKGRlbGF5ZWRUcmFuc2l0aW9uID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBkZWxheVxuICAgIH0gPSBkZWxheWVkVHJhbnNpdGlvbjtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZm9ybWF0VHJhbnNpdGlvbihzdGF0ZU5vZGUsIGRlbGF5ZWRUcmFuc2l0aW9uLmV2ZW50LCBkZWxheWVkVHJhbnNpdGlvbiksXG4gICAgICBkZWxheVxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gZm9ybWF0VHJhbnNpdGlvbihzdGF0ZU5vZGUsIGRlc2NyaXB0b3IsIHRyYW5zaXRpb25Db25maWcpIHtcbiAgY29uc3Qgbm9ybWFsaXplZFRhcmdldCA9IG5vcm1hbGl6ZVRhcmdldCh0cmFuc2l0aW9uQ29uZmlnLnRhcmdldCk7XG4gIGNvbnN0IHJlZW50ZXIgPSB0cmFuc2l0aW9uQ29uZmlnLnJlZW50ZXIgPz8gZmFsc2U7XG4gIGNvbnN0IHRhcmdldCA9IHJlc29sdmVUYXJnZXQoc3RhdGVOb2RlLCBub3JtYWxpemVkVGFyZ2V0KTtcblxuICAvLyBUT0RPOiBzaG91bGQgdGhpcyBiZSBwYXJ0IG9mIGEgbGludCBydWxlIGluc3RlYWQ/XG4gIGlmICh0cmFuc2l0aW9uQ29uZmlnLmNvbmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YXRlIFwiJHtzdGF0ZU5vZGUuaWR9XCIgaGFzIGRlY2xhcmVkIFxcYGNvbmRcXGAgZm9yIG9uZSBvZiBpdHMgdHJhbnNpdGlvbnMuIFRoaXMgcHJvcGVydHkgaGFzIGJlZW4gcmVuYW1lZCB0byBcXGBndWFyZFxcYC4gUGxlYXNlIHVwZGF0ZSB5b3VyIGNvZGUuYCk7XG4gIH1cbiAgY29uc3QgdHJhbnNpdGlvbiA9IHtcbiAgICAuLi50cmFuc2l0aW9uQ29uZmlnLFxuICAgIGFjdGlvbnM6IHRvQXJyYXkodHJhbnNpdGlvbkNvbmZpZy5hY3Rpb25zKSxcbiAgICBndWFyZDogdHJhbnNpdGlvbkNvbmZpZy5ndWFyZCxcbiAgICB0YXJnZXQsXG4gICAgc291cmNlOiBzdGF0ZU5vZGUsXG4gICAgcmVlbnRlcixcbiAgICBldmVudFR5cGU6IGRlc2NyaXB0b3IsXG4gICAgdG9KU09OOiAoKSA9PiAoe1xuICAgICAgLi4udHJhbnNpdGlvbixcbiAgICAgIHNvdXJjZTogYCMke3N0YXRlTm9kZS5pZH1gLFxuICAgICAgdGFyZ2V0OiB0YXJnZXQgPyB0YXJnZXQubWFwKHQgPT4gYCMke3QuaWR9YCkgOiB1bmRlZmluZWRcbiAgICB9KVxuICB9O1xuICByZXR1cm4gdHJhbnNpdGlvbjtcbn1cbmZ1bmN0aW9uIGZvcm1hdFRyYW5zaXRpb25zKHN0YXRlTm9kZSkge1xuICBjb25zdCB0cmFuc2l0aW9ucyA9IG5ldyBNYXAoKTtcbiAgaWYgKHN0YXRlTm9kZS5jb25maWcub24pIHtcbiAgICBmb3IgKGNvbnN0IGRlc2NyaXB0b3Igb2YgT2JqZWN0LmtleXMoc3RhdGVOb2RlLmNvbmZpZy5vbikpIHtcbiAgICAgIGlmIChkZXNjcmlwdG9yID09PSBOVUxMX0VWRU5UKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTnVsbCBldmVudHMgKFwiXCIpIGNhbm5vdCBiZSBzcGVjaWZpZWQgYXMgYSB0cmFuc2l0aW9uIGtleS4gVXNlIGBhbHdheXM6IHsgLi4uIH1gIGluc3RlYWQuJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2l0aW9uc0NvbmZpZyA9IHN0YXRlTm9kZS5jb25maWcub25bZGVzY3JpcHRvcl07XG4gICAgICB0cmFuc2l0aW9ucy5zZXQoZGVzY3JpcHRvciwgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkodHJhbnNpdGlvbnNDb25maWcpLm1hcCh0ID0+IGZvcm1hdFRyYW5zaXRpb24oc3RhdGVOb2RlLCBkZXNjcmlwdG9yLCB0KSkpO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGVOb2RlLmNvbmZpZy5vbkRvbmUpIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gYHhzdGF0ZS5kb25lLnN0YXRlLiR7c3RhdGVOb2RlLmlkfWA7XG4gICAgdHJhbnNpdGlvbnMuc2V0KGRlc2NyaXB0b3IsIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KHN0YXRlTm9kZS5jb25maWcub25Eb25lKS5tYXAodCA9PiBmb3JtYXRUcmFuc2l0aW9uKHN0YXRlTm9kZSwgZGVzY3JpcHRvciwgdCkpKTtcbiAgfVxuICBmb3IgKGNvbnN0IGludm9rZURlZiBvZiBzdGF0ZU5vZGUuaW52b2tlKSB7XG4gICAgaWYgKGludm9rZURlZi5vbkRvbmUpIHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBgeHN0YXRlLmRvbmUuYWN0b3IuJHtpbnZva2VEZWYuaWR9YDtcbiAgICAgIHRyYW5zaXRpb25zLnNldChkZXNjcmlwdG9yLCB0b1RyYW5zaXRpb25Db25maWdBcnJheShpbnZva2VEZWYub25Eb25lKS5tYXAodCA9PiBmb3JtYXRUcmFuc2l0aW9uKHN0YXRlTm9kZSwgZGVzY3JpcHRvciwgdCkpKTtcbiAgICB9XG4gICAgaWYgKGludm9rZURlZi5vbkVycm9yKSB7XG4gICAgICBjb25zdCBkZXNjcmlwdG9yID0gYHhzdGF0ZS5lcnJvci5hY3Rvci4ke2ludm9rZURlZi5pZH1gO1xuICAgICAgdHJhbnNpdGlvbnMuc2V0KGRlc2NyaXB0b3IsIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KGludm9rZURlZi5vbkVycm9yKS5tYXAodCA9PiBmb3JtYXRUcmFuc2l0aW9uKHN0YXRlTm9kZSwgZGVzY3JpcHRvciwgdCkpKTtcbiAgICB9XG4gICAgaWYgKGludm9rZURlZi5vblNuYXBzaG90KSB7XG4gICAgICBjb25zdCBkZXNjcmlwdG9yID0gYHhzdGF0ZS5zbmFwc2hvdC4ke2ludm9rZURlZi5pZH1gO1xuICAgICAgdHJhbnNpdGlvbnMuc2V0KGRlc2NyaXB0b3IsIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KGludm9rZURlZi5vblNuYXBzaG90KS5tYXAodCA9PiBmb3JtYXRUcmFuc2l0aW9uKHN0YXRlTm9kZSwgZGVzY3JpcHRvciwgdCkpKTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBkZWxheWVkVHJhbnNpdGlvbiBvZiBzdGF0ZU5vZGUuYWZ0ZXIpIHtcbiAgICBsZXQgZXhpc3RpbmcgPSB0cmFuc2l0aW9ucy5nZXQoZGVsYXllZFRyYW5zaXRpb24uZXZlbnRUeXBlKTtcbiAgICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgICBleGlzdGluZyA9IFtdO1xuICAgICAgdHJhbnNpdGlvbnMuc2V0KGRlbGF5ZWRUcmFuc2l0aW9uLmV2ZW50VHlwZSwgZXhpc3RpbmcpO1xuICAgIH1cbiAgICBleGlzdGluZy5wdXNoKGRlbGF5ZWRUcmFuc2l0aW9uKTtcbiAgfVxuICByZXR1cm4gdHJhbnNpdGlvbnM7XG59XG5mdW5jdGlvbiBmb3JtYXRJbml0aWFsVHJhbnNpdGlvbihzdGF0ZU5vZGUsIF90YXJnZXQpIHtcbiAgY29uc3QgcmVzb2x2ZWRUYXJnZXQgPSB0eXBlb2YgX3RhcmdldCA9PT0gJ3N0cmluZycgPyBzdGF0ZU5vZGUuc3RhdGVzW190YXJnZXRdIDogX3RhcmdldCA/IHN0YXRlTm9kZS5zdGF0ZXNbX3RhcmdldC50YXJnZXRdIDogdW5kZWZpbmVkO1xuICBpZiAoIXJlc29sdmVkVGFyZ2V0ICYmIF90YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9ucywgQHR5cGVzY3JpcHQtZXNsaW50L25vLWJhc2UtdG8tc3RyaW5nXG4gICAgYEluaXRpYWwgc3RhdGUgbm9kZSBcIiR7X3RhcmdldH1cIiBub3QgZm91bmQgb24gcGFyZW50IHN0YXRlIG5vZGUgIyR7c3RhdGVOb2RlLmlkfWApO1xuICB9XG4gIGNvbnN0IHRyYW5zaXRpb24gPSB7XG4gICAgc291cmNlOiBzdGF0ZU5vZGUsXG4gICAgYWN0aW9uczogIV90YXJnZXQgfHwgdHlwZW9mIF90YXJnZXQgPT09ICdzdHJpbmcnID8gW10gOiB0b0FycmF5KF90YXJnZXQuYWN0aW9ucyksXG4gICAgZXZlbnRUeXBlOiBudWxsLFxuICAgIHJlZW50ZXI6IGZhbHNlLFxuICAgIHRhcmdldDogcmVzb2x2ZWRUYXJnZXQgPyBbcmVzb2x2ZWRUYXJnZXRdIDogW10sXG4gICAgdG9KU09OOiAoKSA9PiAoe1xuICAgICAgLi4udHJhbnNpdGlvbixcbiAgICAgIHNvdXJjZTogYCMke3N0YXRlTm9kZS5pZH1gLFxuICAgICAgdGFyZ2V0OiByZXNvbHZlZFRhcmdldCA/IFtgIyR7cmVzb2x2ZWRUYXJnZXQuaWR9YF0gOiBbXVxuICAgIH0pXG4gIH07XG4gIHJldHVybiB0cmFuc2l0aW9uO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldChzdGF0ZU5vZGUsIHRhcmdldHMpIHtcbiAgaWYgKHRhcmdldHMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGFuIHVuZGVmaW5lZCB0YXJnZXQgc2lnbmFscyB0aGF0IHRoZSBzdGF0ZSBub2RlIHNob3VsZCBub3QgdHJhbnNpdGlvbiBmcm9tIHRoYXQgc3RhdGUgd2hlbiByZWNlaXZpbmcgdGhhdCBldmVudFxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHRhcmdldHMubWFwKHRhcmdldCA9PiB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBpZiAoaXNTdGF0ZUlkKHRhcmdldCkpIHtcbiAgICAgIHJldHVybiBzdGF0ZU5vZGUubWFjaGluZS5nZXRTdGF0ZU5vZGVCeUlkKHRhcmdldCk7XG4gICAgfVxuICAgIGNvbnN0IGlzSW50ZXJuYWxUYXJnZXQgPSB0YXJnZXRbMF0gPT09IFNUQVRFX0RFTElNSVRFUjtcbiAgICAvLyBJZiBpbnRlcm5hbCB0YXJnZXQgaXMgZGVmaW5lZCBvbiBtYWNoaW5lLFxuICAgIC8vIGRvIG5vdCBpbmNsdWRlIG1hY2hpbmUga2V5IG9uIHRhcmdldFxuICAgIGlmIChpc0ludGVybmFsVGFyZ2V0ICYmICFzdGF0ZU5vZGUucGFyZW50KSB7XG4gICAgICByZXR1cm4gZ2V0U3RhdGVOb2RlQnlQYXRoKHN0YXRlTm9kZSwgdGFyZ2V0LnNsaWNlKDEpKTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRUYXJnZXQgPSBpc0ludGVybmFsVGFyZ2V0ID8gc3RhdGVOb2RlLmtleSArIHRhcmdldCA6IHRhcmdldDtcbiAgICBpZiAoc3RhdGVOb2RlLnBhcmVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0U3RhdGVOb2RlID0gZ2V0U3RhdGVOb2RlQnlQYXRoKHN0YXRlTm9kZS5wYXJlbnQsIHJlc29sdmVkVGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFN0YXRlTm9kZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdHJhbnNpdGlvbiBkZWZpbml0aW9uIGZvciBzdGF0ZSBub2RlICcke3N0YXRlTm9kZS5pZH0nOlxcbiR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0YXJnZXQ6IFwiJHt0YXJnZXR9XCIgaXMgbm90IGEgdmFsaWQgdGFyZ2V0IGZyb20gdGhlIHJvb3Qgbm9kZS4gRGlkIHlvdSBtZWFuIFwiLiR7dGFyZ2V0fVwiP2ApO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXNvbHZlSGlzdG9yeURlZmF1bHRUcmFuc2l0aW9uKHN0YXRlTm9kZSkge1xuICBjb25zdCBub3JtYWxpemVkVGFyZ2V0ID0gbm9ybWFsaXplVGFyZ2V0KHN0YXRlTm9kZS5jb25maWcudGFyZ2V0KTtcbiAgaWYgKCFub3JtYWxpemVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHN0YXRlTm9kZS5wYXJlbnQuaW5pdGlhbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRhcmdldDogbm9ybWFsaXplZFRhcmdldC5tYXAodCA9PiB0eXBlb2YgdCA9PT0gJ3N0cmluZycgPyBnZXRTdGF0ZU5vZGVCeVBhdGgoc3RhdGVOb2RlLnBhcmVudCwgdCkgOiB0KVxuICB9O1xufVxuZnVuY3Rpb24gaXNIaXN0b3J5Tm9kZShzdGF0ZU5vZGUpIHtcbiAgcmV0dXJuIHN0YXRlTm9kZS50eXBlID09PSAnaGlzdG9yeSc7XG59XG5mdW5jdGlvbiBnZXRJbml0aWFsU3RhdGVOb2Rlc1dpdGhUaGVpckFuY2VzdG9ycyhzdGF0ZU5vZGUpIHtcbiAgY29uc3Qgc3RhdGVzID0gZ2V0SW5pdGlhbFN0YXRlTm9kZXMoc3RhdGVOb2RlKTtcbiAgZm9yIChjb25zdCBpbml0aWFsU3RhdGUgb2Ygc3RhdGVzKSB7XG4gICAgZm9yIChjb25zdCBhbmNlc3RvciBvZiBnZXRQcm9wZXJBbmNlc3RvcnMoaW5pdGlhbFN0YXRlLCBzdGF0ZU5vZGUpKSB7XG4gICAgICBzdGF0ZXMuYWRkKGFuY2VzdG9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXRlcztcbn1cbmZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZU5vZGVzKHN0YXRlTm9kZSkge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG4gIGZ1bmN0aW9uIGl0ZXIoZGVzY1N0YXRlTm9kZSkge1xuICAgIGlmIChzZXQuaGFzKGRlc2NTdGF0ZU5vZGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldC5hZGQoZGVzY1N0YXRlTm9kZSk7XG4gICAgaWYgKGRlc2NTdGF0ZU5vZGUudHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgICAgaXRlcihkZXNjU3RhdGVOb2RlLmluaXRpYWwudGFyZ2V0WzBdKTtcbiAgICB9IGVsc2UgaWYgKGRlc2NTdGF0ZU5vZGUudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBnZXRDaGlsZHJlbihkZXNjU3RhdGVOb2RlKSkge1xuICAgICAgICBpdGVyKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXRlcihzdGF0ZU5vZGUpO1xuICByZXR1cm4gc2V0O1xufVxuLyoqIFJldHVybnMgdGhlIGNoaWxkIHN0YXRlIG5vZGUgZnJvbSBpdHMgcmVsYXRpdmUgYHN0YXRlS2V5YCwgb3IgdGhyb3dzLiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGVOb2RlKHN0YXRlTm9kZSwgc3RhdGVLZXkpIHtcbiAgaWYgKGlzU3RhdGVJZChzdGF0ZUtleSkpIHtcbiAgICByZXR1cm4gc3RhdGVOb2RlLm1hY2hpbmUuZ2V0U3RhdGVOb2RlQnlJZChzdGF0ZUtleSk7XG4gIH1cbiAgaWYgKCFzdGF0ZU5vZGUuc3RhdGVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcmV0cmlldmUgY2hpbGQgc3RhdGUgJyR7c3RhdGVLZXl9JyBmcm9tICcke3N0YXRlTm9kZS5pZH0nOyBubyBjaGlsZCBzdGF0ZXMgZXhpc3QuYCk7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gc3RhdGVOb2RlLnN0YXRlc1tzdGF0ZUtleV07XG4gIGlmICghcmVzdWx0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDaGlsZCBzdGF0ZSAnJHtzdGF0ZUtleX0nIGRvZXMgbm90IGV4aXN0IG9uICcke3N0YXRlTm9kZS5pZH0nYCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZWxhdGl2ZSBzdGF0ZSBub2RlIGZyb20gdGhlIGdpdmVuIGBzdGF0ZVBhdGhgLCBvciB0aHJvd3MuXG4gKlxuICogQHBhcmFtIHN0YXRlUGF0aCBUaGUgc3RyaW5nIG9yIHN0cmluZyBhcnJheSByZWxhdGl2ZSBwYXRoIHRvIHRoZSBzdGF0ZSBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRTdGF0ZU5vZGVCeVBhdGgoc3RhdGVOb2RlLCBzdGF0ZVBhdGgpIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZVBhdGggPT09ICdzdHJpbmcnICYmIGlzU3RhdGVJZChzdGF0ZVBhdGgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBzdGF0ZU5vZGUubWFjaGluZS5nZXRTdGF0ZU5vZGVCeUlkKHN0YXRlUGF0aCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyB0cnkgaW5kaXZpZHVhbCBwYXRoc1xuICAgICAgLy8gdGhyb3cgZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgYXJyYXlTdGF0ZVBhdGggPSB0b1N0YXRlUGF0aChzdGF0ZVBhdGgpLnNsaWNlKCk7XG4gIGxldCBjdXJyZW50U3RhdGVOb2RlID0gc3RhdGVOb2RlO1xuICB3aGlsZSAoYXJyYXlTdGF0ZVBhdGgubGVuZ3RoKSB7XG4gICAgY29uc3Qga2V5ID0gYXJyYXlTdGF0ZVBhdGguc2hpZnQoKTtcbiAgICBpZiAoIWtleS5sZW5ndGgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjdXJyZW50U3RhdGVOb2RlID0gZ2V0U3RhdGVOb2RlKGN1cnJlbnRTdGF0ZU5vZGUsIGtleSk7XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnRTdGF0ZU5vZGU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RhdGUgbm9kZXMgcmVwcmVzZW50ZWQgYnkgdGhlIGN1cnJlbnQgc3RhdGUgdmFsdWUuXG4gKlxuICogQHBhcmFtIHN0YXRlVmFsdWUgVGhlIHN0YXRlIHZhbHVlIG9yIFN0YXRlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXRlTm9kZXMoc3RhdGVOb2RlLCBzdGF0ZVZhbHVlKSB7XG4gIGlmICh0eXBlb2Ygc3RhdGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBjaGlsZFN0YXRlTm9kZSA9IHN0YXRlTm9kZS5zdGF0ZXNbc3RhdGVWYWx1ZV07XG4gICAgaWYgKCFjaGlsZFN0YXRlTm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdGF0ZSAnJHtzdGF0ZVZhbHVlfScgZG9lcyBub3QgZXhpc3Qgb24gJyR7c3RhdGVOb2RlLmlkfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIFtzdGF0ZU5vZGUsIGNoaWxkU3RhdGVOb2RlXTtcbiAgfVxuICBjb25zdCBjaGlsZFN0YXRlS2V5cyA9IE9iamVjdC5rZXlzKHN0YXRlVmFsdWUpO1xuICBjb25zdCBjaGlsZFN0YXRlTm9kZXMgPSBjaGlsZFN0YXRlS2V5cy5tYXAoc3ViU3RhdGVLZXkgPT4gZ2V0U3RhdGVOb2RlKHN0YXRlTm9kZSwgc3ViU3RhdGVLZXkpKS5maWx0ZXIoQm9vbGVhbik7XG4gIHJldHVybiBbc3RhdGVOb2RlLm1hY2hpbmUucm9vdCwgc3RhdGVOb2RlXS5jb25jYXQoY2hpbGRTdGF0ZU5vZGVzLCBjaGlsZFN0YXRlS2V5cy5yZWR1Y2UoKGFsbFN1YlN0YXRlTm9kZXMsIHN1YlN0YXRlS2V5KSA9PiB7XG4gICAgY29uc3Qgc3ViU3RhdGVOb2RlID0gZ2V0U3RhdGVOb2RlKHN0YXRlTm9kZSwgc3ViU3RhdGVLZXkpO1xuICAgIGlmICghc3ViU3RhdGVOb2RlKSB7XG4gICAgICByZXR1cm4gYWxsU3ViU3RhdGVOb2RlcztcbiAgICB9XG4gICAgY29uc3Qgc3ViU3RhdGVOb2RlcyA9IGdldFN0YXRlTm9kZXMoc3ViU3RhdGVOb2RlLCBzdGF0ZVZhbHVlW3N1YlN0YXRlS2V5XSk7XG4gICAgcmV0dXJuIGFsbFN1YlN0YXRlTm9kZXMuY29uY2F0KHN1YlN0YXRlTm9kZXMpO1xuICB9LCBbXSkpO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbkF0b21pY05vZGUoc3RhdGVOb2RlLCBzdGF0ZVZhbHVlLCBzbmFwc2hvdCwgZXZlbnQpIHtcbiAgY29uc3QgY2hpbGRTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdGF0ZVZhbHVlKTtcbiAgY29uc3QgbmV4dCA9IGNoaWxkU3RhdGVOb2RlLm5leHQoc25hcHNob3QsIGV2ZW50KTtcbiAgaWYgKCFuZXh0IHx8ICFuZXh0Lmxlbmd0aCkge1xuICAgIHJldHVybiBzdGF0ZU5vZGUubmV4dChzbmFwc2hvdCwgZXZlbnQpO1xuICB9XG4gIHJldHVybiBuZXh0O1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbkNvbXBvdW5kTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCkge1xuICBjb25zdCBzdWJTdGF0ZUtleXMgPSBPYmplY3Qua2V5cyhzdGF0ZVZhbHVlKTtcbiAgY29uc3QgY2hpbGRTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdWJTdGF0ZUtleXNbMF0pO1xuICBjb25zdCBuZXh0ID0gdHJhbnNpdGlvbk5vZGUoY2hpbGRTdGF0ZU5vZGUsIHN0YXRlVmFsdWVbc3ViU3RhdGVLZXlzWzBdXSwgc25hcHNob3QsIGV2ZW50KTtcbiAgaWYgKCFuZXh0IHx8ICFuZXh0Lmxlbmd0aCkge1xuICAgIHJldHVybiBzdGF0ZU5vZGUubmV4dChzbmFwc2hvdCwgZXZlbnQpO1xuICB9XG4gIHJldHVybiBuZXh0O1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvblBhcmFsbGVsTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCkge1xuICBjb25zdCBhbGxJbm5lclRyYW5zaXRpb25zID0gW107XG4gIGZvciAoY29uc3Qgc3ViU3RhdGVLZXkgb2YgT2JqZWN0LmtleXMoc3RhdGVWYWx1ZSkpIHtcbiAgICBjb25zdCBzdWJTdGF0ZVZhbHVlID0gc3RhdGVWYWx1ZVtzdWJTdGF0ZUtleV07XG4gICAgaWYgKCFzdWJTdGF0ZVZhbHVlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qgc3ViU3RhdGVOb2RlID0gZ2V0U3RhdGVOb2RlKHN0YXRlTm9kZSwgc3ViU3RhdGVLZXkpO1xuICAgIGNvbnN0IGlubmVyVHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9uTm9kZShzdWJTdGF0ZU5vZGUsIHN1YlN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCk7XG4gICAgaWYgKGlubmVyVHJhbnNpdGlvbnMpIHtcbiAgICAgIGFsbElubmVyVHJhbnNpdGlvbnMucHVzaCguLi5pbm5lclRyYW5zaXRpb25zKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFhbGxJbm5lclRyYW5zaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBzdGF0ZU5vZGUubmV4dChzbmFwc2hvdCwgZXZlbnQpO1xuICB9XG4gIHJldHVybiBhbGxJbm5lclRyYW5zaXRpb25zO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbk5vZGUoc3RhdGVOb2RlLCBzdGF0ZVZhbHVlLCBzbmFwc2hvdCwgZXZlbnQpIHtcbiAgLy8gbGVhZiBub2RlXG4gIGlmICh0eXBlb2Ygc3RhdGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbkF0b21pY05vZGUoc3RhdGVOb2RlLCBzdGF0ZVZhbHVlLCBzbmFwc2hvdCwgZXZlbnQpO1xuICB9XG5cbiAgLy8gY29tcG91bmQgbm9kZVxuICBpZiAoT2JqZWN0LmtleXMoc3RhdGVWYWx1ZSkubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25Db21wb3VuZE5vZGUoc3RhdGVOb2RlLCBzdGF0ZVZhbHVlLCBzbmFwc2hvdCwgZXZlbnQpO1xuICB9XG5cbiAgLy8gcGFyYWxsZWwgbm9kZVxuICByZXR1cm4gdHJhbnNpdGlvblBhcmFsbGVsTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCk7XG59XG5mdW5jdGlvbiBnZXRIaXN0b3J5Tm9kZXMoc3RhdGVOb2RlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzdGF0ZU5vZGUuc3RhdGVzKS5tYXAoa2V5ID0+IHN0YXRlTm9kZS5zdGF0ZXNba2V5XSkuZmlsdGVyKHNuID0+IHNuLnR5cGUgPT09ICdoaXN0b3J5Jyk7XG59XG5mdW5jdGlvbiBpc0Rlc2NlbmRhbnQoY2hpbGRTdGF0ZU5vZGUsIHBhcmVudFN0YXRlTm9kZSkge1xuICBsZXQgbWFya2VyID0gY2hpbGRTdGF0ZU5vZGU7XG4gIHdoaWxlIChtYXJrZXIucGFyZW50ICYmIG1hcmtlci5wYXJlbnQgIT09IHBhcmVudFN0YXRlTm9kZSkge1xuICAgIG1hcmtlciA9IG1hcmtlci5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG1hcmtlci5wYXJlbnQgPT09IHBhcmVudFN0YXRlTm9kZTtcbn1cbmZ1bmN0aW9uIGhhc0ludGVyc2VjdGlvbihzMSwgczIpIHtcbiAgY29uc3Qgc2V0MSA9IG5ldyBTZXQoczEpO1xuICBjb25zdCBzZXQyID0gbmV3IFNldChzMik7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBzZXQxKSB7XG4gICAgaWYgKHNldDIuaGFzKGl0ZW0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBpdGVtIG9mIHNldDIpIHtcbiAgICBpZiAoc2V0MS5oYXMoaXRlbSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZW1vdmVDb25mbGljdGluZ1RyYW5zaXRpb25zKGVuYWJsZWRUcmFuc2l0aW9ucywgc3RhdGVOb2RlU2V0LCBoaXN0b3J5VmFsdWUpIHtcbiAgY29uc3QgZmlsdGVyZWRUcmFuc2l0aW9ucyA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCB0MSBvZiBlbmFibGVkVHJhbnNpdGlvbnMpIHtcbiAgICBsZXQgdDFQcmVlbXB0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCB0cmFuc2l0aW9uc1RvUmVtb3ZlID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgdDIgb2YgZmlsdGVyZWRUcmFuc2l0aW9ucykge1xuICAgICAgaWYgKGhhc0ludGVyc2VjdGlvbihjb21wdXRlRXhpdFNldChbdDFdLCBzdGF0ZU5vZGVTZXQsIGhpc3RvcnlWYWx1ZSksIGNvbXB1dGVFeGl0U2V0KFt0Ml0sIHN0YXRlTm9kZVNldCwgaGlzdG9yeVZhbHVlKSkpIHtcbiAgICAgICAgaWYgKGlzRGVzY2VuZGFudCh0MS5zb3VyY2UsIHQyLnNvdXJjZSkpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uc1RvUmVtb3ZlLmFkZCh0Mik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdDFQcmVlbXB0ZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdDFQcmVlbXB0ZWQpIHtcbiAgICAgIGZvciAoY29uc3QgdDMgb2YgdHJhbnNpdGlvbnNUb1JlbW92ZSkge1xuICAgICAgICBmaWx0ZXJlZFRyYW5zaXRpb25zLmRlbGV0ZSh0Myk7XG4gICAgICB9XG4gICAgICBmaWx0ZXJlZFRyYW5zaXRpb25zLmFkZCh0MSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKGZpbHRlcmVkVHJhbnNpdGlvbnMpO1xufVxuZnVuY3Rpb24gZmluZExlYXN0Q29tbW9uQW5jZXN0b3Ioc3RhdGVOb2Rlcykge1xuICBjb25zdCBbaGVhZCwgLi4udGFpbF0gPSBzdGF0ZU5vZGVzO1xuICBmb3IgKGNvbnN0IGFuY2VzdG9yIG9mIGdldFByb3BlckFuY2VzdG9ycyhoZWFkLCB1bmRlZmluZWQpKSB7XG4gICAgaWYgKHRhaWwuZXZlcnkoc24gPT4gaXNEZXNjZW5kYW50KHNuLCBhbmNlc3RvcikpKSB7XG4gICAgICByZXR1cm4gYW5jZXN0b3I7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRFZmZlY3RpdmVUYXJnZXRTdGF0ZXModHJhbnNpdGlvbiwgaGlzdG9yeVZhbHVlKSB7XG4gIGlmICghdHJhbnNpdGlvbi50YXJnZXQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgdGFyZ2V0cyA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCB0YXJnZXROb2RlIG9mIHRyYW5zaXRpb24udGFyZ2V0KSB7XG4gICAgaWYgKGlzSGlzdG9yeU5vZGUodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGlmIChoaXN0b3J5VmFsdWVbdGFyZ2V0Tm9kZS5pZF0pIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGhpc3RvcnlWYWx1ZVt0YXJnZXROb2RlLmlkXSkge1xuICAgICAgICAgIHRhcmdldHMuYWRkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgZ2V0RWZmZWN0aXZlVGFyZ2V0U3RhdGVzKHJlc29sdmVIaXN0b3J5RGVmYXVsdFRyYW5zaXRpb24odGFyZ2V0Tm9kZSksIGhpc3RvcnlWYWx1ZSkpIHtcbiAgICAgICAgICB0YXJnZXRzLmFkZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRzLmFkZCh0YXJnZXROb2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsuLi50YXJnZXRzXTtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25Eb21haW4odHJhbnNpdGlvbiwgaGlzdG9yeVZhbHVlKSB7XG4gIGNvbnN0IHRhcmdldFN0YXRlcyA9IGdldEVmZmVjdGl2ZVRhcmdldFN0YXRlcyh0cmFuc2l0aW9uLCBoaXN0b3J5VmFsdWUpO1xuICBpZiAoIXRhcmdldFN0YXRlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXRyYW5zaXRpb24ucmVlbnRlciAmJiB0YXJnZXRTdGF0ZXMuZXZlcnkodGFyZ2V0ID0+IHRhcmdldCA9PT0gdHJhbnNpdGlvbi5zb3VyY2UgfHwgaXNEZXNjZW5kYW50KHRhcmdldCwgdHJhbnNpdGlvbi5zb3VyY2UpKSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uLnNvdXJjZTtcbiAgfVxuICBjb25zdCBsY2EgPSBmaW5kTGVhc3RDb21tb25BbmNlc3Rvcih0YXJnZXRTdGF0ZXMuY29uY2F0KHRyYW5zaXRpb24uc291cmNlKSk7XG4gIGlmIChsY2EpIHtcbiAgICByZXR1cm4gbGNhO1xuICB9XG5cbiAgLy8gYXQgdGhpcyBwb2ludCB3ZSBrbm93IHRoYXQgaXQncyBhIHJvb3QgdHJhbnNpdGlvbiBzaW5jZSBMQ0EgY291bGRuJ3QgYmUgZm91bmRcbiAgaWYgKHRyYW5zaXRpb24ucmVlbnRlcikge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gdHJhbnNpdGlvbi5zb3VyY2UubWFjaGluZS5yb290O1xufVxuZnVuY3Rpb24gY29tcHV0ZUV4aXRTZXQodHJhbnNpdGlvbnMsIHN0YXRlTm9kZVNldCwgaGlzdG9yeVZhbHVlKSB7XG4gIGNvbnN0IHN0YXRlc1RvRXhpdCA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCB0IG9mIHRyYW5zaXRpb25zKSB7XG4gICAgaWYgKHQudGFyZ2V0Py5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGRvbWFpbiA9IGdldFRyYW5zaXRpb25Eb21haW4odCwgaGlzdG9yeVZhbHVlKTtcbiAgICAgIGlmICh0LnJlZW50ZXIgJiYgdC5zb3VyY2UgPT09IGRvbWFpbikge1xuICAgICAgICBzdGF0ZXNUb0V4aXQuYWRkKGRvbWFpbik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHN0YXRlTm9kZSBvZiBzdGF0ZU5vZGVTZXQpIHtcbiAgICAgICAgaWYgKGlzRGVzY2VuZGFudChzdGF0ZU5vZGUsIGRvbWFpbikpIHtcbiAgICAgICAgICBzdGF0ZXNUb0V4aXQuYWRkKHN0YXRlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsuLi5zdGF0ZXNUb0V4aXRdO1xufVxuZnVuY3Rpb24gYXJlU3RhdGVOb2RlQ29sbGVjdGlvbnNFcXVhbChwcmV2U3RhdGVOb2RlcywgbmV4dFN0YXRlTm9kZVNldCkge1xuICBpZiAocHJldlN0YXRlTm9kZXMubGVuZ3RoICE9PSBuZXh0U3RhdGVOb2RlU2V0LnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBub2RlIG9mIHByZXZTdGF0ZU5vZGVzKSB7XG4gICAgaWYgKCFuZXh0U3RhdGVOb2RlU2V0Lmhhcyhub2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zY3htbC8jbWljcm9zdGVwUHJvY2VkdXJlICovXG5mdW5jdGlvbiBtaWNyb3N0ZXAodHJhbnNpdGlvbnMsIGN1cnJlbnRTbmFwc2hvdCwgYWN0b3JTY29wZSwgZXZlbnQsIGlzSW5pdGlhbCwgaW50ZXJuYWxRdWV1ZSkge1xuICBpZiAoIXRyYW5zaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBjdXJyZW50U25hcHNob3Q7XG4gIH1cbiAgY29uc3QgbXV0U3RhdGVOb2RlU2V0ID0gbmV3IFNldChjdXJyZW50U25hcHNob3QuX25vZGVzKTtcbiAgbGV0IGhpc3RvcnlWYWx1ZSA9IGN1cnJlbnRTbmFwc2hvdC5oaXN0b3J5VmFsdWU7XG4gIGNvbnN0IGZpbHRlcmVkVHJhbnNpdGlvbnMgPSByZW1vdmVDb25mbGljdGluZ1RyYW5zaXRpb25zKHRyYW5zaXRpb25zLCBtdXRTdGF0ZU5vZGVTZXQsIGhpc3RvcnlWYWx1ZSk7XG4gIGxldCBuZXh0U3RhdGUgPSBjdXJyZW50U25hcHNob3Q7XG5cbiAgLy8gRXhpdCBzdGF0ZXNcbiAgaWYgKCFpc0luaXRpYWwpIHtcbiAgICBbbmV4dFN0YXRlLCBoaXN0b3J5VmFsdWVdID0gZXhpdFN0YXRlcyhuZXh0U3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlLCBmaWx0ZXJlZFRyYW5zaXRpb25zLCBtdXRTdGF0ZU5vZGVTZXQsIGhpc3RvcnlWYWx1ZSwgaW50ZXJuYWxRdWV1ZSwgYWN0b3JTY29wZS5hY3Rpb25FeGVjdXRvcik7XG4gIH1cblxuICAvLyBFeGVjdXRlIHRyYW5zaXRpb24gY29udGVudFxuICBuZXh0U3RhdGUgPSByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQobmV4dFN0YXRlLCBldmVudCwgYWN0b3JTY29wZSwgZmlsdGVyZWRUcmFuc2l0aW9ucy5mbGF0TWFwKHQgPT4gdC5hY3Rpb25zKSwgaW50ZXJuYWxRdWV1ZSwgdW5kZWZpbmVkKTtcblxuICAvLyBFbnRlciBzdGF0ZXNcbiAgbmV4dFN0YXRlID0gZW50ZXJTdGF0ZXMobmV4dFN0YXRlLCBldmVudCwgYWN0b3JTY29wZSwgZmlsdGVyZWRUcmFuc2l0aW9ucywgbXV0U3RhdGVOb2RlU2V0LCBpbnRlcm5hbFF1ZXVlLCBoaXN0b3J5VmFsdWUsIGlzSW5pdGlhbCk7XG4gIGNvbnN0IG5leHRTdGF0ZU5vZGVzID0gWy4uLm11dFN0YXRlTm9kZVNldF07XG4gIGlmIChuZXh0U3RhdGUuc3RhdHVzID09PSAnZG9uZScpIHtcbiAgICBuZXh0U3RhdGUgPSByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQobmV4dFN0YXRlLCBldmVudCwgYWN0b3JTY29wZSwgbmV4dFN0YXRlTm9kZXMuc29ydCgoYSwgYikgPT4gYi5vcmRlciAtIGEub3JkZXIpLmZsYXRNYXAoc3RhdGUgPT4gc3RhdGUuZXhpdCksIGludGVybmFsUXVldWUsIHVuZGVmaW5lZCk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYXRjaFxuICB0cnkge1xuICAgIGlmIChoaXN0b3J5VmFsdWUgPT09IGN1cnJlbnRTbmFwc2hvdC5oaXN0b3J5VmFsdWUgJiYgYXJlU3RhdGVOb2RlQ29sbGVjdGlvbnNFcXVhbChjdXJyZW50U25hcHNob3QuX25vZGVzLCBtdXRTdGF0ZU5vZGVTZXQpKSB7XG4gICAgICByZXR1cm4gbmV4dFN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmVNYWNoaW5lU25hcHNob3QobmV4dFN0YXRlLCB7XG4gICAgICBfbm9kZXM6IG5leHRTdGF0ZU5vZGVzLFxuICAgICAgaGlzdG9yeVZhbHVlXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUT0RPOiBSZWZhY3RvciB0aGlzIG9uY2UgcHJvcGVyIGVycm9yIGhhbmRsaW5nIGlzIGltcGxlbWVudGVkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc3RhdGVseWFpL3JmY3MvcHVsbC80XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TWFjaGluZU91dHB1dChzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIHJvb3ROb2RlLCByb290Q29tcGxldGlvbk5vZGUpIHtcbiAgaWYgKHJvb3ROb2RlLm91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRvbmVTdGF0ZUV2ZW50ID0gY3JlYXRlRG9uZVN0YXRlRXZlbnQocm9vdENvbXBsZXRpb25Ob2RlLmlkLCByb290Q29tcGxldGlvbk5vZGUub3V0cHV0ICE9PSB1bmRlZmluZWQgJiYgcm9vdENvbXBsZXRpb25Ob2RlLnBhcmVudCA/IHJlc29sdmVPdXRwdXQocm9vdENvbXBsZXRpb25Ob2RlLm91dHB1dCwgc25hcHNob3QuY29udGV4dCwgZXZlbnQsIGFjdG9yU2NvcGUuc2VsZikgOiB1bmRlZmluZWQpO1xuICByZXR1cm4gcmVzb2x2ZU91dHB1dChyb290Tm9kZS5vdXRwdXQsIHNuYXBzaG90LmNvbnRleHQsIGRvbmVTdGF0ZUV2ZW50LCBhY3RvclNjb3BlLnNlbGYpO1xufVxuZnVuY3Rpb24gZW50ZXJTdGF0ZXMoY3VycmVudFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgZmlsdGVyZWRUcmFuc2l0aW9ucywgbXV0U3RhdGVOb2RlU2V0LCBpbnRlcm5hbFF1ZXVlLCBoaXN0b3J5VmFsdWUsIGlzSW5pdGlhbCkge1xuICBsZXQgbmV4dFNuYXBzaG90ID0gY3VycmVudFNuYXBzaG90O1xuICBjb25zdCBzdGF0ZXNUb0VudGVyID0gbmV3IFNldCgpO1xuICAvLyB0aG9zZSBhcmUgc3RhdGVzIHRoYXQgd2VyZSBkaXJlY3RseSB0YXJnZXRlZCBvciBpbmRpcmVjdGx5IHRhcmdldGVkIGJ5IHRoZSBleHBsaWNpdCB0YXJnZXRcbiAgLy8gaW4gb3RoZXIgd29yZHMsIHRob3NlIGFyZSBzdGF0ZXMgZm9yIHdoaWNoIGluaXRpYWwgYWN0aW9ucyBzaG91bGQgYmUgZXhlY3V0ZWRcbiAgLy8gd2hlbiB3ZSB0YXJnZXQgYCNkZWVwX2NoaWxkYCBpbml0aWFsIGFjdGlvbnMgb2YgaXRzIGFuY2VzdG9ycyBzaG91bGRuJ3QgYmUgZXhlY3V0ZWRcbiAgY29uc3Qgc3RhdGVzRm9yRGVmYXVsdEVudHJ5ID0gbmV3IFNldCgpO1xuICBjb21wdXRlRW50cnlTZXQoZmlsdGVyZWRUcmFuc2l0aW9ucywgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpO1xuXG4gIC8vIEluIHRoZSBpbml0aWFsIHN0YXRlLCB0aGUgcm9vdCBzdGF0ZSBub2RlIGlzIFwiZW50ZXJlZFwiLlxuICBpZiAoaXNJbml0aWFsKSB7XG4gICAgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LmFkZChjdXJyZW50U25hcHNob3QubWFjaGluZS5yb290KTtcbiAgfVxuICBjb25zdCBjb21wbGV0ZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBzdGF0ZU5vZGVUb0VudGVyIG9mIFsuLi5zdGF0ZXNUb0VudGVyXS5zb3J0KChhLCBiKSA9PiBhLm9yZGVyIC0gYi5vcmRlcikpIHtcbiAgICBtdXRTdGF0ZU5vZGVTZXQuYWRkKHN0YXRlTm9kZVRvRW50ZXIpO1xuICAgIGNvbnN0IGFjdGlvbnMgPSBbXTtcblxuICAgIC8vIEFkZCBlbnRyeSBhY3Rpb25zXG4gICAgYWN0aW9ucy5wdXNoKC4uLnN0YXRlTm9kZVRvRW50ZXIuZW50cnkpO1xuICAgIGZvciAoY29uc3QgaW52b2tlRGVmIG9mIHN0YXRlTm9kZVRvRW50ZXIuaW52b2tlKSB7XG4gICAgICBhY3Rpb25zLnB1c2goc3Bhd25DaGlsZChpbnZva2VEZWYuc3JjLCB7XG4gICAgICAgIC4uLmludm9rZURlZixcbiAgICAgICAgc3luY1NuYXBzaG90OiAhIWludm9rZURlZi5vblNuYXBzaG90XG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZXNGb3JEZWZhdWx0RW50cnkuaGFzKHN0YXRlTm9kZVRvRW50ZXIpKSB7XG4gICAgICBjb25zdCBpbml0aWFsQWN0aW9ucyA9IHN0YXRlTm9kZVRvRW50ZXIuaW5pdGlhbC5hY3Rpb25zO1xuICAgICAgYWN0aW9ucy5wdXNoKC4uLmluaXRpYWxBY3Rpb25zKTtcbiAgICB9XG4gICAgbmV4dFNuYXBzaG90ID0gcmVzb2x2ZUFjdGlvbnNBbmRDb250ZXh0KG5leHRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIGFjdGlvbnMsIGludGVybmFsUXVldWUsIHN0YXRlTm9kZVRvRW50ZXIuaW52b2tlLm1hcChpbnZva2VEZWYgPT4gaW52b2tlRGVmLmlkKSk7XG4gICAgaWYgKHN0YXRlTm9kZVRvRW50ZXIudHlwZSA9PT0gJ2ZpbmFsJykge1xuICAgICAgY29uc3QgcGFyZW50ID0gc3RhdGVOb2RlVG9FbnRlci5wYXJlbnQ7XG4gICAgICBsZXQgYW5jZXN0b3JNYXJrZXIgPSBwYXJlbnQ/LnR5cGUgPT09ICdwYXJhbGxlbCcgPyBwYXJlbnQgOiBwYXJlbnQ/LnBhcmVudDtcbiAgICAgIGxldCByb290Q29tcGxldGlvbk5vZGUgPSBhbmNlc3Rvck1hcmtlciB8fCBzdGF0ZU5vZGVUb0VudGVyO1xuICAgICAgaWYgKHBhcmVudD8udHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgICAgICBpbnRlcm5hbFF1ZXVlLnB1c2goY3JlYXRlRG9uZVN0YXRlRXZlbnQocGFyZW50LmlkLCBzdGF0ZU5vZGVUb0VudGVyLm91dHB1dCAhPT0gdW5kZWZpbmVkID8gcmVzb2x2ZU91dHB1dChzdGF0ZU5vZGVUb0VudGVyLm91dHB1dCwgbmV4dFNuYXBzaG90LmNvbnRleHQsIGV2ZW50LCBhY3RvclNjb3BlLnNlbGYpIDogdW5kZWZpbmVkKSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYW5jZXN0b3JNYXJrZXI/LnR5cGUgPT09ICdwYXJhbGxlbCcgJiYgIWNvbXBsZXRlZE5vZGVzLmhhcyhhbmNlc3Rvck1hcmtlcikgJiYgaXNJbkZpbmFsU3RhdGUobXV0U3RhdGVOb2RlU2V0LCBhbmNlc3Rvck1hcmtlcikpIHtcbiAgICAgICAgY29tcGxldGVkTm9kZXMuYWRkKGFuY2VzdG9yTWFya2VyKTtcbiAgICAgICAgaW50ZXJuYWxRdWV1ZS5wdXNoKGNyZWF0ZURvbmVTdGF0ZUV2ZW50KGFuY2VzdG9yTWFya2VyLmlkKSk7XG4gICAgICAgIHJvb3RDb21wbGV0aW9uTm9kZSA9IGFuY2VzdG9yTWFya2VyO1xuICAgICAgICBhbmNlc3Rvck1hcmtlciA9IGFuY2VzdG9yTWFya2VyLnBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmIChhbmNlc3Rvck1hcmtlcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG5leHRTbmFwc2hvdCA9IGNsb25lTWFjaGluZVNuYXBzaG90KG5leHRTbmFwc2hvdCwge1xuICAgICAgICBzdGF0dXM6ICdkb25lJyxcbiAgICAgICAgb3V0cHV0OiBnZXRNYWNoaW5lT3V0cHV0KG5leHRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIG5leHRTbmFwc2hvdC5tYWNoaW5lLnJvb3QsIHJvb3RDb21wbGV0aW9uTm9kZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV4dFNuYXBzaG90O1xufVxuZnVuY3Rpb24gY29tcHV0ZUVudHJ5U2V0KHRyYW5zaXRpb25zLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcikge1xuICBmb3IgKGNvbnN0IHQgb2YgdHJhbnNpdGlvbnMpIHtcbiAgICBjb25zdCBkb21haW4gPSBnZXRUcmFuc2l0aW9uRG9tYWluKHQsIGhpc3RvcnlWYWx1ZSk7XG4gICAgZm9yIChjb25zdCBzIG9mIHQudGFyZ2V0IHx8IFtdKSB7XG4gICAgICBpZiAoIWlzSGlzdG9yeU5vZGUocykgJiYgKFxuICAgICAgLy8gaWYgdGhlIHRhcmdldCBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgc291cmNlIHRoZW4gaXQgd2lsbCAqZGVmaW5pdGVseSogYmUgZW50ZXJlZFxuICAgICAgdC5zb3VyY2UgIT09IHMgfHxcbiAgICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgZG9tYWluIGNhbid0IGxpZSB3aXRoaW4gdGhlIHNvdXJjZVxuICAgICAgLy8gaWYgaXQncyBkaWZmZXJlbnQgdGhhbiB0aGUgc291cmNlIHRoZW4gaXQncyBvdXRzaWRlIG9mIGl0IGFuZCBpdCBtZWFucyB0aGF0IHRoZSB0YXJnZXQgaGFzIHRvIGJlIGVudGVyZWQgYXMgd2VsbFxuICAgICAgdC5zb3VyY2UgIT09IGRvbWFpbiB8fFxuICAgICAgLy8gcmVlbnRlcmluZyB0cmFuc2l0aW9ucyBhbHdheXMgZW50ZXIgdGhlIHRhcmdldCwgZXZlbiBpZiBpdCdzIHRoZSBzb3VyY2UgaXRzZWxmXG4gICAgICB0LnJlZW50ZXIpKSB7XG4gICAgICAgIHN0YXRlc1RvRW50ZXIuYWRkKHMpO1xuICAgICAgICBzdGF0ZXNGb3JEZWZhdWx0RW50cnkuYWRkKHMpO1xuICAgICAgfVxuICAgICAgYWRkRGVzY2VuZGFudFN0YXRlc1RvRW50ZXIocywgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRTdGF0ZXMgPSBnZXRFZmZlY3RpdmVUYXJnZXRTdGF0ZXModCwgaGlzdG9yeVZhbHVlKTtcbiAgICBmb3IgKGNvbnN0IHMgb2YgdGFyZ2V0U3RhdGVzKSB7XG4gICAgICBjb25zdCBhbmNlc3RvcnMgPSBnZXRQcm9wZXJBbmNlc3RvcnMocywgZG9tYWluKTtcbiAgICAgIGlmIChkb21haW4/LnR5cGUgPT09ICdwYXJhbGxlbCcpIHtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2goZG9tYWluKTtcbiAgICAgIH1cbiAgICAgIGFkZEFuY2VzdG9yU3RhdGVzVG9FbnRlcihzdGF0ZXNUb0VudGVyLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgYW5jZXN0b3JzLCAhdC5zb3VyY2UucGFyZW50ICYmIHQucmVlbnRlciA/IHVuZGVmaW5lZCA6IGRvbWFpbik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGREZXNjZW5kYW50U3RhdGVzVG9FbnRlcihzdGF0ZU5vZGUsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBzdGF0ZXNUb0VudGVyKSB7XG4gIGlmIChpc0hpc3RvcnlOb2RlKHN0YXRlTm9kZSkpIHtcbiAgICBpZiAoaGlzdG9yeVZhbHVlW3N0YXRlTm9kZS5pZF0pIHtcbiAgICAgIGNvbnN0IGhpc3RvcnlTdGF0ZU5vZGVzID0gaGlzdG9yeVZhbHVlW3N0YXRlTm9kZS5pZF07XG4gICAgICBmb3IgKGNvbnN0IHMgb2YgaGlzdG9yeVN0YXRlTm9kZXMpIHtcbiAgICAgICAgc3RhdGVzVG9FbnRlci5hZGQocyk7XG4gICAgICAgIGFkZERlc2NlbmRhbnRTdGF0ZXNUb0VudGVyKHMsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBzdGF0ZXNUb0VudGVyKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgcyBvZiBoaXN0b3J5U3RhdGVOb2Rlcykge1xuICAgICAgICBhZGRQcm9wZXJBbmNlc3RvclN0YXRlc1RvRW50ZXIocywgc3RhdGVOb2RlLnBhcmVudCwgc3RhdGVzVG9FbnRlciwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoaXN0b3J5RGVmYXVsdFRyYW5zaXRpb24gPSByZXNvbHZlSGlzdG9yeURlZmF1bHRUcmFuc2l0aW9uKHN0YXRlTm9kZSk7XG4gICAgICBmb3IgKGNvbnN0IHMgb2YgaGlzdG9yeURlZmF1bHRUcmFuc2l0aW9uLnRhcmdldCkge1xuICAgICAgICBzdGF0ZXNUb0VudGVyLmFkZChzKTtcbiAgICAgICAgaWYgKGhpc3RvcnlEZWZhdWx0VHJhbnNpdGlvbiA9PT0gc3RhdGVOb2RlLnBhcmVudD8uaW5pdGlhbCkge1xuICAgICAgICAgIHN0YXRlc0ZvckRlZmF1bHRFbnRyeS5hZGQoc3RhdGVOb2RlLnBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGVzY2VuZGFudFN0YXRlc1RvRW50ZXIocywgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBzIG9mIGhpc3RvcnlEZWZhdWx0VHJhbnNpdGlvbi50YXJnZXQpIHtcbiAgICAgICAgYWRkUHJvcGVyQW5jZXN0b3JTdGF0ZXNUb0VudGVyKHMsIHN0YXRlTm9kZS5wYXJlbnQsIHN0YXRlc1RvRW50ZXIsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHN0YXRlTm9kZS50eXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgICBjb25zdCBbaW5pdGlhbFN0YXRlXSA9IHN0YXRlTm9kZS5pbml0aWFsLnRhcmdldDtcbiAgICAgIGlmICghaXNIaXN0b3J5Tm9kZShpbml0aWFsU3RhdGUpKSB7XG4gICAgICAgIHN0YXRlc1RvRW50ZXIuYWRkKGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIHN0YXRlc0ZvckRlZmF1bHRFbnRyeS5hZGQoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGFkZERlc2NlbmRhbnRTdGF0ZXNUb0VudGVyKGluaXRpYWxTdGF0ZSwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpO1xuICAgICAgYWRkUHJvcGVyQW5jZXN0b3JTdGF0ZXNUb0VudGVyKGluaXRpYWxTdGF0ZSwgc3RhdGVOb2RlLCBzdGF0ZXNUb0VudGVyLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZU5vZGUudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGdldENoaWxkcmVuKHN0YXRlTm9kZSkuZmlsdGVyKHNuID0+ICFpc0hpc3RvcnlOb2RlKHNuKSkpIHtcbiAgICAgICAgICBpZiAoIVsuLi5zdGF0ZXNUb0VudGVyXS5zb21lKHMgPT4gaXNEZXNjZW5kYW50KHMsIGNoaWxkKSkpIHtcbiAgICAgICAgICAgIGlmICghaXNIaXN0b3J5Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgICAgICAgc3RhdGVzVG9FbnRlci5hZGQoY2hpbGQpO1xuICAgICAgICAgICAgICBzdGF0ZXNGb3JEZWZhdWx0RW50cnkuYWRkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZERlc2NlbmRhbnRTdGF0ZXNUb0VudGVyKGNoaWxkLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGRBbmNlc3RvclN0YXRlc1RvRW50ZXIoc3RhdGVzVG9FbnRlciwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIGFuY2VzdG9ycywgcmVlbnRyYW5jeURvbWFpbikge1xuICBmb3IgKGNvbnN0IGFuYyBvZiBhbmNlc3RvcnMpIHtcbiAgICBpZiAoIXJlZW50cmFuY3lEb21haW4gfHwgaXNEZXNjZW5kYW50KGFuYywgcmVlbnRyYW5jeURvbWFpbikpIHtcbiAgICAgIHN0YXRlc1RvRW50ZXIuYWRkKGFuYyk7XG4gICAgfVxuICAgIGlmIChhbmMudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBnZXRDaGlsZHJlbihhbmMpLmZpbHRlcihzbiA9PiAhaXNIaXN0b3J5Tm9kZShzbikpKSB7XG4gICAgICAgIGlmICghWy4uLnN0YXRlc1RvRW50ZXJdLnNvbWUocyA9PiBpc0Rlc2NlbmRhbnQocywgY2hpbGQpKSkge1xuICAgICAgICAgIHN0YXRlc1RvRW50ZXIuYWRkKGNoaWxkKTtcbiAgICAgICAgICBhZGREZXNjZW5kYW50U3RhdGVzVG9FbnRlcihjaGlsZCwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGRQcm9wZXJBbmNlc3RvclN0YXRlc1RvRW50ZXIoc3RhdGVOb2RlLCB0b1N0YXRlTm9kZSwgc3RhdGVzVG9FbnRlciwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnkpIHtcbiAgYWRkQW5jZXN0b3JTdGF0ZXNUb0VudGVyKHN0YXRlc1RvRW50ZXIsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBnZXRQcm9wZXJBbmNlc3RvcnMoc3RhdGVOb2RlLCB0b1N0YXRlTm9kZSkpO1xufVxuZnVuY3Rpb24gZXhpdFN0YXRlcyhjdXJyZW50U25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlLCB0cmFuc2l0aW9ucywgbXV0U3RhdGVOb2RlU2V0LCBoaXN0b3J5VmFsdWUsIGludGVybmFsUXVldWUsIF9hY3Rpb25FeGVjdXRvcikge1xuICBsZXQgbmV4dFNuYXBzaG90ID0gY3VycmVudFNuYXBzaG90O1xuICBjb25zdCBzdGF0ZXNUb0V4aXQgPSBjb21wdXRlRXhpdFNldCh0cmFuc2l0aW9ucywgbXV0U3RhdGVOb2RlU2V0LCBoaXN0b3J5VmFsdWUpO1xuICBzdGF0ZXNUb0V4aXQuc29ydCgoYSwgYikgPT4gYi5vcmRlciAtIGEub3JkZXIpO1xuICBsZXQgY2hhbmdlZEhpc3Rvcnk7XG5cbiAgLy8gRnJvbSBTQ1hNTCBhbGdvcml0aG06IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zY3htbC8jZXhpdFN0YXRlc1xuICBmb3IgKGNvbnN0IGV4aXRTdGF0ZU5vZGUgb2Ygc3RhdGVzVG9FeGl0KSB7XG4gICAgZm9yIChjb25zdCBoaXN0b3J5Tm9kZSBvZiBnZXRIaXN0b3J5Tm9kZXMoZXhpdFN0YXRlTm9kZSkpIHtcbiAgICAgIGxldCBwcmVkaWNhdGU7XG4gICAgICBpZiAoaGlzdG9yeU5vZGUuaGlzdG9yeSA9PT0gJ2RlZXAnKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHNuID0+IGlzQXRvbWljU3RhdGVOb2RlKHNuKSAmJiBpc0Rlc2NlbmRhbnQoc24sIGV4aXRTdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZGljYXRlID0gc24gPT4ge1xuICAgICAgICAgIHJldHVybiBzbi5wYXJlbnQgPT09IGV4aXRTdGF0ZU5vZGU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjaGFuZ2VkSGlzdG9yeSA/Pz0ge1xuICAgICAgICAuLi5oaXN0b3J5VmFsdWVcbiAgICAgIH07XG4gICAgICBjaGFuZ2VkSGlzdG9yeVtoaXN0b3J5Tm9kZS5pZF0gPSBBcnJheS5mcm9tKG11dFN0YXRlTm9kZVNldCkuZmlsdGVyKHByZWRpY2F0ZSk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgcyBvZiBzdGF0ZXNUb0V4aXQpIHtcbiAgICBuZXh0U25hcHNob3QgPSByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQobmV4dFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgWy4uLnMuZXhpdCwgLi4ucy5pbnZva2UubWFwKGRlZiA9PiBzdG9wQ2hpbGQoZGVmLmlkKSldLCBpbnRlcm5hbFF1ZXVlLCB1bmRlZmluZWQpO1xuICAgIG11dFN0YXRlTm9kZVNldC5kZWxldGUocyk7XG4gIH1cbiAgcmV0dXJuIFtuZXh0U25hcHNob3QsIGNoYW5nZWRIaXN0b3J5IHx8IGhpc3RvcnlWYWx1ZV07XG59XG5mdW5jdGlvbiBnZXRBY3Rpb24obWFjaGluZSwgYWN0aW9uVHlwZSkge1xuICByZXR1cm4gbWFjaGluZS5pbXBsZW1lbnRhdGlvbnMuYWN0aW9uc1thY3Rpb25UeXBlXTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVBbmRFeGVjdXRlQWN0aW9uc1dpdGhDb250ZXh0KGN1cnJlbnRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIGFjdGlvbnMsIGV4dHJhLCByZXRyaWVzKSB7XG4gIGNvbnN0IHtcbiAgICBtYWNoaW5lXG4gIH0gPSBjdXJyZW50U25hcHNob3Q7XG4gIGxldCBpbnRlcm1lZGlhdGVTbmFwc2hvdCA9IGN1cnJlbnRTbmFwc2hvdDtcbiAgZm9yIChjb25zdCBhY3Rpb24gb2YgYWN0aW9ucykge1xuICAgIGNvbnN0IGlzSW5saW5lID0gdHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJztcbiAgICBjb25zdCByZXNvbHZlZEFjdGlvbiA9IGlzSW5saW5lID8gYWN0aW9uIDpcbiAgICAvLyB0aGUgZXhpc3RpbmcgdHlwZSBvZiBgLmFjdGlvbnNgIGFzc3VtZXMgbm9uLW51bGxhYmxlIGBURXhwcmVzc2lvbkFjdGlvbmBcbiAgICAvLyBpdCdzIGZpbmUgdG8gY2FzdCB0aGlzIGhlcmUgdG8gZ2V0IGEgY29tbW9uIHR5cGUgYW5kIGxhY2sgb2YgZXJyb3JzIGluIHRoZSByZXN0IG9mIHRoZSBjb2RlXG4gICAgLy8gb3VyIGxvZ2ljIGJlbG93IG1ha2VzIHN1cmUgdGhhdCB3ZSBjYWxsIHRob3NlIDIgXCJ2YXJpYW50c1wiIGNvcnJlY3RseVxuXG4gICAgZ2V0QWN0aW9uKG1hY2hpbmUsIHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnID8gYWN0aW9uIDogYWN0aW9uLnR5cGUpO1xuICAgIGNvbnN0IGFjdGlvbkFyZ3MgPSB7XG4gICAgICBjb250ZXh0OiBpbnRlcm1lZGlhdGVTbmFwc2hvdC5jb250ZXh0LFxuICAgICAgZXZlbnQsXG4gICAgICBzZWxmOiBhY3RvclNjb3BlLnNlbGYsXG4gICAgICBzeXN0ZW06IGFjdG9yU2NvcGUuc3lzdGVtXG4gICAgfTtcbiAgICBjb25zdCBhY3Rpb25QYXJhbXMgPSBpc0lubGluZSB8fCB0eXBlb2YgYWN0aW9uID09PSAnc3RyaW5nJyA/IHVuZGVmaW5lZCA6ICdwYXJhbXMnIGluIGFjdGlvbiA/IHR5cGVvZiBhY3Rpb24ucGFyYW1zID09PSAnZnVuY3Rpb24nID8gYWN0aW9uLnBhcmFtcyh7XG4gICAgICBjb250ZXh0OiBpbnRlcm1lZGlhdGVTbmFwc2hvdC5jb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA6IGFjdGlvbi5wYXJhbXMgOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFyZXNvbHZlZEFjdGlvbiB8fCAhKCdyZXNvbHZlJyBpbiByZXNvbHZlZEFjdGlvbikpIHtcbiAgICAgIGFjdG9yU2NvcGUuYWN0aW9uRXhlY3V0b3Ioe1xuICAgICAgICB0eXBlOiB0eXBlb2YgYWN0aW9uID09PSAnc3RyaW5nJyA/IGFjdGlvbiA6IHR5cGVvZiBhY3Rpb24gPT09ICdvYmplY3QnID8gYWN0aW9uLnR5cGUgOiBhY3Rpb24ubmFtZSB8fCAnKGFub255bW91cyknLFxuICAgICAgICBpbmZvOiBhY3Rpb25BcmdzLFxuICAgICAgICBwYXJhbXM6IGFjdGlvblBhcmFtcyxcbiAgICAgICAgZXhlYzogcmVzb2x2ZWRBY3Rpb25cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGJ1aWx0aW5BY3Rpb24gPSByZXNvbHZlZEFjdGlvbjtcbiAgICBjb25zdCBbbmV4dFN0YXRlLCBwYXJhbXMsIGFjdGlvbnNdID0gYnVpbHRpbkFjdGlvbi5yZXNvbHZlKGFjdG9yU2NvcGUsIGludGVybWVkaWF0ZVNuYXBzaG90LCBhY3Rpb25BcmdzLCBhY3Rpb25QYXJhbXMsIHJlc29sdmVkQWN0aW9uLFxuICAgIC8vIHRoaXMgaG9sZHMgYWxsIHBhcmFtc1xuICAgIGV4dHJhKTtcbiAgICBpbnRlcm1lZGlhdGVTbmFwc2hvdCA9IG5leHRTdGF0ZTtcbiAgICBpZiAoJ3JldHJ5UmVzb2x2ZScgaW4gYnVpbHRpbkFjdGlvbikge1xuICAgICAgcmV0cmllcz8ucHVzaChbYnVpbHRpbkFjdGlvbiwgcGFyYW1zXSk7XG4gICAgfVxuICAgIGlmICgnZXhlY3V0ZScgaW4gYnVpbHRpbkFjdGlvbikge1xuICAgICAgYWN0b3JTY29wZS5hY3Rpb25FeGVjdXRvcih7XG4gICAgICAgIHR5cGU6IGJ1aWx0aW5BY3Rpb24udHlwZSxcbiAgICAgICAgaW5mbzogYWN0aW9uQXJncyxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBleGVjOiBidWlsdGluQWN0aW9uLmV4ZWN1dGUuYmluZChudWxsLCBhY3RvclNjb3BlLCBwYXJhbXMpXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGFjdGlvbnMpIHtcbiAgICAgIGludGVybWVkaWF0ZVNuYXBzaG90ID0gcmVzb2x2ZUFuZEV4ZWN1dGVBY3Rpb25zV2l0aENvbnRleHQoaW50ZXJtZWRpYXRlU25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlLCBhY3Rpb25zLCBleHRyYSwgcmV0cmllcyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbnRlcm1lZGlhdGVTbmFwc2hvdDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dChjdXJyZW50U25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlLCBhY3Rpb25zLCBpbnRlcm5hbFF1ZXVlLCBkZWZlcnJlZEFjdG9ySWRzKSB7XG4gIGNvbnN0IHJldHJpZXMgPSBkZWZlcnJlZEFjdG9ySWRzID8gW10gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IG5leHRTdGF0ZSA9IHJlc29sdmVBbmRFeGVjdXRlQWN0aW9uc1dpdGhDb250ZXh0KGN1cnJlbnRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIGFjdGlvbnMsIHtcbiAgICBpbnRlcm5hbFF1ZXVlLFxuICAgIGRlZmVycmVkQWN0b3JJZHNcbiAgfSwgcmV0cmllcyk7XG4gIHJldHJpZXM/LmZvckVhY2goKFtidWlsdGluQWN0aW9uLCBwYXJhbXNdKSA9PiB7XG4gICAgYnVpbHRpbkFjdGlvbi5yZXRyeVJlc29sdmUoYWN0b3JTY29wZSwgbmV4dFN0YXRlLCBwYXJhbXMpO1xuICB9KTtcbiAgcmV0dXJuIG5leHRTdGF0ZTtcbn1cbmZ1bmN0aW9uIG1hY3Jvc3RlcChzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIGludGVybmFsUXVldWUpIHtcbiAgaWYgKGV2ZW50LnR5cGUgPT09IFdJTERDQVJEKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBbiBldmVudCBjYW5ub3QgaGF2ZSB0aGUgd2lsZGNhcmQgdHlwZSAoJyR7V0lMRENBUkR9JylgKTtcbiAgfVxuICBsZXQgbmV4dFNuYXBzaG90ID0gc25hcHNob3Q7XG4gIGNvbnN0IG1pY3Jvc3RhdGVzID0gW107XG4gIGZ1bmN0aW9uIGFkZE1pY3Jvc3RhdGUobWljcm9zdGF0ZSwgZXZlbnQsIHRyYW5zaXRpb25zKSB7XG4gICAgYWN0b3JTY29wZS5zeXN0ZW0uX3NlbmRJbnNwZWN0aW9uRXZlbnQoe1xuICAgICAgdHlwZTogJ0B4c3RhdGUubWljcm9zdGVwJyxcbiAgICAgIGFjdG9yUmVmOiBhY3RvclNjb3BlLnNlbGYsXG4gICAgICBldmVudCxcbiAgICAgIHNuYXBzaG90OiBtaWNyb3N0YXRlLFxuICAgICAgX3RyYW5zaXRpb25zOiB0cmFuc2l0aW9uc1xuICAgIH0pO1xuICAgIG1pY3Jvc3RhdGVzLnB1c2gobWljcm9zdGF0ZSk7XG4gIH1cblxuICAvLyBIYW5kbGUgc3RvcCBldmVudFxuICBpZiAoZXZlbnQudHlwZSA9PT0gWFNUQVRFX1NUT1ApIHtcbiAgICBuZXh0U25hcHNob3QgPSBjbG9uZU1hY2hpbmVTbmFwc2hvdChzdG9wQ2hpbGRyZW4obmV4dFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSksIHtcbiAgICAgIHN0YXR1czogJ3N0b3BwZWQnXG4gICAgfSk7XG4gICAgYWRkTWljcm9zdGF0ZShuZXh0U25hcHNob3QsIGV2ZW50LCBbXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNuYXBzaG90OiBuZXh0U25hcHNob3QsXG4gICAgICBtaWNyb3N0YXRlc1xuICAgIH07XG4gIH1cbiAgbGV0IG5leHRFdmVudCA9IGV2ZW50O1xuXG4gIC8vIEFzc3VtZSB0aGUgc3RhdGUgaXMgYXQgcmVzdCAobm8gcmFpc2VkIGV2ZW50cylcbiAgLy8gRGV0ZXJtaW5lIHRoZSBuZXh0IHN0YXRlIGJhc2VkIG9uIHRoZSBuZXh0IG1pY3Jvc3RlcFxuICBpZiAobmV4dEV2ZW50LnR5cGUgIT09IFhTVEFURV9JTklUKSB7XG4gICAgY29uc3QgY3VycmVudEV2ZW50ID0gbmV4dEV2ZW50O1xuICAgIGNvbnN0IGlzRXJyID0gaXNFcnJvckFjdG9yRXZlbnQoY3VycmVudEV2ZW50KTtcbiAgICBjb25zdCB0cmFuc2l0aW9ucyA9IHNlbGVjdFRyYW5zaXRpb25zKGN1cnJlbnRFdmVudCwgbmV4dFNuYXBzaG90KTtcbiAgICBpZiAoaXNFcnIgJiYgIXRyYW5zaXRpb25zLmxlbmd0aCkge1xuICAgICAgLy8gVE9ETzogd2Ugc2hvdWxkIGxpa2VseSBvbmx5IGFsbG93IHRyYW5zaXRpb25zIHNlbGVjdGVkIGJ5IHZlcnkgZXhwbGljaXQgZGVzY3JpcHRvcnNcbiAgICAgIC8vIGAqYCBzaG91bGRuJ3QgYmUgbWF0Y2hlZCwgbGlrZWx5IGB4c3RhdGUuZXJyb3IuKmAgc2hvdWxkbid0IGJlIGVpdGhlclxuICAgICAgLy8gc2ltaWxhcmx5IGB4c3RhdGUuZXJyb3IuYWN0b3IuKmAgYW5kIGB4c3RhdGUuZXJyb3IuYWN0b3IudG9kby4qYCBoYXZlIHRvIGJlIGNvbnNpZGVyZWQgdG9vXG4gICAgICBuZXh0U25hcHNob3QgPSBjbG9uZU1hY2hpbmVTbmFwc2hvdChzbmFwc2hvdCwge1xuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIGVycm9yOiBjdXJyZW50RXZlbnQuZXJyb3JcbiAgICAgIH0pO1xuICAgICAgYWRkTWljcm9zdGF0ZShuZXh0U25hcHNob3QsIGN1cnJlbnRFdmVudCwgW10pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc25hcHNob3Q6IG5leHRTbmFwc2hvdCxcbiAgICAgICAgbWljcm9zdGF0ZXNcbiAgICAgIH07XG4gICAgfVxuICAgIG5leHRTbmFwc2hvdCA9IG1pY3Jvc3RlcCh0cmFuc2l0aW9ucywgc25hcHNob3QsIGFjdG9yU2NvcGUsIG5leHRFdmVudCwgZmFsc2UsXG4gICAgLy8gaXNJbml0aWFsXG4gICAgaW50ZXJuYWxRdWV1ZSk7XG4gICAgYWRkTWljcm9zdGF0ZShuZXh0U25hcHNob3QsIGN1cnJlbnRFdmVudCwgdHJhbnNpdGlvbnMpO1xuICB9XG4gIGxldCBzaG91bGRTZWxlY3RFdmVudGxlc3NUcmFuc2l0aW9ucyA9IHRydWU7XG4gIHdoaWxlIChuZXh0U25hcHNob3Quc3RhdHVzID09PSAnYWN0aXZlJykge1xuICAgIGxldCBlbmFibGVkVHJhbnNpdGlvbnMgPSBzaG91bGRTZWxlY3RFdmVudGxlc3NUcmFuc2l0aW9ucyA/IHNlbGVjdEV2ZW50bGVzc1RyYW5zaXRpb25zKG5leHRTbmFwc2hvdCwgbmV4dEV2ZW50KSA6IFtdO1xuXG4gICAgLy8gZXZlbnRsZXNzIHRyYW5zaXRpb25zIHNob3VsZCBhbHdheXMgYmUgc2VsZWN0ZWQgYWZ0ZXIgc2VsZWN0aW5nICpyZWd1bGFyKiB0cmFuc2l0aW9uc1xuICAgIC8vIGJ5IGFzc2lnbmluZyBgdW5kZWZpbmVkYCB0byBgcHJldmlvdXNTdGF0ZWAgd2UgZW5zdXJlIHRoYXQgYHNob3VsZFNlbGVjdEV2ZW50bGVzc1RyYW5zaXRpb25zYCBnZXRzIGFsd2F5cyBjb21wdXRlZCB0byB0cnVlIGluIHN1Y2ggYSBjYXNlXG4gICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IGVuYWJsZWRUcmFuc2l0aW9ucy5sZW5ndGggPyBuZXh0U25hcHNob3QgOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFlbmFibGVkVHJhbnNpdGlvbnMubGVuZ3RoKSB7XG4gICAgICBpZiAoIWludGVybmFsUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbmV4dEV2ZW50ID0gaW50ZXJuYWxRdWV1ZS5zaGlmdCgpO1xuICAgICAgZW5hYmxlZFRyYW5zaXRpb25zID0gc2VsZWN0VHJhbnNpdGlvbnMobmV4dEV2ZW50LCBuZXh0U25hcHNob3QpO1xuICAgIH1cbiAgICBuZXh0U25hcHNob3QgPSBtaWNyb3N0ZXAoZW5hYmxlZFRyYW5zaXRpb25zLCBuZXh0U25hcHNob3QsIGFjdG9yU2NvcGUsIG5leHRFdmVudCwgZmFsc2UsIGludGVybmFsUXVldWUpO1xuICAgIHNob3VsZFNlbGVjdEV2ZW50bGVzc1RyYW5zaXRpb25zID0gbmV4dFNuYXBzaG90ICE9PSBwcmV2aW91c1N0YXRlO1xuICAgIGFkZE1pY3Jvc3RhdGUobmV4dFNuYXBzaG90LCBuZXh0RXZlbnQsIGVuYWJsZWRUcmFuc2l0aW9ucyk7XG4gIH1cbiAgaWYgKG5leHRTbmFwc2hvdC5zdGF0dXMgIT09ICdhY3RpdmUnKSB7XG4gICAgc3RvcENoaWxkcmVuKG5leHRTbmFwc2hvdCwgbmV4dEV2ZW50LCBhY3RvclNjb3BlKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNuYXBzaG90OiBuZXh0U25hcHNob3QsXG4gICAgbWljcm9zdGF0ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHN0b3BDaGlsZHJlbihuZXh0U3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlKSB7XG4gIHJldHVybiByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQobmV4dFN0YXRlLCBldmVudCwgYWN0b3JTY29wZSwgT2JqZWN0LnZhbHVlcyhuZXh0U3RhdGUuY2hpbGRyZW4pLm1hcChjaGlsZCA9PiBzdG9wQ2hpbGQoY2hpbGQpKSwgW10sIHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBzZWxlY3RUcmFuc2l0aW9ucyhldmVudCwgbmV4dFN0YXRlKSB7XG4gIHJldHVybiBuZXh0U3RhdGUubWFjaGluZS5nZXRUcmFuc2l0aW9uRGF0YShuZXh0U3RhdGUsIGV2ZW50KTtcbn1cbmZ1bmN0aW9uIHNlbGVjdEV2ZW50bGVzc1RyYW5zaXRpb25zKG5leHRTdGF0ZSwgZXZlbnQpIHtcbiAgY29uc3QgZW5hYmxlZFRyYW5zaXRpb25TZXQgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGF0b21pY1N0YXRlcyA9IG5leHRTdGF0ZS5fbm9kZXMuZmlsdGVyKGlzQXRvbWljU3RhdGVOb2RlKTtcbiAgZm9yIChjb25zdCBzdGF0ZU5vZGUgb2YgYXRvbWljU3RhdGVzKSB7XG4gICAgbG9vcDogZm9yIChjb25zdCBzIG9mIFtzdGF0ZU5vZGVdLmNvbmNhdChnZXRQcm9wZXJBbmNlc3RvcnMoc3RhdGVOb2RlLCB1bmRlZmluZWQpKSkge1xuICAgICAgaWYgKCFzLmFsd2F5cykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgdHJhbnNpdGlvbiBvZiBzLmFsd2F5cykge1xuICAgICAgICBpZiAodHJhbnNpdGlvbi5ndWFyZCA9PT0gdW5kZWZpbmVkIHx8IGV2YWx1YXRlR3VhcmQodHJhbnNpdGlvbi5ndWFyZCwgbmV4dFN0YXRlLmNvbnRleHQsIGV2ZW50LCBuZXh0U3RhdGUpKSB7XG4gICAgICAgICAgZW5hYmxlZFRyYW5zaXRpb25TZXQuYWRkKHRyYW5zaXRpb24pO1xuICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbW92ZUNvbmZsaWN0aW5nVHJhbnNpdGlvbnMoQXJyYXkuZnJvbShlbmFibGVkVHJhbnNpdGlvblNldCksIG5ldyBTZXQobmV4dFN0YXRlLl9ub2RlcyksIG5leHRTdGF0ZS5oaXN0b3J5VmFsdWUpO1xufVxuXG4vKipcbiAqIFJlc29sdmVzIGEgcGFydGlhbCBzdGF0ZSB2YWx1ZSB3aXRoIGl0cyBmdWxsIHJlcHJlc2VudGF0aW9uIGluIHRoZSBzdGF0ZVxuICogbm9kZSdzIG1hY2hpbmUuXG4gKlxuICogQHBhcmFtIHN0YXRlVmFsdWUgVGhlIHBhcnRpYWwgc3RhdGUgdmFsdWUgdG8gcmVzb2x2ZS5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVN0YXRlVmFsdWUocm9vdE5vZGUsIHN0YXRlVmFsdWUpIHtcbiAgY29uc3QgYWxsU3RhdGVOb2RlcyA9IGdldEFsbFN0YXRlTm9kZXMoZ2V0U3RhdGVOb2Rlcyhyb290Tm9kZSwgc3RhdGVWYWx1ZSkpO1xuICByZXR1cm4gZ2V0U3RhdGVWYWx1ZShyb290Tm9kZSwgWy4uLmFsbFN0YXRlTm9kZXNdKTtcbn1cblxuZnVuY3Rpb24gaXNNYWNoaW5lU25hcHNob3QodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAnbWFjaGluZScgaW4gdmFsdWUgJiYgJ3ZhbHVlJyBpbiB2YWx1ZTtcbn1cbmNvbnN0IG1hY2hpbmVTbmFwc2hvdE1hdGNoZXMgPSBmdW5jdGlvbiBtYXRjaGVzKHRlc3RWYWx1ZSkge1xuICByZXR1cm4gbWF0Y2hlc1N0YXRlKHRlc3RWYWx1ZSwgdGhpcy52YWx1ZSk7XG59O1xuY29uc3QgbWFjaGluZVNuYXBzaG90SGFzVGFnID0gZnVuY3Rpb24gaGFzVGFnKHRhZykge1xuICByZXR1cm4gdGhpcy50YWdzLmhhcyh0YWcpO1xufTtcbmNvbnN0IG1hY2hpbmVTbmFwc2hvdENhbiA9IGZ1bmN0aW9uIGNhbihldmVudCkge1xuICBpZiAoIXRoaXMubWFjaGluZSkge1xuICAgIGNvbnNvbGUud2Fybihgc3RhdGUuY2FuKC4uLikgdXNlZCBvdXRzaWRlIG9mIGEgbWFjaGluZS1jcmVhdGVkIFN0YXRlIG9iamVjdDsgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gZmFsc2UuYCk7XG4gIH1cbiAgY29uc3QgdHJhbnNpdGlvbkRhdGEgPSB0aGlzLm1hY2hpbmUuZ2V0VHJhbnNpdGlvbkRhdGEodGhpcywgZXZlbnQpO1xuICByZXR1cm4gISF0cmFuc2l0aW9uRGF0YT8ubGVuZ3RoICYmXG4gIC8vIENoZWNrIHRoYXQgYXQgbGVhc3Qgb25lIHRyYW5zaXRpb24gaXMgbm90IGZvcmJpZGRlblxuICB0cmFuc2l0aW9uRGF0YS5zb21lKHQgPT4gdC50YXJnZXQgIT09IHVuZGVmaW5lZCB8fCB0LmFjdGlvbnMubGVuZ3RoKTtcbn07XG5jb25zdCBtYWNoaW5lU25hcHNob3RUb0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gIGNvbnN0IHtcbiAgICBfbm9kZXM6IG5vZGVzLFxuICAgIHRhZ3MsXG4gICAgbWFjaGluZSxcbiAgICBnZXRNZXRhLFxuICAgIHRvSlNPTixcbiAgICBjYW4sXG4gICAgaGFzVGFnLFxuICAgIG1hdGNoZXMsXG4gICAgLi4uanNvblZhbHVlc1xuICB9ID0gdGhpcztcbiAgcmV0dXJuIHtcbiAgICAuLi5qc29uVmFsdWVzLFxuICAgIHRhZ3M6IEFycmF5LmZyb20odGFncylcbiAgfTtcbn07XG5jb25zdCBtYWNoaW5lU25hcHNob3RHZXRNZXRhID0gZnVuY3Rpb24gZ2V0TWV0YSgpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGVzLnJlZHVjZSgoYWNjLCBzdGF0ZU5vZGUpID0+IHtcbiAgICBpZiAoc3RhdGVOb2RlLm1ldGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYWNjW3N0YXRlTm9kZS5pZF0gPSBzdGF0ZU5vZGUubWV0YTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZU1hY2hpbmVTbmFwc2hvdChjb25maWcsIG1hY2hpbmUpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXM6IGNvbmZpZy5zdGF0dXMsXG4gICAgb3V0cHV0OiBjb25maWcub3V0cHV0LFxuICAgIGVycm9yOiBjb25maWcuZXJyb3IsXG4gICAgbWFjaGluZSxcbiAgICBjb250ZXh0OiBjb25maWcuY29udGV4dCxcbiAgICBfbm9kZXM6IGNvbmZpZy5fbm9kZXMsXG4gICAgdmFsdWU6IGdldFN0YXRlVmFsdWUobWFjaGluZS5yb290LCBjb25maWcuX25vZGVzKSxcbiAgICB0YWdzOiBuZXcgU2V0KGNvbmZpZy5fbm9kZXMuZmxhdE1hcChzbiA9PiBzbi50YWdzKSksXG4gICAgY2hpbGRyZW46IGNvbmZpZy5jaGlsZHJlbixcbiAgICBoaXN0b3J5VmFsdWU6IGNvbmZpZy5oaXN0b3J5VmFsdWUgfHwge30sXG4gICAgbWF0Y2hlczogbWFjaGluZVNuYXBzaG90TWF0Y2hlcyxcbiAgICBoYXNUYWc6IG1hY2hpbmVTbmFwc2hvdEhhc1RhZyxcbiAgICBjYW46IG1hY2hpbmVTbmFwc2hvdENhbixcbiAgICBnZXRNZXRhOiBtYWNoaW5lU25hcHNob3RHZXRNZXRhLFxuICAgIHRvSlNPTjogbWFjaGluZVNuYXBzaG90VG9KU09OXG4gIH07XG59XG5mdW5jdGlvbiBjbG9uZU1hY2hpbmVTbmFwc2hvdChzbmFwc2hvdCwgY29uZmlnID0ge30pIHtcbiAgcmV0dXJuIGNyZWF0ZU1hY2hpbmVTbmFwc2hvdCh7XG4gICAgLi4uc25hcHNob3QsXG4gICAgLi4uY29uZmlnXG4gIH0sIHNuYXBzaG90Lm1hY2hpbmUpO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplSGlzdG9yeVZhbHVlKGhpc3RvcnlWYWx1ZSkge1xuICBpZiAodHlwZW9mIGhpc3RvcnlWYWx1ZSAhPT0gJ29iamVjdCcgfHwgaGlzdG9yeVZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBoaXN0b3J5VmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGhpc3RvcnlWYWx1ZVtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZS5tYXAoaXRlbSA9PiAoe1xuICAgICAgICBpZDogaXRlbS5pZFxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0UGVyc2lzdGVkU25hcHNob3Qoc25hcHNob3QsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIF9ub2Rlczogbm9kZXMsXG4gICAgdGFncyxcbiAgICBtYWNoaW5lLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbnRleHQsXG4gICAgY2FuLFxuICAgIGhhc1RhZyxcbiAgICBtYXRjaGVzLFxuICAgIGdldE1ldGEsXG4gICAgdG9KU09OLFxuICAgIC4uLmpzb25WYWx1ZXNcbiAgfSA9IHNuYXBzaG90O1xuICBjb25zdCBjaGlsZHJlbkpzb24gPSB7fTtcbiAgZm9yIChjb25zdCBpZCBpbiBjaGlsZHJlbikge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baWRdO1xuICAgIGlmICh0eXBlb2YgY2hpbGQuc3JjICE9PSAnc3RyaW5nJyAmJiAoIW9wdGlvbnMgfHwgISgnX191bnNhZmVBbGxvd0lubGluZUFjdG9ycycgaW4gb3B0aW9ucykpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIGlubGluZSBjaGlsZCBhY3RvciBjYW5ub3QgYmUgcGVyc2lzdGVkLicpO1xuICAgIH1cbiAgICBjaGlsZHJlbkpzb25baWRdID0ge1xuICAgICAgc25hcHNob3Q6IGNoaWxkLmdldFBlcnNpc3RlZFNuYXBzaG90KG9wdGlvbnMpLFxuICAgICAgc3JjOiBjaGlsZC5zcmMsXG4gICAgICBzeXN0ZW1JZDogY2hpbGQuc3lzdGVtSWQsXG4gICAgICBzeW5jU25hcHNob3Q6IGNoaWxkLl9zeW5jU25hcHNob3RcbiAgICB9O1xuICB9XG4gIGNvbnN0IHBlcnNpc3RlZCA9IHtcbiAgICAuLi5qc29uVmFsdWVzLFxuICAgIGNvbnRleHQ6IHBlcnNpc3RDb250ZXh0KGNvbnRleHQpLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbkpzb24sXG4gICAgaGlzdG9yeVZhbHVlOiBzZXJpYWxpemVIaXN0b3J5VmFsdWUoanNvblZhbHVlcy5oaXN0b3J5VmFsdWUpXG4gIH07XG4gIHJldHVybiBwZXJzaXN0ZWQ7XG59XG5mdW5jdGlvbiBwZXJzaXN0Q29udGV4dChjb250ZXh0UGFydCkge1xuICBsZXQgY29weTtcbiAgZm9yIChjb25zdCBrZXkgaW4gY29udGV4dFBhcnQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGNvbnRleHRQYXJ0W2tleV07XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICgnc2Vzc2lvbklkJyBpbiB2YWx1ZSAmJiAnc2VuZCcgaW4gdmFsdWUgJiYgJ3JlZicgaW4gdmFsdWUpIHtcbiAgICAgICAgY29weSA/Pz0gQXJyYXkuaXNBcnJheShjb250ZXh0UGFydCkgPyBjb250ZXh0UGFydC5zbGljZSgpIDoge1xuICAgICAgICAgIC4uLmNvbnRleHRQYXJ0XG4gICAgICAgIH07XG4gICAgICAgIGNvcHlba2V5XSA9IHtcbiAgICAgICAgICB4c3RhdGUkJHR5cGU6ICQkQUNUT1JfVFlQRSxcbiAgICAgICAgICBpZDogdmFsdWUuaWRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBlcnNpc3RDb250ZXh0KHZhbHVlKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBjb3B5ID8/PSBBcnJheS5pc0FycmF5KGNvbnRleHRQYXJ0KSA/IGNvbnRleHRQYXJ0LnNsaWNlKCkgOiB7XG4gICAgICAgICAgICAuLi5jb250ZXh0UGFydFxuICAgICAgICAgIH07XG4gICAgICAgICAgY29weVtrZXldID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3B5ID8/IGNvbnRleHRQYXJ0O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlUmFpc2UoXywgc25hcHNob3QsIGFyZ3MsIGFjdGlvblBhcmFtcywge1xuICBldmVudDogZXZlbnRPckV4cHIsXG4gIGlkLFxuICBkZWxheVxufSwge1xuICBpbnRlcm5hbFF1ZXVlXG59KSB7XG4gIGNvbnN0IGRlbGF5c01hcCA9IHNuYXBzaG90Lm1hY2hpbmUuaW1wbGVtZW50YXRpb25zLmRlbGF5cztcbiAgaWYgKHR5cGVvZiBldmVudE9yRXhwciA9PT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgIGBPbmx5IGV2ZW50IG9iamVjdHMgbWF5IGJlIHVzZWQgd2l0aCByYWlzZTsgdXNlIHJhaXNlKHsgdHlwZTogXCIke2V2ZW50T3JFeHByfVwiIH0pIGluc3RlYWRgKTtcbiAgfVxuICBjb25zdCByZXNvbHZlZEV2ZW50ID0gdHlwZW9mIGV2ZW50T3JFeHByID09PSAnZnVuY3Rpb24nID8gZXZlbnRPckV4cHIoYXJncywgYWN0aW9uUGFyYW1zKSA6IGV2ZW50T3JFeHByO1xuICBsZXQgcmVzb2x2ZWREZWxheTtcbiAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBjb25maWdEZWxheSA9IGRlbGF5c01hcCAmJiBkZWxheXNNYXBbZGVsYXldO1xuICAgIHJlc29sdmVkRGVsYXkgPSB0eXBlb2YgY29uZmlnRGVsYXkgPT09ICdmdW5jdGlvbicgPyBjb25maWdEZWxheShhcmdzLCBhY3Rpb25QYXJhbXMpIDogY29uZmlnRGVsYXk7XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZWREZWxheSA9IHR5cGVvZiBkZWxheSA9PT0gJ2Z1bmN0aW9uJyA/IGRlbGF5KGFyZ3MsIGFjdGlvblBhcmFtcykgOiBkZWxheTtcbiAgfVxuICBpZiAodHlwZW9mIHJlc29sdmVkRGVsYXkgIT09ICdudW1iZXInKSB7XG4gICAgaW50ZXJuYWxRdWV1ZS5wdXNoKHJlc29sdmVkRXZlbnQpO1xuICB9XG4gIHJldHVybiBbc25hcHNob3QsIHtcbiAgICBldmVudDogcmVzb2x2ZWRFdmVudCxcbiAgICBpZCxcbiAgICBkZWxheTogcmVzb2x2ZWREZWxheVxuICB9LCB1bmRlZmluZWRdO1xufVxuZnVuY3Rpb24gZXhlY3V0ZVJhaXNlKGFjdG9yU2NvcGUsIHBhcmFtcykge1xuICBjb25zdCB7XG4gICAgZXZlbnQsXG4gICAgZGVsYXksXG4gICAgaWRcbiAgfSA9IHBhcmFtcztcbiAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICBhY3RvclNjb3BlLmRlZmVyKCgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGYgPSBhY3RvclNjb3BlLnNlbGY7XG4gICAgICBhY3RvclNjb3BlLnN5c3RlbS5zY2hlZHVsZXIuc2NoZWR1bGUoc2VsZiwgc2VsZiwgZXZlbnQsIGRlbGF5LCBpZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG59XG4vKipcbiAqIFJhaXNlcyBhbiBldmVudC4gVGhpcyBwbGFjZXMgdGhlIGV2ZW50IGluIHRoZSBpbnRlcm5hbCBldmVudCBxdWV1ZSwgc28gdGhhdFxuICogdGhlIGV2ZW50IGlzIGltbWVkaWF0ZWx5IGNvbnN1bWVkIGJ5IHRoZSBtYWNoaW5lIGluIHRoZSBjdXJyZW50IHN0ZXAuXG4gKlxuICogQHBhcmFtIGV2ZW50VHlwZSBUaGUgZXZlbnQgdG8gcmFpc2UuXG4gKi9cbmZ1bmN0aW9uIHJhaXNlKGV2ZW50T3JFeHByLCBvcHRpb25zKSB7XG4gIGlmIChleGVjdXRpbmdDdXN0b21BY3Rpb24pIHtcbiAgICBjb25zb2xlLndhcm4oJ0N1c3RvbSBhY3Rpb25zIHNob3VsZCBub3QgY2FsbCBgcmFpc2UoKWAgZGlyZWN0bHksIGFzIGl0IGlzIG5vdCBpbXBlcmF0aXZlLiBTZWUgaHR0cHM6Ly9zdGF0ZWx5LmFpL2RvY3MvYWN0aW9ucyNidWlsdC1pbi1hY3Rpb25zIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gIH1cbiAgZnVuY3Rpb24gcmFpc2UoX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIHJhaXNlLnR5cGUgPSAneHN0YXRlLnJhaXNlJztcbiAgcmFpc2UuZXZlbnQgPSBldmVudE9yRXhwcjtcbiAgcmFpc2UuaWQgPSBvcHRpb25zPy5pZDtcbiAgcmFpc2UuZGVsYXkgPSBvcHRpb25zPy5kZWxheTtcbiAgcmFpc2UucmVzb2x2ZSA9IHJlc29sdmVSYWlzZTtcbiAgcmFpc2UuZXhlY3V0ZSA9IGV4ZWN1dGVSYWlzZTtcbiAgcmV0dXJuIHJhaXNlO1xufVxuXG5leHBvcnQgeyAkJEFDVE9SX1RZUEUgYXMgJCwgQWN0b3IgYXMgQSwgZm9ybWF0SW5pdGlhbFRyYW5zaXRpb24gYXMgQiwgZ2V0Q2FuZGlkYXRlcyBhcyBDLCByZXNvbHZlU3RhdGVWYWx1ZSBhcyBELCBnZXRBbGxTdGF0ZU5vZGVzIGFzIEUsIGNyZWF0ZU1hY2hpbmVTbmFwc2hvdCBhcyBGLCBpc0luRmluYWxTdGF0ZSBhcyBHLCBtYWNyb3N0ZXAgYXMgSCwgdHJhbnNpdGlvbk5vZGUgYXMgSSwgcmVzb2x2ZUFjdGlvbnNBbmRDb250ZXh0IGFzIEosIGNyZWF0ZUluaXRFdmVudCBhcyBLLCBtaWNyb3N0ZXAgYXMgTCwgZ2V0SW5pdGlhbFN0YXRlTm9kZXMgYXMgTSwgTlVMTF9FVkVOVCBhcyBOLCB0b1N0YXRlUGF0aCBhcyBPLCBpc1N0YXRlSWQgYXMgUCwgZ2V0U3RhdGVOb2RlQnlQYXRoIGFzIFEsIGdldFBlcnNpc3RlZFNuYXBzaG90IGFzIFIsIFNUQVRFX0RFTElNSVRFUiBhcyBTLCByZXNvbHZlUmVmZXJlbmNlZEFjdG9yIGFzIFQsIGV4ZWN1dGluZ0N1c3RvbUFjdGlvbiBhcyBVLCBYU1RBVEVfRVJST1IgYXMgViwgY3JlYXRlRXJyb3JBY3RvckV2ZW50IGFzIFcsIFhTVEFURV9TVE9QIGFzIFgsIFByb2Nlc3NpbmdTdGF0dXMgYXMgWSwgY2xvbmVNYWNoaW5lU25hcHNob3QgYXMgWiwgY2FuY2VsIGFzIGEsIHNwYXduQ2hpbGQgYXMgYiwgY3JlYXRlQWN0b3IgYXMgYywgYW5kIGFzIGQsIHN0YXRlSW4gYXMgZSwgaXNNYWNoaW5lU25hcHNob3QgYXMgZiwgZ2V0U3RhdGVOb2RlcyBhcyBnLCBnZXRBbGxPd25FdmVudERlc2NyaXB0b3JzIGFzIGgsIGludGVycHJldCBhcyBpLCBtYXRjaGVzU3RhdGUgYXMgaiwgdG9PYnNlcnZlciBhcyBrLCBzdG9wIGFzIGwsIG1hdGNoZXNFdmVudERlc2NyaXB0b3IgYXMgbSwgbm90IGFzIG4sIG9yIGFzIG8sIHBhdGhUb1N0YXRlVmFsdWUgYXMgcCwgbWFwVmFsdWVzIGFzIHEsIHJhaXNlIGFzIHIsIHN0b3BDaGlsZCBhcyBzLCB0b0FycmF5IGFzIHQsIGZvcm1hdFRyYW5zaXRpb25zIGFzIHUsIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5IGFzIHYsIGZvcm1hdFRyYW5zaXRpb24gYXMgdywgZXZhbHVhdGVHdWFyZCBhcyB4LCBjcmVhdGVJbnZva2VJZCBhcyB5LCBnZXREZWxheWVkVHJhbnNpdGlvbnMgYXMgeiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/raise-235fa0c7.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/xstate.development.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/xstate/dist/xstate.development.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Actor: () => (/* reexport safe */ _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.A),\n/* harmony export */   SimulatedClock: () => (/* binding */ SimulatedClock),\n/* harmony export */   SpecialTargets: () => (/* reexport safe */ _log_3eec9346_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.S),\n/* harmony export */   StateMachine: () => (/* reexport safe */ _StateMachine_53479528_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.S),\n/* harmony export */   StateNode: () => (/* reexport safe */ _StateMachine_53479528_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.a),\n/* harmony export */   __unsafe_getAllOwnEventDescriptors: () => (/* reexport safe */ _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.h),\n/* harmony export */   and: () => (/* reexport safe */ _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.d),\n/* harmony export */   assertEvent: () => (/* binding */ assertEvent),\n/* harmony export */   assign: () => (/* reexport safe */ _assign_ef1b62f6_development_esm_js__WEBPACK_IMPORTED_MODULE_3__.a),\n/* harmony export */   cancel: () => (/* reexport safe */ _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.a),\n/* harmony export */   createActor: () => (/* reexport safe */ _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.c),\n/* harmony export */   createEmptyActor: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.createEmptyActor),\n/* harmony export */   createMachine: () => (/* binding */ createMachine),\n/* harmony export */   emit: () => (/* reexport safe */ _log_3eec9346_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.a),\n/* harmony export */   enqueueActions: () => (/* reexport safe */ _log_3eec9346_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.e),\n/* harmony export */   forwardTo: () => (/* reexport safe */ _log_3eec9346_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.f),\n/* harmony export */   fromCallback: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromCallback),\n/* harmony export */   fromEventObservable: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromEventObservable),\n/* harmony export */   fromObservable: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromObservable),\n/* harmony export */   fromPromise: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromPromise),\n/* harmony export */   fromTransition: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromTransition),\n/* harmony export */   getInitialSnapshot: () => (/* binding */ getInitialSnapshot),\n/* harmony export */   getNextSnapshot: () => (/* binding */ getNextSnapshot),\n/* harmony export */   getStateNodes: () => (/* reexport safe */ _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.g),\n/* harmony export */   initialTransition: () => (/* binding */ initialTransition),\n/* harmony export */   interpret: () => (/* reexport safe */ _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.i),\n/* harmony export */   isMachineSnapshot: () => (/* reexport safe */ _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.f),\n/* harmony export */   log: () => (/* reexport safe */ _log_3eec9346_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.l),\n/* harmony export */   matchesState: () => (/* reexport safe */ _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.j),\n/* harmony export */   not: () => (/* reexport safe */ _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.n),\n/* harmony export */   or: () => (/* reexport safe */ _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.o),\n/* harmony export */   pathToStateValue: () => (/* reexport safe */ _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.p),\n/* harmony export */   raise: () => (/* reexport safe */ _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.r),\n/* harmony export */   sendParent: () => (/* reexport safe */ _log_3eec9346_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.b),\n/* harmony export */   sendTo: () => (/* reexport safe */ _log_3eec9346_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.s),\n/* harmony export */   setup: () => (/* binding */ setup),\n/* harmony export */   spawnChild: () => (/* reexport safe */ _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.b),\n/* harmony export */   stateIn: () => (/* reexport safe */ _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.e),\n/* harmony export */   stop: () => (/* reexport safe */ _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.l),\n/* harmony export */   stopChild: () => (/* reexport safe */ _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.s),\n/* harmony export */   toObserver: () => (/* reexport safe */ _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.k),\n/* harmony export */   toPromise: () => (/* binding */ toPromise),\n/* harmony export */   transition: () => (/* binding */ transition),\n/* harmony export */   waitFor: () => (/* binding */ waitFor)\n/* harmony export */ });\n/* harmony import */ var _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../actors/dist/xstate-actors.development.esm.js */ \"(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\");\n/* harmony import */ var _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./raise-235fa0c7.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-235fa0c7.development.esm.js\");\n/* harmony import */ var _StateMachine_53479528_development_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StateMachine-53479528.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/StateMachine-53479528.development.esm.js\");\n/* harmony import */ var _assign_ef1b62f6_development_esm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./assign-ef1b62f6.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/assign-ef1b62f6.development.esm.js\");\n/* harmony import */ var _log_3eec9346_development_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./log-3eec9346.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/log-3eec9346.development.esm.js\");\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dev/dist/xstate-dev.development.esm.js */ \"(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Asserts that the given event object is of the specified type or types. Throws\n * an error if the event object is not of the specified types.\n *\n * @example\n *\n * ```ts\n * // ...\n * entry: ({ event }) => {\n *   assertEvent(event, 'doNothing');\n *   // event is { type: 'doNothing' }\n * },\n * // ...\n * exit: ({ event }) => {\n *   assertEvent(event, 'greet');\n *   // event is { type: 'greet'; message: string }\n *\n *   assertEvent(event, ['greet', 'notify']);\n *   // event is { type: 'greet'; message: string }\n *   // or { type: 'notify'; message: string; level: 'info' | 'error' }\n * },\n * ```\n */\nfunction assertEvent(event, type) {\n  const types = (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(type);\n  const matches = types.some(descriptor => (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.m)(event.type, descriptor));\n  if (!matches) {\n    const typesText = types.length === 1 ? `type matching \"${types[0]}\"` : `one of types matching \"${types.join('\", \"')}\"`;\n    throw new Error(`Expected event ${JSON.stringify(event)} to have ${typesText}`);\n  }\n}\n\n/**\n * Creates a state machine (statechart) with the given configuration.\n *\n * The state machine represents the pure logic of a state machine actor.\n *\n * @example\n *\n * ```ts\n * import { createMachine } from 'xstate';\n *\n * const lightMachine = createMachine({\n *   id: 'light',\n *   initial: 'green',\n *   states: {\n *     green: {\n *       on: {\n *         TIMER: { target: 'yellow' }\n *       }\n *     },\n *     yellow: {\n *       on: {\n *         TIMER: { target: 'red' }\n *       }\n *     },\n *     red: {\n *       on: {\n *         TIMER: { target: 'green' }\n *       }\n *     }\n *   }\n * });\n *\n * const lightActor = createActor(lightMachine);\n * lightActor.start();\n *\n * lightActor.send({ type: 'TIMER' });\n * ```\n *\n * @param config The state machine configuration.\n * @param options DEPRECATED: use `setup({ ... })` or `machine.provide({ ... })`\n *   to provide machine implementations instead.\n */\nfunction createMachine(config, implementations) {\n  return new _StateMachine_53479528_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.S(config, implementations);\n}\n\n/** @internal */\nfunction createInertActorScope(actorLogic) {\n  const self = (0,_raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(actorLogic);\n  const inertActorScope = {\n    self,\n    defer: () => {},\n    id: '',\n    logger: () => {},\n    sessionId: '',\n    stopChild: () => {},\n    system: self.system,\n    emit: () => {},\n    actionExecutor: () => {}\n  };\n  return inertActorScope;\n}\n\n/** @deprecated Use `initialTransition(…)` instead. */\nfunction getInitialSnapshot(actorLogic, ...[input]) {\n  const actorScope = createInertActorScope(actorLogic);\n  return actorLogic.getInitialSnapshot(actorScope, input);\n}\n\n/**\n * Determines the next snapshot for the given `actorLogic` based on the given\n * `snapshot` and `event`.\n *\n * If the `snapshot` is `undefined`, the initial snapshot of the `actorLogic` is\n * used.\n *\n * @deprecated Use `transition(…)` instead.\n * @example\n *\n * ```ts\n * import { getNextSnapshot } from 'xstate';\n * import { trafficLightMachine } from './trafficLightMachine.ts';\n *\n * const nextSnapshot = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   undefined, // snapshot (or initial state if undefined)\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot.value);\n * // => 'yellow'\n *\n * const nextSnapshot2 = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   nextSnapshot, // snapshot\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot2.value);\n * // =>'red'\n * ```\n */\nfunction getNextSnapshot(actorLogic, snapshot, event) {\n  const inertActorScope = createInertActorScope(actorLogic);\n  inertActorScope.self._snapshot = snapshot;\n  return actorLogic.transition(snapshot, event, inertActorScope);\n}\n\n// at the moment we allow extra actors - ones that are not specified by `children`\n// this could be reconsidered in the future\n\n// used to keep only StateSchema relevant keys\n// this helps with type serialization as it makes the inferred type much shorter when dealing with huge configs\n\nfunction setup({\n  schemas,\n  actors,\n  actions,\n  guards,\n  delays\n}) {\n  return {\n    assign: _assign_ef1b62f6_development_esm_js__WEBPACK_IMPORTED_MODULE_3__.a,\n    sendTo: _log_3eec9346_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.s,\n    raise: _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.r,\n    log: _log_3eec9346_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.l,\n    cancel: _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.a,\n    stopChild: _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.s,\n    enqueueActions: _log_3eec9346_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.e,\n    emit: _log_3eec9346_development_esm_js__WEBPACK_IMPORTED_MODULE_4__.a,\n    spawnChild: _raise_235fa0c7_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.b,\n    createStateConfig: config => config,\n    createAction: fn => fn,\n    createMachine: config => createMachine({\n      ...config,\n      schemas\n    }, {\n      actors,\n      actions,\n      guards,\n      delays\n    }),\n    extend: extended => setup({\n      schemas,\n      actors,\n      actions: {\n        ...actions,\n        ...extended.actions\n      },\n      guards: {\n        ...guards,\n        ...extended.guards\n      },\n      delays: {\n        ...delays,\n        ...extended.delays\n      }\n    })\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass SimulatedClock {\n  constructor() {\n    this.timeouts = new Map();\n    this._now = 0;\n    this._id = 0;\n    this._flushing = false;\n    this._flushingInvalidated = false;\n  }\n  now() {\n    return this._now;\n  }\n  getId() {\n    return this._id++;\n  }\n  setTimeout(fn, timeout) {\n    this._flushingInvalidated = this._flushing;\n    const id = this.getId();\n    this.timeouts.set(id, {\n      start: this.now(),\n      timeout,\n      fn\n    });\n    return id;\n  }\n  clearTimeout(id) {\n    this._flushingInvalidated = this._flushing;\n    this.timeouts.delete(id);\n  }\n  set(time) {\n    if (this._now > time) {\n      throw new Error('Unable to travel back in time');\n    }\n    this._now = time;\n    this.flushTimeouts();\n  }\n  flushTimeouts() {\n    if (this._flushing) {\n      this._flushingInvalidated = true;\n      return;\n    }\n    this._flushing = true;\n    const sorted = [...this.timeouts].sort(([_idA, timeoutA], [_idB, timeoutB]) => {\n      const endA = timeoutA.start + timeoutA.timeout;\n      const endB = timeoutB.start + timeoutB.timeout;\n      return endB > endA ? -1 : 1;\n    });\n    for (const [id, timeout] of sorted) {\n      if (this._flushingInvalidated) {\n        this._flushingInvalidated = false;\n        this._flushing = false;\n        this.flushTimeouts();\n        return;\n      }\n      if (this.now() - timeout.start >= timeout.timeout) {\n        this.timeouts.delete(id);\n        timeout.fn.call(null);\n      }\n    }\n    this._flushing = false;\n  }\n  increment(ms) {\n    this._now += ms;\n    this.flushTimeouts();\n  }\n}\n\n/**\n * Returns a promise that resolves to the `output` of the actor when it is done.\n *\n * @example\n *\n * ```ts\n * const machine = createMachine({\n *   // ...\n *   output: {\n *     count: 42\n *   }\n * });\n *\n * const actor = createActor(machine);\n *\n * actor.start();\n *\n * const output = await toPromise(actor);\n *\n * console.log(output);\n * // logs { count: 42 }\n * ```\n */\nfunction toPromise(actor) {\n  return new Promise((resolve, reject) => {\n    actor.subscribe({\n      complete: () => {\n        resolve(actor.getSnapshot().output);\n      },\n      error: reject\n    });\n  });\n}\n\n/**\n * Given actor `logic`, a `snapshot`, and an `event`, returns a tuple of the\n * `nextSnapshot` and `actions` to execute.\n *\n * This is a pure function that does not execute `actions`.\n */\nfunction transition(logic, snapshot, event) {\n  const executableActions = [];\n  const actorScope = createInertActorScope(logic);\n  actorScope.actionExecutor = action => {\n    executableActions.push(action);\n  };\n  const nextSnapshot = logic.transition(snapshot, event, actorScope);\n  return [nextSnapshot, executableActions];\n}\n\n/**\n * Given actor `logic` and optional `input`, returns a tuple of the\n * `nextSnapshot` and `actions` to execute from the initial transition (no\n * previous state).\n *\n * This is a pure function that does not execute `actions`.\n */\nfunction initialTransition(logic, ...[input]) {\n  const executableActions = [];\n  const actorScope = createInertActorScope(logic);\n  actorScope.actionExecutor = action => {\n    executableActions.push(action);\n  };\n  const nextSnapshot = logic.getInitialSnapshot(actorScope, input);\n  return [nextSnapshot, executableActions];\n}\n\nconst defaultWaitForOptions = {\n  timeout: Infinity // much more than 10 seconds\n};\n\n/**\n * Subscribes to an actor ref and waits for its emitted value to satisfy a\n * predicate, and then resolves with that value. Will throw if the desired state\n * is not reached after an optional timeout. (defaults to Infinity).\n *\n * @example\n *\n * ```js\n * const state = await waitFor(someService, (state) => {\n *   return state.hasTag('loaded');\n * });\n *\n * state.hasTag('loaded'); // true\n * ```\n *\n * @param actorRef The actor ref to subscribe to\n * @param predicate Determines if a value matches the condition to wait for\n * @param options\n * @returns A promise that eventually resolves to the emitted value that matches\n *   the condition\n */\nfunction waitFor(actorRef, predicate, options) {\n  const resolvedOptions = {\n    ...defaultWaitForOptions,\n    ...options\n  };\n  return new Promise((res, rej) => {\n    const {\n      signal\n    } = resolvedOptions;\n    if (signal?.aborted) {\n      // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n      rej(signal.reason);\n      return;\n    }\n    let done = false;\n    if (resolvedOptions.timeout < 0) {\n      console.error('`timeout` passed to `waitFor` is negative and it will reject its internal promise immediately.');\n    }\n    const handle = resolvedOptions.timeout === Infinity ? undefined : setTimeout(() => {\n      dispose();\n      rej(new Error(`Timeout of ${resolvedOptions.timeout} ms exceeded`));\n    }, resolvedOptions.timeout);\n    const dispose = () => {\n      clearTimeout(handle);\n      done = true;\n      sub?.unsubscribe();\n      if (abortListener) {\n        signal.removeEventListener('abort', abortListener);\n      }\n    };\n    function checkEmitted(emitted) {\n      if (predicate(emitted)) {\n        dispose();\n        res(emitted);\n      }\n    }\n\n    /**\n     * If the `signal` option is provided, this will be the listener for its\n     * `abort` event\n     */\n    let abortListener;\n    // eslint-disable-next-line prefer-const\n    let sub; // avoid TDZ when disposing synchronously\n\n    // See if the current snapshot already matches the predicate\n    checkEmitted(actorRef.getSnapshot());\n    if (done) {\n      return;\n    }\n\n    // only define the `abortListener` if the `signal` option is provided\n    if (signal) {\n      abortListener = () => {\n        dispose();\n        // XState does not \"own\" the signal, so we should reject with its reason (if any)\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        rej(signal.reason);\n      };\n      signal.addEventListener('abort', abortListener);\n    }\n    sub = actorRef.subscribe({\n      next: checkEmitted,\n      error: err => {\n        dispose();\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        rej(err);\n      },\n      complete: () => {\n        dispose();\n        rej(new Error(`Actor terminated without satisfying predicate`));\n      }\n    });\n    if (done) {\n      sub.unsubscribe();\n    }\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QveHN0YXRlLmRldmVsb3BtZW50LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtSztBQUNTO0FBQ3VMO0FBQ3BSO0FBQ2dCO0FBQzVCO0FBQ0E7QUFDdUM7QUFDc0Q7QUFDN0c7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxtQkFBbUI7QUFDbkIsSUFBSTtBQUNKO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLGFBQWEsZ0JBQWdCLGlCQUFpQjtBQUM5QyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFFQUFPO0FBQ3ZCLDJDQUEyQyxxRUFBc0I7QUFDakU7QUFDQSw2REFBNkQsU0FBUywrQkFBK0IsbUJBQW1CO0FBQ3hILHNDQUFzQyx1QkFBdUIsVUFBVSxVQUFVO0FBQ2pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsS0FBSyx5QkFBeUIsS0FBSztBQUM5RTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdFQUFZO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHFFQUFXO0FBQzFCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUIsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsVUFBVTtBQUNWLFVBQVU7QUFDVixTQUFTO0FBQ1QsT0FBTztBQUNQLFVBQVU7QUFDVixhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLFFBQVE7QUFDUixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFcUoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmlzcC1jbGVhbmluZy8uL25vZGVfbW9kdWxlcy94c3RhdGUvZGlzdC94c3RhdGUuZGV2ZWxvcG1lbnQuZXNtLmpzP2I0YjkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgY3JlYXRlRW1wdHlBY3RvciwgZnJvbUNhbGxiYWNrLCBmcm9tRXZlbnRPYnNlcnZhYmxlLCBmcm9tT2JzZXJ2YWJsZSwgZnJvbVByb21pc2UsIGZyb21UcmFuc2l0aW9uIH0gZnJvbSAnLi4vYWN0b3JzL2Rpc3QveHN0YXRlLWFjdG9ycy5kZXZlbG9wbWVudC5lc20uanMnO1xuaW1wb3J0IHsgbSBhcyBtYXRjaGVzRXZlbnREZXNjcmlwdG9yLCB0IGFzIHRvQXJyYXksIGMgYXMgY3JlYXRlQWN0b3IsIHIgYXMgcmFpc2UsIGEgYXMgY2FuY2VsLCBzIGFzIHN0b3BDaGlsZCwgYiBhcyBzcGF3bkNoaWxkIH0gZnJvbSAnLi9yYWlzZS0yMzVmYTBjNy5kZXZlbG9wbWVudC5lc20uanMnO1xuZXhwb3J0IHsgQSBhcyBBY3RvciwgaCBhcyBfX3Vuc2FmZV9nZXRBbGxPd25FdmVudERlc2NyaXB0b3JzLCBkIGFzIGFuZCwgYSBhcyBjYW5jZWwsIGMgYXMgY3JlYXRlQWN0b3IsIGcgYXMgZ2V0U3RhdGVOb2RlcywgaSBhcyBpbnRlcnByZXQsIGYgYXMgaXNNYWNoaW5lU25hcHNob3QsIGogYXMgbWF0Y2hlc1N0YXRlLCBuIGFzIG5vdCwgbyBhcyBvciwgcCBhcyBwYXRoVG9TdGF0ZVZhbHVlLCByIGFzIHJhaXNlLCBiIGFzIHNwYXduQ2hpbGQsIGUgYXMgc3RhdGVJbiwgbCBhcyBzdG9wLCBzIGFzIHN0b3BDaGlsZCwgayBhcyB0b09ic2VydmVyIH0gZnJvbSAnLi9yYWlzZS0yMzVmYTBjNy5kZXZlbG9wbWVudC5lc20uanMnO1xuaW1wb3J0IHsgUyBhcyBTdGF0ZU1hY2hpbmUgfSBmcm9tICcuL1N0YXRlTWFjaGluZS01MzQ3OTUyOC5kZXZlbG9wbWVudC5lc20uanMnO1xuZXhwb3J0IHsgUyBhcyBTdGF0ZU1hY2hpbmUsIGEgYXMgU3RhdGVOb2RlIH0gZnJvbSAnLi9TdGF0ZU1hY2hpbmUtNTM0Nzk1MjguZGV2ZWxvcG1lbnQuZXNtLmpzJztcbmltcG9ydCB7IGEgYXMgYXNzaWduIH0gZnJvbSAnLi9hc3NpZ24tZWYxYjYyZjYuZGV2ZWxvcG1lbnQuZXNtLmpzJztcbmV4cG9ydCB7IGEgYXMgYXNzaWduIH0gZnJvbSAnLi9hc3NpZ24tZWYxYjYyZjYuZGV2ZWxvcG1lbnQuZXNtLmpzJztcbmltcG9ydCB7IHMgYXMgc2VuZFRvLCBsIGFzIGxvZywgZSBhcyBlbnF1ZXVlQWN0aW9ucywgYSBhcyBlbWl0IH0gZnJvbSAnLi9sb2ctM2VlYzkzNDYuZGV2ZWxvcG1lbnQuZXNtLmpzJztcbmV4cG9ydCB7IFMgYXMgU3BlY2lhbFRhcmdldHMsIGEgYXMgZW1pdCwgZSBhcyBlbnF1ZXVlQWN0aW9ucywgZiBhcyBmb3J3YXJkVG8sIGwgYXMgbG9nLCBiIGFzIHNlbmRQYXJlbnQsIHMgYXMgc2VuZFRvIH0gZnJvbSAnLi9sb2ctM2VlYzkzNDYuZGV2ZWxvcG1lbnQuZXNtLmpzJztcbmltcG9ydCAnLi4vZGV2L2Rpc3QveHN0YXRlLWRldi5kZXZlbG9wbWVudC5lc20uanMnO1xuXG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gZXZlbnQgb2JqZWN0IGlzIG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvciB0eXBlcy4gVGhyb3dzXG4gKiBhbiBlcnJvciBpZiB0aGUgZXZlbnQgb2JqZWN0IGlzIG5vdCBvZiB0aGUgc3BlY2lmaWVkIHR5cGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIC8vIC4uLlxuICogZW50cnk6ICh7IGV2ZW50IH0pID0+IHtcbiAqICAgYXNzZXJ0RXZlbnQoZXZlbnQsICdkb05vdGhpbmcnKTtcbiAqICAgLy8gZXZlbnQgaXMgeyB0eXBlOiAnZG9Ob3RoaW5nJyB9XG4gKiB9LFxuICogLy8gLi4uXG4gKiBleGl0OiAoeyBldmVudCB9KSA9PiB7XG4gKiAgIGFzc2VydEV2ZW50KGV2ZW50LCAnZ3JlZXQnKTtcbiAqICAgLy8gZXZlbnQgaXMgeyB0eXBlOiAnZ3JlZXQnOyBtZXNzYWdlOiBzdHJpbmcgfVxuICpcbiAqICAgYXNzZXJ0RXZlbnQoZXZlbnQsIFsnZ3JlZXQnLCAnbm90aWZ5J10pO1xuICogICAvLyBldmVudCBpcyB7IHR5cGU6ICdncmVldCc7IG1lc3NhZ2U6IHN0cmluZyB9XG4gKiAgIC8vIG9yIHsgdHlwZTogJ25vdGlmeSc7IG1lc3NhZ2U6IHN0cmluZzsgbGV2ZWw6ICdpbmZvJyB8ICdlcnJvcicgfVxuICogfSxcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBhc3NlcnRFdmVudChldmVudCwgdHlwZSkge1xuICBjb25zdCB0eXBlcyA9IHRvQXJyYXkodHlwZSk7XG4gIGNvbnN0IG1hdGNoZXMgPSB0eXBlcy5zb21lKGRlc2NyaXB0b3IgPT4gbWF0Y2hlc0V2ZW50RGVzY3JpcHRvcihldmVudC50eXBlLCBkZXNjcmlwdG9yKSk7XG4gIGlmICghbWF0Y2hlcykge1xuICAgIGNvbnN0IHR5cGVzVGV4dCA9IHR5cGVzLmxlbmd0aCA9PT0gMSA/IGB0eXBlIG1hdGNoaW5nIFwiJHt0eXBlc1swXX1cImAgOiBgb25lIG9mIHR5cGVzIG1hdGNoaW5nIFwiJHt0eXBlcy5qb2luKCdcIiwgXCInKX1cImA7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBldmVudCAke0pTT04uc3RyaW5naWZ5KGV2ZW50KX0gdG8gaGF2ZSAke3R5cGVzVGV4dH1gKTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGF0ZSBtYWNoaW5lIChzdGF0ZWNoYXJ0KSB3aXRoIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uLlxuICpcbiAqIFRoZSBzdGF0ZSBtYWNoaW5lIHJlcHJlc2VudHMgdGhlIHB1cmUgbG9naWMgb2YgYSBzdGF0ZSBtYWNoaW5lIGFjdG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNyZWF0ZU1hY2hpbmUgfSBmcm9tICd4c3RhdGUnO1xuICpcbiAqIGNvbnN0IGxpZ2h0TWFjaGluZSA9IGNyZWF0ZU1hY2hpbmUoe1xuICogICBpZDogJ2xpZ2h0JyxcbiAqICAgaW5pdGlhbDogJ2dyZWVuJyxcbiAqICAgc3RhdGVzOiB7XG4gKiAgICAgZ3JlZW46IHtcbiAqICAgICAgIG9uOiB7XG4gKiAgICAgICAgIFRJTUVSOiB7IHRhcmdldDogJ3llbGxvdycgfVxuICogICAgICAgfVxuICogICAgIH0sXG4gKiAgICAgeWVsbG93OiB7XG4gKiAgICAgICBvbjoge1xuICogICAgICAgICBUSU1FUjogeyB0YXJnZXQ6ICdyZWQnIH1cbiAqICAgICAgIH1cbiAqICAgICB9LFxuICogICAgIHJlZDoge1xuICogICAgICAgb246IHtcbiAqICAgICAgICAgVElNRVI6IHsgdGFyZ2V0OiAnZ3JlZW4nIH1cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pO1xuICpcbiAqIGNvbnN0IGxpZ2h0QWN0b3IgPSBjcmVhdGVBY3RvcihsaWdodE1hY2hpbmUpO1xuICogbGlnaHRBY3Rvci5zdGFydCgpO1xuICpcbiAqIGxpZ2h0QWN0b3Iuc2VuZCh7IHR5cGU6ICdUSU1FUicgfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gY29uZmlnIFRoZSBzdGF0ZSBtYWNoaW5lIGNvbmZpZ3VyYXRpb24uXG4gKiBAcGFyYW0gb3B0aW9ucyBERVBSRUNBVEVEOiB1c2UgYHNldHVwKHsgLi4uIH0pYCBvciBgbWFjaGluZS5wcm92aWRlKHsgLi4uIH0pYFxuICogICB0byBwcm92aWRlIG1hY2hpbmUgaW1wbGVtZW50YXRpb25zIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1hY2hpbmUoY29uZmlnLCBpbXBsZW1lbnRhdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBTdGF0ZU1hY2hpbmUoY29uZmlnLCBpbXBsZW1lbnRhdGlvbnMpO1xufVxuXG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBjcmVhdGVJbmVydEFjdG9yU2NvcGUoYWN0b3JMb2dpYykge1xuICBjb25zdCBzZWxmID0gY3JlYXRlQWN0b3IoYWN0b3JMb2dpYyk7XG4gIGNvbnN0IGluZXJ0QWN0b3JTY29wZSA9IHtcbiAgICBzZWxmLFxuICAgIGRlZmVyOiAoKSA9PiB7fSxcbiAgICBpZDogJycsXG4gICAgbG9nZ2VyOiAoKSA9PiB7fSxcbiAgICBzZXNzaW9uSWQ6ICcnLFxuICAgIHN0b3BDaGlsZDogKCkgPT4ge30sXG4gICAgc3lzdGVtOiBzZWxmLnN5c3RlbSxcbiAgICBlbWl0OiAoKSA9PiB7fSxcbiAgICBhY3Rpb25FeGVjdXRvcjogKCkgPT4ge31cbiAgfTtcbiAgcmV0dXJuIGluZXJ0QWN0b3JTY29wZTtcbn1cblxuLyoqIEBkZXByZWNhdGVkIFVzZSBgaW5pdGlhbFRyYW5zaXRpb24o4oCmKWAgaW5zdGVhZC4gKi9cbmZ1bmN0aW9uIGdldEluaXRpYWxTbmFwc2hvdChhY3RvckxvZ2ljLCAuLi5baW5wdXRdKSB7XG4gIGNvbnN0IGFjdG9yU2NvcGUgPSBjcmVhdGVJbmVydEFjdG9yU2NvcGUoYWN0b3JMb2dpYyk7XG4gIHJldHVybiBhY3RvckxvZ2ljLmdldEluaXRpYWxTbmFwc2hvdChhY3RvclNjb3BlLCBpbnB1dCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbmV4dCBzbmFwc2hvdCBmb3IgdGhlIGdpdmVuIGBhY3RvckxvZ2ljYCBiYXNlZCBvbiB0aGUgZ2l2ZW5cbiAqIGBzbmFwc2hvdGAgYW5kIGBldmVudGAuXG4gKlxuICogSWYgdGhlIGBzbmFwc2hvdGAgaXMgYHVuZGVmaW5lZGAsIHRoZSBpbml0aWFsIHNuYXBzaG90IG9mIHRoZSBgYWN0b3JMb2dpY2AgaXNcbiAqIHVzZWQuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGB0cmFuc2l0aW9uKOKApilgIGluc3RlYWQuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBnZXROZXh0U25hcHNob3QgfSBmcm9tICd4c3RhdGUnO1xuICogaW1wb3J0IHsgdHJhZmZpY0xpZ2h0TWFjaGluZSB9IGZyb20gJy4vdHJhZmZpY0xpZ2h0TWFjaGluZS50cyc7XG4gKlxuICogY29uc3QgbmV4dFNuYXBzaG90ID0gZ2V0TmV4dFNuYXBzaG90KFxuICogICB0cmFmZmljTGlnaHRNYWNoaW5lLCAvLyBhY3RvciBsb2dpY1xuICogICB1bmRlZmluZWQsIC8vIHNuYXBzaG90IChvciBpbml0aWFsIHN0YXRlIGlmIHVuZGVmaW5lZClcbiAqICAgeyB0eXBlOiAnVElNRVInIH1cbiAqICk7IC8vIGV2ZW50IG9iamVjdFxuICpcbiAqIGNvbnNvbGUubG9nKG5leHRTbmFwc2hvdC52YWx1ZSk7XG4gKiAvLyA9PiAneWVsbG93J1xuICpcbiAqIGNvbnN0IG5leHRTbmFwc2hvdDIgPSBnZXROZXh0U25hcHNob3QoXG4gKiAgIHRyYWZmaWNMaWdodE1hY2hpbmUsIC8vIGFjdG9yIGxvZ2ljXG4gKiAgIG5leHRTbmFwc2hvdCwgLy8gc25hcHNob3RcbiAqICAgeyB0eXBlOiAnVElNRVInIH1cbiAqICk7IC8vIGV2ZW50IG9iamVjdFxuICpcbiAqIGNvbnNvbGUubG9nKG5leHRTbmFwc2hvdDIudmFsdWUpO1xuICogLy8gPT4ncmVkJ1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGdldE5leHRTbmFwc2hvdChhY3RvckxvZ2ljLCBzbmFwc2hvdCwgZXZlbnQpIHtcbiAgY29uc3QgaW5lcnRBY3RvclNjb3BlID0gY3JlYXRlSW5lcnRBY3RvclNjb3BlKGFjdG9yTG9naWMpO1xuICBpbmVydEFjdG9yU2NvcGUuc2VsZi5fc25hcHNob3QgPSBzbmFwc2hvdDtcbiAgcmV0dXJuIGFjdG9yTG9naWMudHJhbnNpdGlvbihzbmFwc2hvdCwgZXZlbnQsIGluZXJ0QWN0b3JTY29wZSk7XG59XG5cbi8vIGF0IHRoZSBtb21lbnQgd2UgYWxsb3cgZXh0cmEgYWN0b3JzIC0gb25lcyB0aGF0IGFyZSBub3Qgc3BlY2lmaWVkIGJ5IGBjaGlsZHJlbmBcbi8vIHRoaXMgY291bGQgYmUgcmVjb25zaWRlcmVkIGluIHRoZSBmdXR1cmVcblxuLy8gdXNlZCB0byBrZWVwIG9ubHkgU3RhdGVTY2hlbWEgcmVsZXZhbnQga2V5c1xuLy8gdGhpcyBoZWxwcyB3aXRoIHR5cGUgc2VyaWFsaXphdGlvbiBhcyBpdCBtYWtlcyB0aGUgaW5mZXJyZWQgdHlwZSBtdWNoIHNob3J0ZXIgd2hlbiBkZWFsaW5nIHdpdGggaHVnZSBjb25maWdzXG5cbmZ1bmN0aW9uIHNldHVwKHtcbiAgc2NoZW1hcyxcbiAgYWN0b3JzLFxuICBhY3Rpb25zLFxuICBndWFyZHMsXG4gIGRlbGF5c1xufSkge1xuICByZXR1cm4ge1xuICAgIGFzc2lnbixcbiAgICBzZW5kVG8sXG4gICAgcmFpc2UsXG4gICAgbG9nLFxuICAgIGNhbmNlbCxcbiAgICBzdG9wQ2hpbGQsXG4gICAgZW5xdWV1ZUFjdGlvbnMsXG4gICAgZW1pdCxcbiAgICBzcGF3bkNoaWxkLFxuICAgIGNyZWF0ZVN0YXRlQ29uZmlnOiBjb25maWcgPT4gY29uZmlnLFxuICAgIGNyZWF0ZUFjdGlvbjogZm4gPT4gZm4sXG4gICAgY3JlYXRlTWFjaGluZTogY29uZmlnID0+IGNyZWF0ZU1hY2hpbmUoe1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgc2NoZW1hc1xuICAgIH0sIHtcbiAgICAgIGFjdG9ycyxcbiAgICAgIGFjdGlvbnMsXG4gICAgICBndWFyZHMsXG4gICAgICBkZWxheXNcbiAgICB9KSxcbiAgICBleHRlbmQ6IGV4dGVuZGVkID0+IHNldHVwKHtcbiAgICAgIHNjaGVtYXMsXG4gICAgICBhY3RvcnMsXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgIC4uLmFjdGlvbnMsXG4gICAgICAgIC4uLmV4dGVuZGVkLmFjdGlvbnNcbiAgICAgIH0sXG4gICAgICBndWFyZHM6IHtcbiAgICAgICAgLi4uZ3VhcmRzLFxuICAgICAgICAuLi5leHRlbmRlZC5ndWFyZHNcbiAgICAgIH0sXG4gICAgICBkZWxheXM6IHtcbiAgICAgICAgLi4uZGVsYXlzLFxuICAgICAgICAuLi5leHRlbmRlZC5kZWxheXNcbiAgICAgIH1cbiAgICB9KVxuICB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1kZWNsYXJhdGlvbi1tZXJnaW5nXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWRlY2xhcmF0aW9uLW1lcmdpbmdcbmNsYXNzIFNpbXVsYXRlZENsb2NrIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50aW1lb3V0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ub3cgPSAwO1xuICAgIHRoaXMuX2lkID0gMDtcbiAgICB0aGlzLl9mbHVzaGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2ZsdXNoaW5nSW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgfVxuICBub3coKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vdztcbiAgfVxuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWQrKztcbiAgfVxuICBzZXRUaW1lb3V0KGZuLCB0aW1lb3V0KSB7XG4gICAgdGhpcy5fZmx1c2hpbmdJbnZhbGlkYXRlZCA9IHRoaXMuX2ZsdXNoaW5nO1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXRJZCgpO1xuICAgIHRoaXMudGltZW91dHMuc2V0KGlkLCB7XG4gICAgICBzdGFydDogdGhpcy5ub3coKSxcbiAgICAgIHRpbWVvdXQsXG4gICAgICBmblxuICAgIH0pO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBjbGVhclRpbWVvdXQoaWQpIHtcbiAgICB0aGlzLl9mbHVzaGluZ0ludmFsaWRhdGVkID0gdGhpcy5fZmx1c2hpbmc7XG4gICAgdGhpcy50aW1lb3V0cy5kZWxldGUoaWQpO1xuICB9XG4gIHNldCh0aW1lKSB7XG4gICAgaWYgKHRoaXMuX25vdyA+IHRpbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHRyYXZlbCBiYWNrIGluIHRpbWUnKTtcbiAgICB9XG4gICAgdGhpcy5fbm93ID0gdGltZTtcbiAgICB0aGlzLmZsdXNoVGltZW91dHMoKTtcbiAgfVxuICBmbHVzaFRpbWVvdXRzKCkge1xuICAgIGlmICh0aGlzLl9mbHVzaGluZykge1xuICAgICAgdGhpcy5fZmx1c2hpbmdJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2ZsdXNoaW5nID0gdHJ1ZTtcbiAgICBjb25zdCBzb3J0ZWQgPSBbLi4udGhpcy50aW1lb3V0c10uc29ydCgoW19pZEEsIHRpbWVvdXRBXSwgW19pZEIsIHRpbWVvdXRCXSkgPT4ge1xuICAgICAgY29uc3QgZW5kQSA9IHRpbWVvdXRBLnN0YXJ0ICsgdGltZW91dEEudGltZW91dDtcbiAgICAgIGNvbnN0IGVuZEIgPSB0aW1lb3V0Qi5zdGFydCArIHRpbWVvdXRCLnRpbWVvdXQ7XG4gICAgICByZXR1cm4gZW5kQiA+IGVuZEEgPyAtMSA6IDE7XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBbaWQsIHRpbWVvdXRdIG9mIHNvcnRlZCkge1xuICAgICAgaWYgKHRoaXMuX2ZsdXNoaW5nSW52YWxpZGF0ZWQpIHtcbiAgICAgICAgdGhpcy5fZmx1c2hpbmdJbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9mbHVzaGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZsdXNoVGltZW91dHMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubm93KCkgLSB0aW1lb3V0LnN0YXJ0ID49IHRpbWVvdXQudGltZW91dCkge1xuICAgICAgICB0aGlzLnRpbWVvdXRzLmRlbGV0ZShpZCk7XG4gICAgICAgIHRpbWVvdXQuZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZmx1c2hpbmcgPSBmYWxzZTtcbiAgfVxuICBpbmNyZW1lbnQobXMpIHtcbiAgICB0aGlzLl9ub3cgKz0gbXM7XG4gICAgdGhpcy5mbHVzaFRpbWVvdXRzKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBgb3V0cHV0YCBvZiB0aGUgYWN0b3Igd2hlbiBpdCBpcyBkb25lLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IG1hY2hpbmUgPSBjcmVhdGVNYWNoaW5lKHtcbiAqICAgLy8gLi4uXG4gKiAgIG91dHB1dDoge1xuICogICAgIGNvdW50OiA0MlxuICogICB9XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKG1hY2hpbmUpO1xuICpcbiAqIGFjdG9yLnN0YXJ0KCk7XG4gKlxuICogY29uc3Qgb3V0cHV0ID0gYXdhaXQgdG9Qcm9taXNlKGFjdG9yKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvdXRwdXQpO1xuICogLy8gbG9ncyB7IGNvdW50OiA0MiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdG9Qcm9taXNlKGFjdG9yKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgYWN0b3Iuc3Vic2NyaWJlKHtcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoYWN0b3IuZ2V0U25hcHNob3QoKS5vdXRwdXQpO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiByZWplY3RcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2l2ZW4gYWN0b3IgYGxvZ2ljYCwgYSBgc25hcHNob3RgLCBhbmQgYW4gYGV2ZW50YCwgcmV0dXJucyBhIHR1cGxlIG9mIHRoZVxuICogYG5leHRTbmFwc2hvdGAgYW5kIGBhY3Rpb25zYCB0byBleGVjdXRlLlxuICpcbiAqIFRoaXMgaXMgYSBwdXJlIGZ1bmN0aW9uIHRoYXQgZG9lcyBub3QgZXhlY3V0ZSBgYWN0aW9uc2AuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zaXRpb24obG9naWMsIHNuYXBzaG90LCBldmVudCkge1xuICBjb25zdCBleGVjdXRhYmxlQWN0aW9ucyA9IFtdO1xuICBjb25zdCBhY3RvclNjb3BlID0gY3JlYXRlSW5lcnRBY3RvclNjb3BlKGxvZ2ljKTtcbiAgYWN0b3JTY29wZS5hY3Rpb25FeGVjdXRvciA9IGFjdGlvbiA9PiB7XG4gICAgZXhlY3V0YWJsZUFjdGlvbnMucHVzaChhY3Rpb24pO1xuICB9O1xuICBjb25zdCBuZXh0U25hcHNob3QgPSBsb2dpYy50cmFuc2l0aW9uKHNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSk7XG4gIHJldHVybiBbbmV4dFNuYXBzaG90LCBleGVjdXRhYmxlQWN0aW9uc107XG59XG5cbi8qKlxuICogR2l2ZW4gYWN0b3IgYGxvZ2ljYCBhbmQgb3B0aW9uYWwgYGlucHV0YCwgcmV0dXJucyBhIHR1cGxlIG9mIHRoZVxuICogYG5leHRTbmFwc2hvdGAgYW5kIGBhY3Rpb25zYCB0byBleGVjdXRlIGZyb20gdGhlIGluaXRpYWwgdHJhbnNpdGlvbiAobm9cbiAqIHByZXZpb3VzIHN0YXRlKS5cbiAqXG4gKiBUaGlzIGlzIGEgcHVyZSBmdW5jdGlvbiB0aGF0IGRvZXMgbm90IGV4ZWN1dGUgYGFjdGlvbnNgLlxuICovXG5mdW5jdGlvbiBpbml0aWFsVHJhbnNpdGlvbihsb2dpYywgLi4uW2lucHV0XSkge1xuICBjb25zdCBleGVjdXRhYmxlQWN0aW9ucyA9IFtdO1xuICBjb25zdCBhY3RvclNjb3BlID0gY3JlYXRlSW5lcnRBY3RvclNjb3BlKGxvZ2ljKTtcbiAgYWN0b3JTY29wZS5hY3Rpb25FeGVjdXRvciA9IGFjdGlvbiA9PiB7XG4gICAgZXhlY3V0YWJsZUFjdGlvbnMucHVzaChhY3Rpb24pO1xuICB9O1xuICBjb25zdCBuZXh0U25hcHNob3QgPSBsb2dpYy5nZXRJbml0aWFsU25hcHNob3QoYWN0b3JTY29wZSwgaW5wdXQpO1xuICByZXR1cm4gW25leHRTbmFwc2hvdCwgZXhlY3V0YWJsZUFjdGlvbnNdO1xufVxuXG5jb25zdCBkZWZhdWx0V2FpdEZvck9wdGlvbnMgPSB7XG4gIHRpbWVvdXQ6IEluZmluaXR5IC8vIG11Y2ggbW9yZSB0aGFuIDEwIHNlY29uZHNcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlcyB0byBhbiBhY3RvciByZWYgYW5kIHdhaXRzIGZvciBpdHMgZW1pdHRlZCB2YWx1ZSB0byBzYXRpc2Z5IGFcbiAqIHByZWRpY2F0ZSwgYW5kIHRoZW4gcmVzb2x2ZXMgd2l0aCB0aGF0IHZhbHVlLiBXaWxsIHRocm93IGlmIHRoZSBkZXNpcmVkIHN0YXRlXG4gKiBpcyBub3QgcmVhY2hlZCBhZnRlciBhbiBvcHRpb25hbCB0aW1lb3V0LiAoZGVmYXVsdHMgdG8gSW5maW5pdHkpLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHN0YXRlID0gYXdhaXQgd2FpdEZvcihzb21lU2VydmljZSwgKHN0YXRlKSA9PiB7XG4gKiAgIHJldHVybiBzdGF0ZS5oYXNUYWcoJ2xvYWRlZCcpO1xuICogfSk7XG4gKlxuICogc3RhdGUuaGFzVGFnKCdsb2FkZWQnKTsgLy8gdHJ1ZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFjdG9yUmVmIFRoZSBhY3RvciByZWYgdG8gc3Vic2NyaWJlIHRvXG4gKiBAcGFyYW0gcHJlZGljYXRlIERldGVybWluZXMgaWYgYSB2YWx1ZSBtYXRjaGVzIHRoZSBjb25kaXRpb24gdG8gd2FpdCBmb3JcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCBldmVudHVhbGx5IHJlc29sdmVzIHRvIHRoZSBlbWl0dGVkIHZhbHVlIHRoYXQgbWF0Y2hlc1xuICogICB0aGUgY29uZGl0aW9uXG4gKi9cbmZ1bmN0aW9uIHdhaXRGb3IoYWN0b3JSZWYsIHByZWRpY2F0ZSwgb3B0aW9ucykge1xuICBjb25zdCByZXNvbHZlZE9wdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdFdhaXRGb3JPcHRpb25zLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHNpZ25hbFxuICAgIH0gPSByZXNvbHZlZE9wdGlvbnM7XG4gICAgaWYgKHNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItcHJvbWlzZS1yZWplY3QtZXJyb3JzXG4gICAgICByZWooc2lnbmFsLnJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgaWYgKHJlc29sdmVkT3B0aW9ucy50aW1lb3V0IDwgMCkge1xuICAgICAgY29uc29sZS5lcnJvcignYHRpbWVvdXRgIHBhc3NlZCB0byBgd2FpdEZvcmAgaXMgbmVnYXRpdmUgYW5kIGl0IHdpbGwgcmVqZWN0IGl0cyBpbnRlcm5hbCBwcm9taXNlIGltbWVkaWF0ZWx5LicpO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGUgPSByZXNvbHZlZE9wdGlvbnMudGltZW91dCA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGRpc3Bvc2UoKTtcbiAgICAgIHJlaihuZXcgRXJyb3IoYFRpbWVvdXQgb2YgJHtyZXNvbHZlZE9wdGlvbnMudGltZW91dH0gbXMgZXhjZWVkZWRgKSk7XG4gICAgfSwgcmVzb2x2ZWRPcHRpb25zLnRpbWVvdXQpO1xuICAgIGNvbnN0IGRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgc3ViPy51bnN1YnNjcmliZSgpO1xuICAgICAgaWYgKGFib3J0TGlzdGVuZXIpIHtcbiAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjaGVja0VtaXR0ZWQoZW1pdHRlZCkge1xuICAgICAgaWYgKHByZWRpY2F0ZShlbWl0dGVkKSkge1xuICAgICAgICBkaXNwb3NlKCk7XG4gICAgICAgIHJlcyhlbWl0dGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgYHNpZ25hbGAgb3B0aW9uIGlzIHByb3ZpZGVkLCB0aGlzIHdpbGwgYmUgdGhlIGxpc3RlbmVyIGZvciBpdHNcbiAgICAgKiBgYWJvcnRgIGV2ZW50XG4gICAgICovXG4gICAgbGV0IGFib3J0TGlzdGVuZXI7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGxldCBzdWI7IC8vIGF2b2lkIFREWiB3aGVuIGRpc3Bvc2luZyBzeW5jaHJvbm91c2x5XG5cbiAgICAvLyBTZWUgaWYgdGhlIGN1cnJlbnQgc25hcHNob3QgYWxyZWFkeSBtYXRjaGVzIHRoZSBwcmVkaWNhdGVcbiAgICBjaGVja0VtaXR0ZWQoYWN0b3JSZWYuZ2V0U25hcHNob3QoKSk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBvbmx5IGRlZmluZSB0aGUgYGFib3J0TGlzdGVuZXJgIGlmIHRoZSBgc2lnbmFsYCBvcHRpb24gaXMgcHJvdmlkZWRcbiAgICBpZiAoc2lnbmFsKSB7XG4gICAgICBhYm9ydExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICBkaXNwb3NlKCk7XG4gICAgICAgIC8vIFhTdGF0ZSBkb2VzIG5vdCBcIm93blwiIHRoZSBzaWduYWwsIHNvIHdlIHNob3VsZCByZWplY3Qgd2l0aCBpdHMgcmVhc29uIChpZiBhbnkpXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLXByb21pc2UtcmVqZWN0LWVycm9yc1xuICAgICAgICByZWooc2lnbmFsLnJlYXNvbik7XG4gICAgICB9O1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRMaXN0ZW5lcik7XG4gICAgfVxuICAgIHN1YiA9IGFjdG9yUmVmLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiBjaGVja0VtaXR0ZWQsXG4gICAgICBlcnJvcjogZXJyID0+IHtcbiAgICAgICAgZGlzcG9zZSgpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1wcm9taXNlLXJlamVjdC1lcnJvcnNcbiAgICAgICAgcmVqKGVycik7XG4gICAgICB9LFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgZGlzcG9zZSgpO1xuICAgICAgICByZWoobmV3IEVycm9yKGBBY3RvciB0ZXJtaW5hdGVkIHdpdGhvdXQgc2F0aXNmeWluZyBwcmVkaWNhdGVgKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCB7IFNpbXVsYXRlZENsb2NrLCBhc3NlcnRFdmVudCwgY3JlYXRlTWFjaGluZSwgZ2V0SW5pdGlhbFNuYXBzaG90LCBnZXROZXh0U25hcHNob3QsIGluaXRpYWxUcmFuc2l0aW9uLCBzZXR1cCwgdG9Qcm9taXNlLCB0cmFuc2l0aW9uLCB3YWl0Rm9yIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/xstate.development.esm.js\n");

/***/ })

};
;