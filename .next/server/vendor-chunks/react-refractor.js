"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-refractor";
exports.ids = ["vendor-chunks/react-refractor"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-refractor/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/react-refractor/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Refractor: () => (/* binding */ Refractor),\n/* harmony export */   hasLanguage: () => (/* binding */ hasLanguage),\n/* harmony export */   registerLanguage: () => (/* binding */ registerLanguage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var refractor_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! refractor/core */ \"(ssr)/./node_modules/refractor/lib/core.js\");\n/* harmony import */ var unist_util_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unist-util-filter */ \"(ssr)/./node_modules/unist-util-filter/lib/index.js\");\n/* harmony import */ var unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! unist-util-visit-parents */ \"(ssr)/./node_modules/unist-util-visit-parents/lib/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n\n\nvar __defProp$2 = Object.defineProperty, __defProps$2 = Object.defineProperties, __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b))\n      __propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  return a;\n}, __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nfunction addMarkers(ast, options) {\n  const markers = options.markers.map((marker) => typeof marker == \"number\" ? { line: marker } : marker).sort((nodeA, nodeB) => nodeA.line - nodeB.line), numbered = lineNumberify(ast.children).nodes;\n  return markers.length === 0 || numbered.length === 0 ? __spreadProps$2(__spreadValues$2({}, ast), { children: numbered }) : wrapLines(numbered, markers, options);\n}\nfunction lineNumberify(ast, context = { lineNumber: 1 }) {\n  const resultNodes = [];\n  return ast.reduce(\n    (result, node) => {\n      if (node.type === \"doctype\")\n        return result;\n      const lineStart = context.lineNumber;\n      if (node.type === \"text\") {\n        if (node.value.indexOf(`\n`) === -1)\n          return setLineInfo(node, lineStart, lineStart), result.nodes.push(node), result;\n        const lines = node.value.split(`\n`);\n        for (let i = 0; i < lines.length; i++) {\n          const lineNum = i === 0 ? context.lineNumber : ++context.lineNumber, text = {\n            type: \"text\",\n            value: i === lines.length - 1 ? lines[i] : `${lines[i]}\n`\n          }, withLineInfo = setLineInfo(text, lineNum, lineNum);\n          result.nodes.push(withLineInfo);\n        }\n        return result.lineNumber = context.lineNumber, result;\n      }\n      if (node.type === \"element\" && node.children) {\n        const processed = lineNumberify(node.children, context), firstChild = processed.nodes.find(isElementOrText), lastChild = processed.nodes.findLast(isElementOrText);\n        return setLineInfo(\n          node,\n          firstChild ? getLineStart(firstChild, lineStart) : lineStart,\n          lastChild ? getLineEnd(lastChild, lineStart) : lineStart\n        ), node.children = processed.nodes, result.lineNumber = processed.lineNumber, result.nodes.push(node), result;\n      }\n      return result.nodes.push(node), result;\n    },\n    { nodes: resultNodes, lineNumber: context.lineNumber }\n  );\n}\nfunction isElementOrText(node) {\n  return node.type === \"element\" || node.type === \"text\";\n}\nfunction getLineStart(node, fallbackLineStart = 1) {\n  return node.data && typeof node.data.lineStart == \"number\" ? node.data.lineStart : fallbackLineStart;\n}\nfunction getLineEnd(node, fallbackLineEnd = 1) {\n  return node.data && typeof node.data.lineEnd == \"number\" ? node.data.lineEnd : fallbackLineEnd;\n}\nfunction setLineInfo(node, lineStart, lineEnd) {\n  return node.data || (node.data = {}), node.data.lineStart = lineStart, node.data.lineEnd = lineEnd, node;\n}\nfunction unwrapLine(markerLine, nodes) {\n  const tree = { type: \"root\", children: nodes }, headMap = /* @__PURE__ */ new WeakMap(), lineMap = /* @__PURE__ */ new WeakMap(), tailMap = /* @__PURE__ */ new WeakMap(), cloned = [];\n  function addCopy(map, node, ancestors) {\n    cloned.push(node), ancestors.forEach((ancestor) => {\n      map.has(ancestor) || (map.set(ancestor, Object.assign({}, ancestor, { children: [] })), ancestor !== tree && cloned.push(ancestor));\n    });\n    let i = ancestors.length;\n    for (; i--; ) {\n      const ancestor = map.get(ancestors[i]);\n      if (!ancestor || !(\"children\" in ancestor))\n        continue;\n      const child = ancestors[i + 1], leaf = map.get(child) || node;\n      ancestor.children.indexOf(leaf) === -1 && ancestor.children.push(leaf);\n    }\n  }\n  (0,unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_2__.visitParents)(tree, (node, ancestors) => {\n    if (!(\"children\" in node || !isElementOrText(node))) {\n      if (getLineStart(node) < markerLine) {\n        addCopy(headMap, node, ancestors);\n        return;\n      }\n      if (getLineStart(node) === markerLine) {\n        addCopy(lineMap, node, ancestors);\n        return;\n      }\n      getLineEnd(node) > markerLine && cloned.some((clone) => ancestors.includes(clone)) && addCopy(tailMap, node, ancestors);\n    }\n  });\n  const filtered = (0,unist_util_filter__WEBPACK_IMPORTED_MODULE_3__.filter)(tree, (node) => cloned.indexOf(node) === -1), getChildren = (map) => {\n    const rootNode = map.get(tree);\n    return rootNode ? ((0,unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_2__.visitParents)(rootNode, (leaf, ancestors) => {\n      if (isElementOrText(leaf) && \"children\" in leaf) {\n        setLineInfo(leaf, 0, 0);\n        return;\n      }\n      ancestors.forEach((ancestor) => {\n        setLineInfo(\n          ancestor,\n          Math.max(getLineStart(ancestor), getLineStart(leaf)),\n          Math.max(getLineEnd(ancestor), getLineEnd(leaf))\n        );\n      });\n    }), rootNode.children) : [];\n  };\n  return [\n    ...getChildren(headMap),\n    ...getChildren(lineMap),\n    ...getChildren(tailMap),\n    ...filtered ? filtered.children : []\n  ];\n}\nfunction wrapBatch(children, marker, options) {\n  const className = marker.className || \"refractor-marker\", baseData = {\n    lineStart: marker.line,\n    lineEnd: getLineEnd(children[children.length - 1]),\n    isMarker: !0\n  };\n  return {\n    type: \"element\",\n    tagName: \"div\",\n    data: marker.component ? __spreadProps$2(__spreadValues$2({}, baseData), { component: marker.component, markerProperties: options }) : baseData,\n    properties: { className },\n    children\n  };\n}\nfunction wrapLines(treeNodes, markers, options) {\n  const ast = markers.reduce(\n    (acc, marker) => unwrapLine(marker.line, acc),\n    treeNodes\n  ), wrapped = [];\n  let astIndex = 0;\n  for (let m = 0; m < markers.length; m++) {\n    const marker = markers[m];\n    for (let node = ast[astIndex]; node && getLineEnd(node) < marker.line; node = ast[++astIndex])\n      wrapped.push(node);\n    const batch = [];\n    for (let node = ast[astIndex]; node && getLineEnd(node) === marker.line; node = ast[++astIndex])\n      node.type !== \"doctype\" && batch.push(node);\n    batch.length > 0 && wrapped.push(wrapBatch(batch, marker, options));\n  }\n  for (; astIndex < ast.length; )\n    wrapped.push(ast[astIndex++]);\n  return { type: \"root\", children: wrapped };\n}\nvar __defProp$1 = Object.defineProperty, __defProps$1 = Object.defineProperties, __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b))\n      __propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  return a;\n}, __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nfunction mapWithDepth(depth) {\n  return function(child, i) {\n    return mapChild(child, i, depth);\n  };\n}\nfunction mapChild(child, i, depth) {\n  if (child.type === \"doctype\")\n    return null;\n  if (!(\"tagName\" in child))\n    return child.value;\n  let className = \"\";\n  typeof child.properties < \"u\" && (className = Array.isArray(child.properties.className) ? child.properties.className.join(\" \") : `${child.properties.className}`);\n  const key = `fract-${depth}-${i}`, children = child.children && child.children.map(mapWithDepth(depth + 1));\n  return isReactRefractorMarkerDataWithComponent(child.data) ? (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n    child.data.component,\n    __spreadProps$1(__spreadValues$1(__spreadValues$1({ key }, child.properties), child.data.markerProperties), { className }),\n    children\n  ) : (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(child.tagName, { key, className }, children);\n}\nfunction isReactRefractorMarkerDataWithComponent(data) {\n  return typeof data == \"object\" && data !== null && \"component\" in data && \"markerProperties\" in data;\n}\nvar __defProp = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b))\n      __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);\n  return a;\n}, __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst DEFAULT_CLASSNAME = \"refractor\";\nfunction Refractor(props) {\n  const className = props.className || DEFAULT_CLASSNAME, langClassName = `language-${props.language}`, codeProps = { className: langClassName }, preClass = [className, langClassName].filter(Boolean).join(\" \");\n  if (props.inline && (codeProps.style = { display: \"inline\" }, codeProps.className = className), props.plainText) {\n    const code2 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"code\", __spreadProps(__spreadValues({}, codeProps), { children: props.value }));\n    return props.inline ? code2 : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"pre\", { className: preClass, children: code2 });\n  }\n  let ast = refractor_core__WEBPACK_IMPORTED_MODULE_4__.refractor.highlight(props.value, props.language);\n  props.markers && props.markers.length > 0 && (ast = addMarkers(ast, { markers: props.markers }));\n  const value = ast.children.length === 0 ? props.value : ast.children.map(mapWithDepth(0)), code = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"code\", __spreadProps(__spreadValues({}, codeProps), { children: value }));\n  return props.inline ? code : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"pre\", { className: preClass, children: code });\n}\nconst registerLanguage = (lang) => refractor_core__WEBPACK_IMPORTED_MODULE_4__.refractor.register(lang), hasLanguage = (lang) => refractor_core__WEBPACK_IMPORTED_MODULE_4__.refractor.registered(lang);\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVmcmFjdG9yL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBd0M7QUFDRztBQUNBO0FBQ2E7QUFDbEI7QUFDdEMsdVhBQXVYLHVEQUF1RDtBQUM5YSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGdGQUFnRixlQUFlO0FBQy9GLDRGQUE0RixVQUFVLG9CQUFvQjtBQUMxSDtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7QUFDQSw4REFBOEQsY0FBYyxjQUFjO0FBQzFGLEtBQUs7QUFDTDtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0VBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG1CQUFtQix5REFBTTtBQUN6QjtBQUNBLHVCQUF1QixzRUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxlQUFlLHdEQUF3RDtBQUN2SSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0EsbUNBQW1DLHdDQUF3QztBQUMzRTtBQUNBO0FBQ0EsbUNBQW1DLDBDQUEwQztBQUM3RTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHVCQUF1QjtBQUNoQztBQUNBLFdBQVc7QUFDWDtBQUNBLHVYQUF1WCx1REFBdUQ7QUFDOWEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNJQUFzSSwyQkFBMkI7QUFDakssdUJBQXVCLE1BQU0sR0FBRyxFQUFFO0FBQ2xDLCtEQUErRCxvREFBYTtBQUM1RTtBQUNBLHdEQUF3RCxLQUFLLHFEQUFxRCxXQUFXO0FBQzdIO0FBQ0EsTUFBTSxvREFBYSxrQkFBa0IsZ0JBQWdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdVdBQXVXLHVEQUF1RDtBQUM5WiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esc0ZBQXNGLGVBQWUsaUJBQWlCLDBCQUEwQjtBQUNoSiwyQ0FBMkMsbUJBQW1CO0FBQzlELGtDQUFrQyxzREFBRyx3Q0FBd0MsZ0JBQWdCLHVCQUF1QjtBQUNwSCxrREFBa0Qsc0RBQUcsVUFBVSxzQ0FBc0M7QUFDckc7QUFDQSxZQUFZLHFEQUFTO0FBQ3JCLHdFQUF3RSx3QkFBd0I7QUFDaEcsb0hBQW9ILHNEQUFHLHdDQUF3QyxnQkFBZ0IsaUJBQWlCO0FBQ2hNLCtDQUErQyxzREFBRyxVQUFVLHFDQUFxQztBQUNqRztBQUNBLG1DQUFtQyxxREFBUyx5Q0FBeUMscURBQVM7QUFLNUY7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaXNwLWNsZWFuaW5nLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZnJhY3Rvci9kaXN0L2luZGV4LmpzP2U5Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyByZWZyYWN0b3IgfSBmcm9tIFwicmVmcmFjdG9yL2NvcmVcIjtcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gXCJ1bmlzdC11dGlsLWZpbHRlclwiO1xuaW1wb3J0IHsgdmlzaXRQYXJlbnRzIH0gZnJvbSBcInVuaXN0LXV0aWwtdmlzaXQtcGFyZW50c1wiO1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gXCJyZWFjdFwiO1xudmFyIF9fZGVmUHJvcCQyID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBfX2RlZlByb3BzJDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcywgX19nZXRPd25Qcm9wRGVzY3MkMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzLCBfX2dldE93blByb3BTeW1ib2xzJDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBfX2hhc093blByb3AkMiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIF9fcHJvcElzRW51bSQyID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgX19kZWZOb3JtYWxQcm9wJDIgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDIob2JqLCBrZXksIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlLCBfX3NwcmVhZFZhbHVlcyQyID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIF9faGFzT3duUHJvcCQyLmNhbGwoYiwgcHJvcCkgJiYgX19kZWZOb3JtYWxQcm9wJDIoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzJDIpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzJDIoYikpXG4gICAgICBfX3Byb3BJc0VudW0kMi5jYWxsKGIsIHByb3ApICYmIF9fZGVmTm9ybWFsUHJvcCQyKGEsIHByb3AsIGJbcHJvcF0pO1xuICByZXR1cm4gYTtcbn0sIF9fc3ByZWFkUHJvcHMkMiA9IChhLCBiKSA9PiBfX2RlZlByb3BzJDIoYSwgX19nZXRPd25Qcm9wRGVzY3MkMihiKSk7XG5mdW5jdGlvbiBhZGRNYXJrZXJzKGFzdCwgb3B0aW9ucykge1xuICBjb25zdCBtYXJrZXJzID0gb3B0aW9ucy5tYXJrZXJzLm1hcCgobWFya2VyKSA9PiB0eXBlb2YgbWFya2VyID09IFwibnVtYmVyXCIgPyB7IGxpbmU6IG1hcmtlciB9IDogbWFya2VyKS5zb3J0KChub2RlQSwgbm9kZUIpID0+IG5vZGVBLmxpbmUgLSBub2RlQi5saW5lKSwgbnVtYmVyZWQgPSBsaW5lTnVtYmVyaWZ5KGFzdC5jaGlsZHJlbikubm9kZXM7XG4gIHJldHVybiBtYXJrZXJzLmxlbmd0aCA9PT0gMCB8fCBudW1iZXJlZC5sZW5ndGggPT09IDAgPyBfX3NwcmVhZFByb3BzJDIoX19zcHJlYWRWYWx1ZXMkMih7fSwgYXN0KSwgeyBjaGlsZHJlbjogbnVtYmVyZWQgfSkgOiB3cmFwTGluZXMobnVtYmVyZWQsIG1hcmtlcnMsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gbGluZU51bWJlcmlmeShhc3QsIGNvbnRleHQgPSB7IGxpbmVOdW1iZXI6IDEgfSkge1xuICBjb25zdCByZXN1bHROb2RlcyA9IFtdO1xuICByZXR1cm4gYXN0LnJlZHVjZShcbiAgICAocmVzdWx0LCBub2RlKSA9PiB7XG4gICAgICBpZiAobm9kZS50eXBlID09PSBcImRvY3R5cGVcIilcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGNvbnN0IGxpbmVTdGFydCA9IGNvbnRleHQubGluZU51bWJlcjtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgIGlmIChub2RlLnZhbHVlLmluZGV4T2YoYFxuYCkgPT09IC0xKVxuICAgICAgICAgIHJldHVybiBzZXRMaW5lSW5mbyhub2RlLCBsaW5lU3RhcnQsIGxpbmVTdGFydCksIHJlc3VsdC5ub2Rlcy5wdXNoKG5vZGUpLCByZXN1bHQ7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gbm9kZS52YWx1ZS5zcGxpdChgXG5gKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGxpbmVOdW0gPSBpID09PSAwID8gY29udGV4dC5saW5lTnVtYmVyIDogKytjb250ZXh0LmxpbmVOdW1iZXIsIHRleHQgPSB7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHZhbHVlOiBpID09PSBsaW5lcy5sZW5ndGggLSAxID8gbGluZXNbaV0gOiBgJHtsaW5lc1tpXX1cbmBcbiAgICAgICAgICB9LCB3aXRoTGluZUluZm8gPSBzZXRMaW5lSW5mbyh0ZXh0LCBsaW5lTnVtLCBsaW5lTnVtKTtcbiAgICAgICAgICByZXN1bHQubm9kZXMucHVzaCh3aXRoTGluZUluZm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQubGluZU51bWJlciA9IGNvbnRleHQubGluZU51bWJlciwgcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgbm9kZS5jaGlsZHJlbikge1xuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBsaW5lTnVtYmVyaWZ5KG5vZGUuY2hpbGRyZW4sIGNvbnRleHQpLCBmaXJzdENoaWxkID0gcHJvY2Vzc2VkLm5vZGVzLmZpbmQoaXNFbGVtZW50T3JUZXh0KSwgbGFzdENoaWxkID0gcHJvY2Vzc2VkLm5vZGVzLmZpbmRMYXN0KGlzRWxlbWVudE9yVGV4dCk7XG4gICAgICAgIHJldHVybiBzZXRMaW5lSW5mbyhcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIGZpcnN0Q2hpbGQgPyBnZXRMaW5lU3RhcnQoZmlyc3RDaGlsZCwgbGluZVN0YXJ0KSA6IGxpbmVTdGFydCxcbiAgICAgICAgICBsYXN0Q2hpbGQgPyBnZXRMaW5lRW5kKGxhc3RDaGlsZCwgbGluZVN0YXJ0KSA6IGxpbmVTdGFydFxuICAgICAgICApLCBub2RlLmNoaWxkcmVuID0gcHJvY2Vzc2VkLm5vZGVzLCByZXN1bHQubGluZU51bWJlciA9IHByb2Nlc3NlZC5saW5lTnVtYmVyLCByZXN1bHQubm9kZXMucHVzaChub2RlKSwgcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdC5ub2Rlcy5wdXNoKG5vZGUpLCByZXN1bHQ7XG4gICAgfSxcbiAgICB7IG5vZGVzOiByZXN1bHROb2RlcywgbGluZU51bWJlcjogY29udGV4dC5saW5lTnVtYmVyIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudE9yVGV4dChub2RlKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFwiZWxlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJ0ZXh0XCI7XG59XG5mdW5jdGlvbiBnZXRMaW5lU3RhcnQobm9kZSwgZmFsbGJhY2tMaW5lU3RhcnQgPSAxKSB7XG4gIHJldHVybiBub2RlLmRhdGEgJiYgdHlwZW9mIG5vZGUuZGF0YS5saW5lU3RhcnQgPT0gXCJudW1iZXJcIiA/IG5vZGUuZGF0YS5saW5lU3RhcnQgOiBmYWxsYmFja0xpbmVTdGFydDtcbn1cbmZ1bmN0aW9uIGdldExpbmVFbmQobm9kZSwgZmFsbGJhY2tMaW5lRW5kID0gMSkge1xuICByZXR1cm4gbm9kZS5kYXRhICYmIHR5cGVvZiBub2RlLmRhdGEubGluZUVuZCA9PSBcIm51bWJlclwiID8gbm9kZS5kYXRhLmxpbmVFbmQgOiBmYWxsYmFja0xpbmVFbmQ7XG59XG5mdW5jdGlvbiBzZXRMaW5lSW5mbyhub2RlLCBsaW5lU3RhcnQsIGxpbmVFbmQpIHtcbiAgcmV0dXJuIG5vZGUuZGF0YSB8fCAobm9kZS5kYXRhID0ge30pLCBub2RlLmRhdGEubGluZVN0YXJ0ID0gbGluZVN0YXJ0LCBub2RlLmRhdGEubGluZUVuZCA9IGxpbmVFbmQsIG5vZGU7XG59XG5mdW5jdGlvbiB1bndyYXBMaW5lKG1hcmtlckxpbmUsIG5vZGVzKSB7XG4gIGNvbnN0IHRyZWUgPSB7IHR5cGU6IFwicm9vdFwiLCBjaGlsZHJlbjogbm9kZXMgfSwgaGVhZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBsaW5lTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIHRhaWxNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgY2xvbmVkID0gW107XG4gIGZ1bmN0aW9uIGFkZENvcHkobWFwLCBub2RlLCBhbmNlc3RvcnMpIHtcbiAgICBjbG9uZWQucHVzaChub2RlKSwgYW5jZXN0b3JzLmZvckVhY2goKGFuY2VzdG9yKSA9PiB7XG4gICAgICBtYXAuaGFzKGFuY2VzdG9yKSB8fCAobWFwLnNldChhbmNlc3RvciwgT2JqZWN0LmFzc2lnbih7fSwgYW5jZXN0b3IsIHsgY2hpbGRyZW46IFtdIH0pKSwgYW5jZXN0b3IgIT09IHRyZWUgJiYgY2xvbmVkLnB1c2goYW5jZXN0b3IpKTtcbiAgICB9KTtcbiAgICBsZXQgaSA9IGFuY2VzdG9ycy5sZW5ndGg7XG4gICAgZm9yICg7IGktLTsgKSB7XG4gICAgICBjb25zdCBhbmNlc3RvciA9IG1hcC5nZXQoYW5jZXN0b3JzW2ldKTtcbiAgICAgIGlmICghYW5jZXN0b3IgfHwgIShcImNoaWxkcmVuXCIgaW4gYW5jZXN0b3IpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGNoaWxkID0gYW5jZXN0b3JzW2kgKyAxXSwgbGVhZiA9IG1hcC5nZXQoY2hpbGQpIHx8IG5vZGU7XG4gICAgICBhbmNlc3Rvci5jaGlsZHJlbi5pbmRleE9mKGxlYWYpID09PSAtMSAmJiBhbmNlc3Rvci5jaGlsZHJlbi5wdXNoKGxlYWYpO1xuICAgIH1cbiAgfVxuICB2aXNpdFBhcmVudHModHJlZSwgKG5vZGUsIGFuY2VzdG9ycykgPT4ge1xuICAgIGlmICghKFwiY2hpbGRyZW5cIiBpbiBub2RlIHx8ICFpc0VsZW1lbnRPclRleHQobm9kZSkpKSB7XG4gICAgICBpZiAoZ2V0TGluZVN0YXJ0KG5vZGUpIDwgbWFya2VyTGluZSkge1xuICAgICAgICBhZGRDb3B5KGhlYWRNYXAsIG5vZGUsIGFuY2VzdG9ycyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChnZXRMaW5lU3RhcnQobm9kZSkgPT09IG1hcmtlckxpbmUpIHtcbiAgICAgICAgYWRkQ29weShsaW5lTWFwLCBub2RlLCBhbmNlc3RvcnMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBnZXRMaW5lRW5kKG5vZGUpID4gbWFya2VyTGluZSAmJiBjbG9uZWQuc29tZSgoY2xvbmUpID0+IGFuY2VzdG9ycy5pbmNsdWRlcyhjbG9uZSkpICYmIGFkZENvcHkodGFpbE1hcCwgbm9kZSwgYW5jZXN0b3JzKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBmaWx0ZXJlZCA9IGZpbHRlcih0cmVlLCAobm9kZSkgPT4gY2xvbmVkLmluZGV4T2Yobm9kZSkgPT09IC0xKSwgZ2V0Q2hpbGRyZW4gPSAobWFwKSA9PiB7XG4gICAgY29uc3Qgcm9vdE5vZGUgPSBtYXAuZ2V0KHRyZWUpO1xuICAgIHJldHVybiByb290Tm9kZSA/ICh2aXNpdFBhcmVudHMocm9vdE5vZGUsIChsZWFmLCBhbmNlc3RvcnMpID0+IHtcbiAgICAgIGlmIChpc0VsZW1lbnRPclRleHQobGVhZikgJiYgXCJjaGlsZHJlblwiIGluIGxlYWYpIHtcbiAgICAgICAgc2V0TGluZUluZm8obGVhZiwgMCwgMCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFuY2VzdG9ycy5mb3JFYWNoKChhbmNlc3RvcikgPT4ge1xuICAgICAgICBzZXRMaW5lSW5mbyhcbiAgICAgICAgICBhbmNlc3RvcixcbiAgICAgICAgICBNYXRoLm1heChnZXRMaW5lU3RhcnQoYW5jZXN0b3IpLCBnZXRMaW5lU3RhcnQobGVhZikpLFxuICAgICAgICAgIE1hdGgubWF4KGdldExpbmVFbmQoYW5jZXN0b3IpLCBnZXRMaW5lRW5kKGxlYWYpKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSksIHJvb3ROb2RlLmNoaWxkcmVuKSA6IFtdO1xuICB9O1xuICByZXR1cm4gW1xuICAgIC4uLmdldENoaWxkcmVuKGhlYWRNYXApLFxuICAgIC4uLmdldENoaWxkcmVuKGxpbmVNYXApLFxuICAgIC4uLmdldENoaWxkcmVuKHRhaWxNYXApLFxuICAgIC4uLmZpbHRlcmVkID8gZmlsdGVyZWQuY2hpbGRyZW4gOiBbXVxuICBdO1xufVxuZnVuY3Rpb24gd3JhcEJhdGNoKGNoaWxkcmVuLCBtYXJrZXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2xhc3NOYW1lID0gbWFya2VyLmNsYXNzTmFtZSB8fCBcInJlZnJhY3Rvci1tYXJrZXJcIiwgYmFzZURhdGEgPSB7XG4gICAgbGluZVN0YXJ0OiBtYXJrZXIubGluZSxcbiAgICBsaW5lRW5kOiBnZXRMaW5lRW5kKGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdKSxcbiAgICBpc01hcmtlcjogITBcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICB0YWdOYW1lOiBcImRpdlwiLFxuICAgIGRhdGE6IG1hcmtlci5jb21wb25lbnQgPyBfX3NwcmVhZFByb3BzJDIoX19zcHJlYWRWYWx1ZXMkMih7fSwgYmFzZURhdGEpLCB7IGNvbXBvbmVudDogbWFya2VyLmNvbXBvbmVudCwgbWFya2VyUHJvcGVydGllczogb3B0aW9ucyB9KSA6IGJhc2VEYXRhLFxuICAgIHByb3BlcnRpZXM6IHsgY2xhc3NOYW1lIH0sXG4gICAgY2hpbGRyZW5cbiAgfTtcbn1cbmZ1bmN0aW9uIHdyYXBMaW5lcyh0cmVlTm9kZXMsIG1hcmtlcnMsIG9wdGlvbnMpIHtcbiAgY29uc3QgYXN0ID0gbWFya2Vycy5yZWR1Y2UoXG4gICAgKGFjYywgbWFya2VyKSA9PiB1bndyYXBMaW5lKG1hcmtlci5saW5lLCBhY2MpLFxuICAgIHRyZWVOb2Rlc1xuICApLCB3cmFwcGVkID0gW107XG4gIGxldCBhc3RJbmRleCA9IDA7XG4gIGZvciAobGV0IG0gPSAwOyBtIDwgbWFya2Vycy5sZW5ndGg7IG0rKykge1xuICAgIGNvbnN0IG1hcmtlciA9IG1hcmtlcnNbbV07XG4gICAgZm9yIChsZXQgbm9kZSA9IGFzdFthc3RJbmRleF07IG5vZGUgJiYgZ2V0TGluZUVuZChub2RlKSA8IG1hcmtlci5saW5lOyBub2RlID0gYXN0WysrYXN0SW5kZXhdKVxuICAgICAgd3JhcHBlZC5wdXNoKG5vZGUpO1xuICAgIGNvbnN0IGJhdGNoID0gW107XG4gICAgZm9yIChsZXQgbm9kZSA9IGFzdFthc3RJbmRleF07IG5vZGUgJiYgZ2V0TGluZUVuZChub2RlKSA9PT0gbWFya2VyLmxpbmU7IG5vZGUgPSBhc3RbKythc3RJbmRleF0pXG4gICAgICBub2RlLnR5cGUgIT09IFwiZG9jdHlwZVwiICYmIGJhdGNoLnB1c2gobm9kZSk7XG4gICAgYmF0Y2gubGVuZ3RoID4gMCAmJiB3cmFwcGVkLnB1c2god3JhcEJhdGNoKGJhdGNoLCBtYXJrZXIsIG9wdGlvbnMpKTtcbiAgfVxuICBmb3IgKDsgYXN0SW5kZXggPCBhc3QubGVuZ3RoOyApXG4gICAgd3JhcHBlZC5wdXNoKGFzdFthc3RJbmRleCsrXSk7XG4gIHJldHVybiB7IHR5cGU6IFwicm9vdFwiLCBjaGlsZHJlbjogd3JhcHBlZCB9O1xufVxudmFyIF9fZGVmUHJvcCQxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBfX2RlZlByb3BzJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcywgX19nZXRPd25Qcm9wRGVzY3MkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzLCBfX2dldE93blByb3BTeW1ib2xzJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBfX2hhc093blByb3AkMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIF9fcHJvcElzRW51bSQxID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgX19kZWZOb3JtYWxQcm9wJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDEob2JqLCBrZXksIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlLCBfX3NwcmVhZFZhbHVlcyQxID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIF9faGFzT3duUHJvcCQxLmNhbGwoYiwgcHJvcCkgJiYgX19kZWZOb3JtYWxQcm9wJDEoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzJDEpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzJDEoYikpXG4gICAgICBfX3Byb3BJc0VudW0kMS5jYWxsKGIsIHByb3ApICYmIF9fZGVmTm9ybWFsUHJvcCQxKGEsIHByb3AsIGJbcHJvcF0pO1xuICByZXR1cm4gYTtcbn0sIF9fc3ByZWFkUHJvcHMkMSA9IChhLCBiKSA9PiBfX2RlZlByb3BzJDEoYSwgX19nZXRPd25Qcm9wRGVzY3MkMShiKSk7XG5mdW5jdGlvbiBtYXBXaXRoRGVwdGgoZGVwdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNoaWxkLCBpKSB7XG4gICAgcmV0dXJuIG1hcENoaWxkKGNoaWxkLCBpLCBkZXB0aCk7XG4gIH07XG59XG5mdW5jdGlvbiBtYXBDaGlsZChjaGlsZCwgaSwgZGVwdGgpIHtcbiAgaWYgKGNoaWxkLnR5cGUgPT09IFwiZG9jdHlwZVwiKVxuICAgIHJldHVybiBudWxsO1xuICBpZiAoIShcInRhZ05hbWVcIiBpbiBjaGlsZCkpXG4gICAgcmV0dXJuIGNoaWxkLnZhbHVlO1xuICBsZXQgY2xhc3NOYW1lID0gXCJcIjtcbiAgdHlwZW9mIGNoaWxkLnByb3BlcnRpZXMgPCBcInVcIiAmJiAoY2xhc3NOYW1lID0gQXJyYXkuaXNBcnJheShjaGlsZC5wcm9wZXJ0aWVzLmNsYXNzTmFtZSkgPyBjaGlsZC5wcm9wZXJ0aWVzLmNsYXNzTmFtZS5qb2luKFwiIFwiKSA6IGAke2NoaWxkLnByb3BlcnRpZXMuY2xhc3NOYW1lfWApO1xuICBjb25zdCBrZXkgPSBgZnJhY3QtJHtkZXB0aH0tJHtpfWAsIGNoaWxkcmVuID0gY2hpbGQuY2hpbGRyZW4gJiYgY2hpbGQuY2hpbGRyZW4ubWFwKG1hcFdpdGhEZXB0aChkZXB0aCArIDEpKTtcbiAgcmV0dXJuIGlzUmVhY3RSZWZyYWN0b3JNYXJrZXJEYXRhV2l0aENvbXBvbmVudChjaGlsZC5kYXRhKSA/IGNyZWF0ZUVsZW1lbnQoXG4gICAgY2hpbGQuZGF0YS5jb21wb25lbnQsXG4gICAgX19zcHJlYWRQcm9wcyQxKF9fc3ByZWFkVmFsdWVzJDEoX19zcHJlYWRWYWx1ZXMkMSh7IGtleSB9LCBjaGlsZC5wcm9wZXJ0aWVzKSwgY2hpbGQuZGF0YS5tYXJrZXJQcm9wZXJ0aWVzKSwgeyBjbGFzc05hbWUgfSksXG4gICAgY2hpbGRyZW5cbiAgKSA6IGNyZWF0ZUVsZW1lbnQoY2hpbGQudGFnTmFtZSwgeyBrZXksIGNsYXNzTmFtZSB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBpc1JlYWN0UmVmcmFjdG9yTWFya2VyRGF0YVdpdGhDb21wb25lbnQoZGF0YSkge1xuICByZXR1cm4gdHlwZW9mIGRhdGEgPT0gXCJvYmplY3RcIiAmJiBkYXRhICE9PSBudWxsICYmIFwiY29tcG9uZW50XCIgaW4gZGF0YSAmJiBcIm1hcmtlclByb3BlcnRpZXNcIiBpbiBkYXRhO1xufVxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLCBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzLCBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWUsIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApICYmIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKVxuICAgICAgX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkgJiYgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICByZXR1cm4gYTtcbn0sIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5jb25zdCBERUZBVUxUX0NMQVNTTkFNRSA9IFwicmVmcmFjdG9yXCI7XG5mdW5jdGlvbiBSZWZyYWN0b3IocHJvcHMpIHtcbiAgY29uc3QgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lIHx8IERFRkFVTFRfQ0xBU1NOQU1FLCBsYW5nQ2xhc3NOYW1lID0gYGxhbmd1YWdlLSR7cHJvcHMubGFuZ3VhZ2V9YCwgY29kZVByb3BzID0geyBjbGFzc05hbWU6IGxhbmdDbGFzc05hbWUgfSwgcHJlQ2xhc3MgPSBbY2xhc3NOYW1lLCBsYW5nQ2xhc3NOYW1lXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIik7XG4gIGlmIChwcm9wcy5pbmxpbmUgJiYgKGNvZGVQcm9wcy5zdHlsZSA9IHsgZGlzcGxheTogXCJpbmxpbmVcIiB9LCBjb2RlUHJvcHMuY2xhc3NOYW1lID0gY2xhc3NOYW1lKSwgcHJvcHMucGxhaW5UZXh0KSB7XG4gICAgY29uc3QgY29kZTIgPSAvKiBAX19QVVJFX18gKi8ganN4KFwiY29kZVwiLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBjb2RlUHJvcHMpLCB7IGNoaWxkcmVuOiBwcm9wcy52YWx1ZSB9KSk7XG4gICAgcmV0dXJuIHByb3BzLmlubGluZSA/IGNvZGUyIDogLyogQF9fUFVSRV9fICovIGpzeChcInByZVwiLCB7IGNsYXNzTmFtZTogcHJlQ2xhc3MsIGNoaWxkcmVuOiBjb2RlMiB9KTtcbiAgfVxuICBsZXQgYXN0ID0gcmVmcmFjdG9yLmhpZ2hsaWdodChwcm9wcy52YWx1ZSwgcHJvcHMubGFuZ3VhZ2UpO1xuICBwcm9wcy5tYXJrZXJzICYmIHByb3BzLm1hcmtlcnMubGVuZ3RoID4gMCAmJiAoYXN0ID0gYWRkTWFya2Vycyhhc3QsIHsgbWFya2VyczogcHJvcHMubWFya2VycyB9KSk7XG4gIGNvbnN0IHZhbHVlID0gYXN0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCA/IHByb3BzLnZhbHVlIDogYXN0LmNoaWxkcmVuLm1hcChtYXBXaXRoRGVwdGgoMCkpLCBjb2RlID0gLyogQF9fUFVSRV9fICovIGpzeChcImNvZGVcIiwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgY29kZVByb3BzKSwgeyBjaGlsZHJlbjogdmFsdWUgfSkpO1xuICByZXR1cm4gcHJvcHMuaW5saW5lID8gY29kZSA6IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwcmVcIiwgeyBjbGFzc05hbWU6IHByZUNsYXNzLCBjaGlsZHJlbjogY29kZSB9KTtcbn1cbmNvbnN0IHJlZ2lzdGVyTGFuZ3VhZ2UgPSAobGFuZykgPT4gcmVmcmFjdG9yLnJlZ2lzdGVyKGxhbmcpLCBoYXNMYW5ndWFnZSA9IChsYW5nKSA9PiByZWZyYWN0b3IucmVnaXN0ZXJlZChsYW5nKTtcbmV4cG9ydCB7XG4gIFJlZnJhY3RvcixcbiAgaGFzTGFuZ3VhZ2UsXG4gIHJlZ2lzdGVyTGFuZ3VhZ2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-refractor/dist/index.js\n");

/***/ })

};
;