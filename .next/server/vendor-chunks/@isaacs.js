/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@isaacs";
exports.ids = ["vendor-chunks/@isaacs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@isaacs/ttlcache/index.js":
/*!************************************************!*\
  !*** ./node_modules/@isaacs/ttlcache/index.js ***!
  \************************************************/
/***/ ((module) => {

eval("// A simple TTL cache with max capacity option, ms resolution,\n// autopurge, and reasonably optimized performance\n// Relies on the fact that integer Object keys are kept sorted,\n// and managed very efficiently by V8.\n\n/* istanbul ignore next */\nconst perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst now = () => perf.now()\nconst isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n)\nconst isPosIntOrInf = n => n === Infinity || isPosInt(n)\n\nclass TTLCache {\n  constructor({\n    max = Infinity,\n    ttl,\n    updateAgeOnGet = false,\n    checkAgeOnGet = false,\n    noUpdateTTL = false,\n    dispose,\n    noDisposeOnSet = false,\n  } = {}) {\n    // {[expirationTime]: [keys]}\n    this.expirations = Object.create(null)\n    // {key=>val}\n    this.data = new Map()\n    // {key=>expiration}\n    this.expirationMap = new Map()\n    if (ttl !== undefined && !isPosIntOrInf(ttl)) {\n      throw new TypeError(\n        'ttl must be positive integer or Infinity if set'\n      )\n    }\n    if (!isPosIntOrInf(max)) {\n      throw new TypeError('max must be positive integer or Infinity')\n    }\n    this.ttl = ttl\n    this.max = max\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.checkAgeOnGet = !!checkAgeOnGet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDisposeOnSet = !!noDisposeOnSet\n    if (dispose !== undefined) {\n      if (typeof dispose !== 'function') {\n        throw new TypeError('dispose must be function if set')\n      }\n      this.dispose = dispose\n    }\n\n    this.timer = undefined\n    this.timerExpiration = undefined\n  }\n\n  setTimer(expiration, ttl) {\n    if (this.timerExpiration < expiration) {\n      return\n    }\n\n    if (this.timer) {\n      clearTimeout(this.timer)\n    }\n\n    const t = setTimeout(() => {\n      this.timer = undefined\n      this.timerExpiration = undefined\n      this.purgeStale()\n      for (const exp in this.expirations) {\n        this.setTimer(exp, exp - now())\n        break\n      }\n    }, ttl)\n\n    /* istanbul ignore else - affordance for non-node envs */\n    if (t.unref) t.unref()\n\n    this.timerExpiration = expiration\n    this.timer = t\n  }\n\n  // hang onto the timer so we can clearTimeout if all items\n  // are deleted.  Deno doesn't have Timer.unref(), so it\n  // hangs otherwise.\n  cancelTimer() {\n    if (this.timer) {\n      clearTimeout(this.timer)\n      this.timerExpiration = undefined\n      this.timer = undefined\n    }\n  }\n\n  /* istanbul ignore next */\n  cancelTimers() {\n    process.emitWarning(\n      'TTLCache.cancelTimers has been renamed to ' +\n        'TTLCache.cancelTimer (no \"s\"), and will be removed in the next ' +\n        'major version update'\n    )\n    return this.cancelTimer()\n  }\n\n  clear() {\n    const entries =\n      this.dispose !== TTLCache.prototype.dispose ? [...this] : []\n    this.data.clear()\n    this.expirationMap.clear()\n    // no need for any purging now\n    this.cancelTimer()\n    this.expirations = Object.create(null)\n    for (const [key, val] of entries) {\n      this.dispose(val, key, 'delete')\n    }\n  }\n\n  setTTL(key, ttl = this.ttl) {\n    const current = this.expirationMap.get(key)\n    if (current !== undefined) {\n      // remove from the expirations list, so it isn't purged\n      const exp = this.expirations[current]\n      if (!exp || exp.length <= 1) {\n        delete this.expirations[current]\n      } else {\n        this.expirations[current] = exp.filter(k => k !== key)\n      }\n    }\n\n    if (ttl !== Infinity) {\n      const expiration = Math.floor(now() + ttl)\n      this.expirationMap.set(key, expiration)\n      if (!this.expirations[expiration]) {\n        this.expirations[expiration] = []\n        this.setTimer(expiration, ttl)\n      }\n      this.expirations[expiration].push(key)\n    } else {\n      this.expirationMap.set(key, Infinity)\n    }\n  }\n\n  set(\n    key,\n    val,\n    {\n      ttl = this.ttl,\n      noUpdateTTL = this.noUpdateTTL,\n      noDisposeOnSet = this.noDisposeOnSet,\n    } = {}\n  ) {\n    if (!isPosIntOrInf(ttl)) {\n      throw new TypeError('ttl must be positive integer or Infinity')\n    }\n    if (this.expirationMap.has(key)) {\n      if (!noUpdateTTL) {\n        this.setTTL(key, ttl)\n      }\n      // has old value\n      const oldValue = this.data.get(key)\n      if (oldValue !== val) {\n        this.data.set(key, val)\n        if (!noDisposeOnSet) {\n          this.dispose(oldValue, key, 'set')\n        }\n      }\n    } else {\n      this.setTTL(key, ttl)\n      this.data.set(key, val)\n    }\n\n    while (this.size > this.max) {\n      this.purgeToCapacity()\n    }\n\n    return this\n  }\n\n  has(key) {\n    return this.data.has(key)\n  }\n\n  getRemainingTTL(key) {\n    const expiration = this.expirationMap.get(key)\n    return expiration === Infinity\n      ? expiration\n      : expiration !== undefined\n      ? Math.max(0, Math.ceil(expiration - now()))\n      : 0\n  }\n\n  get(\n    key,\n    {\n      updateAgeOnGet = this.updateAgeOnGet,\n      ttl = this.ttl,\n      checkAgeOnGet = this.checkAgeOnGet,\n    } = {}\n  ) {\n    const val = this.data.get(key)\n    if (checkAgeOnGet && this.getRemainingTTL(key) === 0) {\n      this.delete(key)\n      return undefined\n    }\n    if (updateAgeOnGet) {\n      this.setTTL(key, ttl)\n    }\n    return val\n  }\n\n  dispose(_, __) {}\n\n  delete(key) {\n    const current = this.expirationMap.get(key)\n    if (current !== undefined) {\n      const value = this.data.get(key)\n      this.data.delete(key)\n      this.expirationMap.delete(key)\n      const exp = this.expirations[current]\n      if (exp) {\n        if (exp.length <= 1) {\n          delete this.expirations[current]\n        } else {\n          this.expirations[current] = exp.filter(k => k !== key)\n        }\n      }\n      this.dispose(value, key, 'delete')\n      if (this.size === 0) {\n        this.cancelTimer()\n      }\n      return true\n    }\n    return false\n  }\n\n  purgeToCapacity() {\n    for (const exp in this.expirations) {\n      const keys = this.expirations[exp]\n      if (this.size - keys.length >= this.max) {\n        delete this.expirations[exp]\n        const entries = []\n        for (const key of keys) {\n          entries.push([key, this.data.get(key)])\n          this.data.delete(key)\n          this.expirationMap.delete(key)\n        }\n        for (const [key, val] of entries) {\n          this.dispose(val, key, 'evict')\n        }\n      } else {\n        const s = this.size - this.max\n        const entries = []\n        for (const key of keys.splice(0, s)) {\n          entries.push([key, this.data.get(key)])\n          this.data.delete(key)\n          this.expirationMap.delete(key)\n        }\n        for (const [key, val] of entries) {\n          this.dispose(val, key, 'evict')\n        }\n        return\n      }\n    }\n  }\n\n  get size() {\n    return this.data.size\n  }\n\n  purgeStale() {\n    const n = Math.ceil(now())\n    for (const exp in this.expirations) {\n      if (exp === 'Infinity' || exp > n) {\n        return\n      }\n\n      /* istanbul ignore next\n       * mysterious need for a guard here?\n       * https://github.com/isaacs/ttlcache/issues/26 */\n      const keys = [...(this.expirations[exp] || [])]\n      const entries = []\n      delete this.expirations[exp]\n      for (const key of keys) {\n        entries.push([key, this.data.get(key)])\n        this.data.delete(key)\n        this.expirationMap.delete(key)\n      }\n      for (const [key, val] of entries) {\n        this.dispose(val, key, 'stale')\n      }\n    }\n    if (this.size === 0) {\n      this.cancelTimer()\n    }\n  }\n\n  *entries() {\n    for (const exp in this.expirations) {\n      for (const key of this.expirations[exp]) {\n        yield [key, this.data.get(key)]\n      }\n    }\n  }\n  *keys() {\n    for (const exp in this.expirations) {\n      for (const key of this.expirations[exp]) {\n        yield key\n      }\n    }\n  }\n  *values() {\n    for (const exp in this.expirations) {\n      for (const key of this.expirations[exp]) {\n        yield this.data.get(key)\n      }\n    }\n  }\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n}\n\nmodule.exports = TTLCache\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGlzYWFjcy90dGxjYWNoZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1IsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3Jpc3AtY2xlYW5pbmcvLi9ub2RlX21vZHVsZXMvQGlzYWFjcy90dGxjYWNoZS9pbmRleC5qcz8wNWVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEEgc2ltcGxlIFRUTCBjYWNoZSB3aXRoIG1heCBjYXBhY2l0eSBvcHRpb24sIG1zIHJlc29sdXRpb24sXG4vLyBhdXRvcHVyZ2UsIGFuZCByZWFzb25hYmx5IG9wdGltaXplZCBwZXJmb3JtYW5jZVxuLy8gUmVsaWVzIG9uIHRoZSBmYWN0IHRoYXQgaW50ZWdlciBPYmplY3Qga2V5cyBhcmUga2VwdCBzb3J0ZWQsXG4vLyBhbmQgbWFuYWdlZCB2ZXJ5IGVmZmljaWVudGx5IGJ5IFY4LlxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgcGVyZiA9XG4gIHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiZcbiAgcGVyZm9ybWFuY2UgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gcGVyZm9ybWFuY2VcbiAgICA6IERhdGVcblxuY29uc3Qgbm93ID0gKCkgPT4gcGVyZi5ub3coKVxuY29uc3QgaXNQb3NJbnQgPSBuID0+IG4gJiYgbiA9PT0gTWF0aC5mbG9vcihuKSAmJiBuID4gMCAmJiBpc0Zpbml0ZShuKVxuY29uc3QgaXNQb3NJbnRPckluZiA9IG4gPT4gbiA9PT0gSW5maW5pdHkgfHwgaXNQb3NJbnQobilcblxuY2xhc3MgVFRMQ2FjaGUge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWF4ID0gSW5maW5pdHksXG4gICAgdHRsLFxuICAgIHVwZGF0ZUFnZU9uR2V0ID0gZmFsc2UsXG4gICAgY2hlY2tBZ2VPbkdldCA9IGZhbHNlLFxuICAgIG5vVXBkYXRlVFRMID0gZmFsc2UsXG4gICAgZGlzcG9zZSxcbiAgICBub0Rpc3Bvc2VPblNldCA9IGZhbHNlLFxuICB9ID0ge30pIHtcbiAgICAvLyB7W2V4cGlyYXRpb25UaW1lXTogW2tleXNdfVxuICAgIHRoaXMuZXhwaXJhdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgLy8ge2tleT0+dmFsfVxuICAgIHRoaXMuZGF0YSA9IG5ldyBNYXAoKVxuICAgIC8vIHtrZXk9PmV4cGlyYXRpb259XG4gICAgdGhpcy5leHBpcmF0aW9uTWFwID0gbmV3IE1hcCgpXG4gICAgaWYgKHR0bCAhPT0gdW5kZWZpbmVkICYmICFpc1Bvc0ludE9ySW5mKHR0bCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICd0dGwgbXVzdCBiZSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIEluZmluaXR5IGlmIHNldCdcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKCFpc1Bvc0ludE9ySW5mKG1heCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBtdXN0IGJlIHBvc2l0aXZlIGludGVnZXIgb3IgSW5maW5pdHknKVxuICAgIH1cbiAgICB0aGlzLnR0bCA9IHR0bFxuICAgIHRoaXMubWF4ID0gbWF4XG4gICAgdGhpcy51cGRhdGVBZ2VPbkdldCA9ICEhdXBkYXRlQWdlT25HZXRcbiAgICB0aGlzLmNoZWNrQWdlT25HZXQgPSAhIWNoZWNrQWdlT25HZXRcbiAgICB0aGlzLm5vVXBkYXRlVFRMID0gISFub1VwZGF0ZVRUTFxuICAgIHRoaXMubm9EaXNwb3NlT25TZXQgPSAhIW5vRGlzcG9zZU9uU2V0XG4gICAgaWYgKGRpc3Bvc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBkaXNwb3NlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Rpc3Bvc2UgbXVzdCBiZSBmdW5jdGlvbiBpZiBzZXQnKVxuICAgICAgfVxuICAgICAgdGhpcy5kaXNwb3NlID0gZGlzcG9zZVxuICAgIH1cblxuICAgIHRoaXMudGltZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLnRpbWVyRXhwaXJhdGlvbiA9IHVuZGVmaW5lZFxuICB9XG5cbiAgc2V0VGltZXIoZXhwaXJhdGlvbiwgdHRsKSB7XG4gICAgaWYgKHRoaXMudGltZXJFeHBpcmF0aW9uIDwgZXhwaXJhdGlvbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKVxuICAgIH1cblxuICAgIGNvbnN0IHQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudGltZXIgPSB1bmRlZmluZWRcbiAgICAgIHRoaXMudGltZXJFeHBpcmF0aW9uID0gdW5kZWZpbmVkXG4gICAgICB0aGlzLnB1cmdlU3RhbGUoKVxuICAgICAgZm9yIChjb25zdCBleHAgaW4gdGhpcy5leHBpcmF0aW9ucykge1xuICAgICAgICB0aGlzLnNldFRpbWVyKGV4cCwgZXhwIC0gbm93KCkpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfSwgdHRsKVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSBhZmZvcmRhbmNlIGZvciBub24tbm9kZSBlbnZzICovXG4gICAgaWYgKHQudW5yZWYpIHQudW5yZWYoKVxuXG4gICAgdGhpcy50aW1lckV4cGlyYXRpb24gPSBleHBpcmF0aW9uXG4gICAgdGhpcy50aW1lciA9IHRcbiAgfVxuXG4gIC8vIGhhbmcgb250byB0aGUgdGltZXIgc28gd2UgY2FuIGNsZWFyVGltZW91dCBpZiBhbGwgaXRlbXNcbiAgLy8gYXJlIGRlbGV0ZWQuICBEZW5vIGRvZXNuJ3QgaGF2ZSBUaW1lci51bnJlZigpLCBzbyBpdFxuICAvLyBoYW5ncyBvdGhlcndpc2UuXG4gIGNhbmNlbFRpbWVyKCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcilcbiAgICAgIHRoaXMudGltZXJFeHBpcmF0aW9uID0gdW5kZWZpbmVkXG4gICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgY2FuY2VsVGltZXJzKCkge1xuICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoXG4gICAgICAnVFRMQ2FjaGUuY2FuY2VsVGltZXJzIGhhcyBiZWVuIHJlbmFtZWQgdG8gJyArXG4gICAgICAgICdUVExDYWNoZS5jYW5jZWxUaW1lciAobm8gXCJzXCIpLCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0ICcgK1xuICAgICAgICAnbWFqb3IgdmVyc2lvbiB1cGRhdGUnXG4gICAgKVxuICAgIHJldHVybiB0aGlzLmNhbmNlbFRpbWVyKClcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIGNvbnN0IGVudHJpZXMgPVxuICAgICAgdGhpcy5kaXNwb3NlICE9PSBUVExDYWNoZS5wcm90b3R5cGUuZGlzcG9zZSA/IFsuLi50aGlzXSA6IFtdXG4gICAgdGhpcy5kYXRhLmNsZWFyKClcbiAgICB0aGlzLmV4cGlyYXRpb25NYXAuY2xlYXIoKVxuICAgIC8vIG5vIG5lZWQgZm9yIGFueSBwdXJnaW5nIG5vd1xuICAgIHRoaXMuY2FuY2VsVGltZXIoKVxuICAgIHRoaXMuZXhwaXJhdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIGVudHJpZXMpIHtcbiAgICAgIHRoaXMuZGlzcG9zZSh2YWwsIGtleSwgJ2RlbGV0ZScpXG4gICAgfVxuICB9XG5cbiAgc2V0VFRMKGtleSwgdHRsID0gdGhpcy50dGwpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5leHBpcmF0aW9uTWFwLmdldChrZXkpXG4gICAgaWYgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmVtb3ZlIGZyb20gdGhlIGV4cGlyYXRpb25zIGxpc3QsIHNvIGl0IGlzbid0IHB1cmdlZFxuICAgICAgY29uc3QgZXhwID0gdGhpcy5leHBpcmF0aW9uc1tjdXJyZW50XVxuICAgICAgaWYgKCFleHAgfHwgZXhwLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmV4cGlyYXRpb25zW2N1cnJlbnRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4cGlyYXRpb25zW2N1cnJlbnRdID0gZXhwLmZpbHRlcihrID0+IGsgIT09IGtleSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHRsICE9PSBJbmZpbml0eSkge1xuICAgICAgY29uc3QgZXhwaXJhdGlvbiA9IE1hdGguZmxvb3Iobm93KCkgKyB0dGwpXG4gICAgICB0aGlzLmV4cGlyYXRpb25NYXAuc2V0KGtleSwgZXhwaXJhdGlvbilcbiAgICAgIGlmICghdGhpcy5leHBpcmF0aW9uc1tleHBpcmF0aW9uXSkge1xuICAgICAgICB0aGlzLmV4cGlyYXRpb25zW2V4cGlyYXRpb25dID0gW11cbiAgICAgICAgdGhpcy5zZXRUaW1lcihleHBpcmF0aW9uLCB0dGwpXG4gICAgICB9XG4gICAgICB0aGlzLmV4cGlyYXRpb25zW2V4cGlyYXRpb25dLnB1c2goa2V5KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cGlyYXRpb25NYXAuc2V0KGtleSwgSW5maW5pdHkpXG4gICAgfVxuICB9XG5cbiAgc2V0KFxuICAgIGtleSxcbiAgICB2YWwsXG4gICAge1xuICAgICAgdHRsID0gdGhpcy50dGwsXG4gICAgICBub1VwZGF0ZVRUTCA9IHRoaXMubm9VcGRhdGVUVEwsXG4gICAgICBub0Rpc3Bvc2VPblNldCA9IHRoaXMubm9EaXNwb3NlT25TZXQsXG4gICAgfSA9IHt9XG4gICkge1xuICAgIGlmICghaXNQb3NJbnRPckluZih0dGwpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0dGwgbXVzdCBiZSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIEluZmluaXR5JylcbiAgICB9XG4gICAgaWYgKHRoaXMuZXhwaXJhdGlvbk1hcC5oYXMoa2V5KSkge1xuICAgICAgaWYgKCFub1VwZGF0ZVRUTCkge1xuICAgICAgICB0aGlzLnNldFRUTChrZXksIHR0bClcbiAgICAgIH1cbiAgICAgIC8vIGhhcyBvbGQgdmFsdWVcbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5kYXRhLmdldChrZXkpXG4gICAgICBpZiAob2xkVmFsdWUgIT09IHZhbCkge1xuICAgICAgICB0aGlzLmRhdGEuc2V0KGtleSwgdmFsKVxuICAgICAgICBpZiAoIW5vRGlzcG9zZU9uU2V0KSB7XG4gICAgICAgICAgdGhpcy5kaXNwb3NlKG9sZFZhbHVlLCBrZXksICdzZXQnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0VFRMKGtleSwgdHRsKVxuICAgICAgdGhpcy5kYXRhLnNldChrZXksIHZhbClcbiAgICB9XG5cbiAgICB3aGlsZSAodGhpcy5zaXplID4gdGhpcy5tYXgpIHtcbiAgICAgIHRoaXMucHVyZ2VUb0NhcGFjaXR5KClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuaGFzKGtleSlcbiAgfVxuXG4gIGdldFJlbWFpbmluZ1RUTChrZXkpIHtcbiAgICBjb25zdCBleHBpcmF0aW9uID0gdGhpcy5leHBpcmF0aW9uTWFwLmdldChrZXkpXG4gICAgcmV0dXJuIGV4cGlyYXRpb24gPT09IEluZmluaXR5XG4gICAgICA/IGV4cGlyYXRpb25cbiAgICAgIDogZXhwaXJhdGlvbiAhPT0gdW5kZWZpbmVkXG4gICAgICA/IE1hdGgubWF4KDAsIE1hdGguY2VpbChleHBpcmF0aW9uIC0gbm93KCkpKVxuICAgICAgOiAwXG4gIH1cblxuICBnZXQoXG4gICAga2V5LFxuICAgIHtcbiAgICAgIHVwZGF0ZUFnZU9uR2V0ID0gdGhpcy51cGRhdGVBZ2VPbkdldCxcbiAgICAgIHR0bCA9IHRoaXMudHRsLFxuICAgICAgY2hlY2tBZ2VPbkdldCA9IHRoaXMuY2hlY2tBZ2VPbkdldCxcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy5kYXRhLmdldChrZXkpXG4gICAgaWYgKGNoZWNrQWdlT25HZXQgJiYgdGhpcy5nZXRSZW1haW5pbmdUVEwoa2V5KSA9PT0gMCkge1xuICAgICAgdGhpcy5kZWxldGUoa2V5KVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgICBpZiAodXBkYXRlQWdlT25HZXQpIHtcbiAgICAgIHRoaXMuc2V0VFRMKGtleSwgdHRsKVxuICAgIH1cbiAgICByZXR1cm4gdmFsXG4gIH1cblxuICBkaXNwb3NlKF8sIF9fKSB7fVxuXG4gIGRlbGV0ZShrZXkpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5leHBpcmF0aW9uTWFwLmdldChrZXkpXG4gICAgaWYgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmRhdGEuZ2V0KGtleSlcbiAgICAgIHRoaXMuZGF0YS5kZWxldGUoa2V5KVxuICAgICAgdGhpcy5leHBpcmF0aW9uTWFwLmRlbGV0ZShrZXkpXG4gICAgICBjb25zdCBleHAgPSB0aGlzLmV4cGlyYXRpb25zW2N1cnJlbnRdXG4gICAgICBpZiAoZXhwKSB7XG4gICAgICAgIGlmIChleHAubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5leHBpcmF0aW9uc1tjdXJyZW50XVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZXhwaXJhdGlvbnNbY3VycmVudF0gPSBleHAuZmlsdGVyKGsgPT4gayAhPT0ga2V5KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmRpc3Bvc2UodmFsdWUsIGtleSwgJ2RlbGV0ZScpXG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsVGltZXIoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBwdXJnZVRvQ2FwYWNpdHkoKSB7XG4gICAgZm9yIChjb25zdCBleHAgaW4gdGhpcy5leHBpcmF0aW9ucykge1xuICAgICAgY29uc3Qga2V5cyA9IHRoaXMuZXhwaXJhdGlvbnNbZXhwXVxuICAgICAgaWYgKHRoaXMuc2l6ZSAtIGtleXMubGVuZ3RoID49IHRoaXMubWF4KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmV4cGlyYXRpb25zW2V4cF1cbiAgICAgICAgY29uc3QgZW50cmllcyA9IFtdXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICBlbnRyaWVzLnB1c2goW2tleSwgdGhpcy5kYXRhLmdldChrZXkpXSlcbiAgICAgICAgICB0aGlzLmRhdGEuZGVsZXRlKGtleSlcbiAgICAgICAgICB0aGlzLmV4cGlyYXRpb25NYXAuZGVsZXRlKGtleSlcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgICAgICAgIHRoaXMuZGlzcG9zZSh2YWwsIGtleSwgJ2V2aWN0JylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMuc2l6ZSAtIHRoaXMubWF4XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBbXVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzLnNwbGljZSgwLCBzKSkge1xuICAgICAgICAgIGVudHJpZXMucHVzaChba2V5LCB0aGlzLmRhdGEuZ2V0KGtleSldKVxuICAgICAgICAgIHRoaXMuZGF0YS5kZWxldGUoa2V5KVxuICAgICAgICAgIHRoaXMuZXhwaXJhdGlvbk1hcC5kZWxldGUoa2V5KVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgdGhpcy5kaXNwb3NlKHZhbCwga2V5LCAnZXZpY3QnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuc2l6ZVxuICB9XG5cbiAgcHVyZ2VTdGFsZSgpIHtcbiAgICBjb25zdCBuID0gTWF0aC5jZWlsKG5vdygpKVxuICAgIGZvciAoY29uc3QgZXhwIGluIHRoaXMuZXhwaXJhdGlvbnMpIHtcbiAgICAgIGlmIChleHAgPT09ICdJbmZpbml0eScgfHwgZXhwID4gbikge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAqIG15c3RlcmlvdXMgbmVlZCBmb3IgYSBndWFyZCBoZXJlP1xuICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy90dGxjYWNoZS9pc3N1ZXMvMjYgKi9cbiAgICAgIGNvbnN0IGtleXMgPSBbLi4uKHRoaXMuZXhwaXJhdGlvbnNbZXhwXSB8fCBbXSldXG4gICAgICBjb25zdCBlbnRyaWVzID0gW11cbiAgICAgIGRlbGV0ZSB0aGlzLmV4cGlyYXRpb25zW2V4cF1cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgZW50cmllcy5wdXNoKFtrZXksIHRoaXMuZGF0YS5nZXQoa2V5KV0pXG4gICAgICAgIHRoaXMuZGF0YS5kZWxldGUoa2V5KVxuICAgICAgICB0aGlzLmV4cGlyYXRpb25NYXAuZGVsZXRlKGtleSlcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZSh2YWwsIGtleSwgJ3N0YWxlJylcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5jYW5jZWxUaW1lcigpXG4gICAgfVxuICB9XG5cbiAgKmVudHJpZXMoKSB7XG4gICAgZm9yIChjb25zdCBleHAgaW4gdGhpcy5leHBpcmF0aW9ucykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5leHBpcmF0aW9uc1tleHBdKSB7XG4gICAgICAgIHlpZWxkIFtrZXksIHRoaXMuZGF0YS5nZXQoa2V5KV1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgKmtleXMoKSB7XG4gICAgZm9yIChjb25zdCBleHAgaW4gdGhpcy5leHBpcmF0aW9ucykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5leHBpcmF0aW9uc1tleHBdKSB7XG4gICAgICAgIHlpZWxkIGtleVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAqdmFsdWVzKCkge1xuICAgIGZvciAoY29uc3QgZXhwIGluIHRoaXMuZXhwaXJhdGlvbnMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMuZXhwaXJhdGlvbnNbZXhwXSkge1xuICAgICAgICB5aWVsZCB0aGlzLmRhdGEuZ2V0KGtleSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUVExDYWNoZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@isaacs/ttlcache/index.js\n");

/***/ })

};
;