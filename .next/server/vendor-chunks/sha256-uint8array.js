"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sha256-uint8array";
exports.ids = ["vendor-chunks/sha256-uint8array"];
exports.modules = {

/***/ "(ssr)/./node_modules/sha256-uint8array/dist/sha256-uint8array.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/sha256-uint8array/dist/sha256-uint8array.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   createHash: () => (/* binding */ createHash)\n/* harmony export */ });\n/**\n * sha256-uint8array.ts\n */\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311\nconst K = [\n    0x428a2f98 | 0, 0x71374491 | 0, 0xb5c0fbcf | 0, 0xe9b5dba5 | 0,\n    0x3956c25b | 0, 0x59f111f1 | 0, 0x923f82a4 | 0, 0xab1c5ed5 | 0,\n    0xd807aa98 | 0, 0x12835b01 | 0, 0x243185be | 0, 0x550c7dc3 | 0,\n    0x72be5d74 | 0, 0x80deb1fe | 0, 0x9bdc06a7 | 0, 0xc19bf174 | 0,\n    0xe49b69c1 | 0, 0xefbe4786 | 0, 0x0fc19dc6 | 0, 0x240ca1cc | 0,\n    0x2de92c6f | 0, 0x4a7484aa | 0, 0x5cb0a9dc | 0, 0x76f988da | 0,\n    0x983e5152 | 0, 0xa831c66d | 0, 0xb00327c8 | 0, 0xbf597fc7 | 0,\n    0xc6e00bf3 | 0, 0xd5a79147 | 0, 0x06ca6351 | 0, 0x14292967 | 0,\n    0x27b70a85 | 0, 0x2e1b2138 | 0, 0x4d2c6dfc | 0, 0x53380d13 | 0,\n    0x650a7354 | 0, 0x766a0abb | 0, 0x81c2c92e | 0, 0x92722c85 | 0,\n    0xa2bfe8a1 | 0, 0xa81a664b | 0, 0xc24b8b70 | 0, 0xc76c51a3 | 0,\n    0xd192e819 | 0, 0xd6990624 | 0, 0xf40e3585 | 0, 0x106aa070 | 0,\n    0x19a4c116 | 0, 0x1e376c08 | 0, 0x2748774c | 0, 0x34b0bcb5 | 0,\n    0x391c0cb3 | 0, 0x4ed8aa4a | 0, 0x5b9cca4f | 0, 0x682e6ff3 | 0,\n    0x748f82ee | 0, 0x78a5636f | 0, 0x84c87814 | 0, 0x8cc70208 | 0,\n    0x90befffa | 0, 0xa4506ceb | 0, 0xbef9a3f7 | 0, 0xc67178f2 | 0,\n];\nconst algorithms = {\n    sha256: 1,\n};\nfunction createHash(algorithm) {\n    if (algorithm && !algorithms[algorithm] && !algorithms[algorithm.toLowerCase()]) {\n        throw new Error(\"Digest method not supported\");\n    }\n    return new Hash();\n}\nclass Hash {\n    constructor() {\n        // first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n        this.A = 0x6a09e667 | 0;\n        this.B = 0xbb67ae85 | 0;\n        this.C = 0x3c6ef372 | 0;\n        this.D = 0xa54ff53a | 0;\n        this.E = 0x510e527f | 0;\n        this.F = 0x9b05688c | 0;\n        this.G = 0x1f83d9ab | 0;\n        this.H = 0x5be0cd19 | 0;\n        this._size = 0;\n        this._sp = 0; // surrogate pair\n        if (!sharedBuffer || sharedOffset >= 8000 /* N.allocTotal */) {\n            sharedBuffer = new ArrayBuffer(8000 /* N.allocTotal */);\n            sharedOffset = 0;\n        }\n        this._byte = new Uint8Array(sharedBuffer, sharedOffset, 80 /* N.allocBytes */);\n        this._word = new Int32Array(sharedBuffer, sharedOffset, 20 /* N.allocWords */);\n        sharedOffset += 80 /* N.allocBytes */;\n    }\n    update(data) {\n        // data: string\n        if (\"string\" === typeof data) {\n            return this._utf8(data);\n        }\n        // data: undefined\n        if (data == null) {\n            throw new TypeError(\"Invalid type: \" + typeof data);\n        }\n        const byteOffset = data.byteOffset;\n        const length = data.byteLength;\n        let blocks = (length / 64 /* N.inputBytes */) | 0;\n        let offset = 0;\n        // longer than 1 block\n        if (blocks && !(byteOffset & 3) && !(this._size % 64 /* N.inputBytes */)) {\n            const block = new Int32Array(data.buffer, byteOffset, blocks * 16 /* N.inputWords */);\n            while (blocks--) {\n                this._int32(block, offset >> 2);\n                offset += 64 /* N.inputBytes */;\n            }\n            this._size += offset;\n        }\n        // data: TypedArray | DataView\n        const BYTES_PER_ELEMENT = data.BYTES_PER_ELEMENT;\n        if (BYTES_PER_ELEMENT !== 1 && data.buffer) {\n            const rest = new Uint8Array(data.buffer, byteOffset + offset, length - offset);\n            return this._uint8(rest);\n        }\n        // no more bytes\n        if (offset === length)\n            return this;\n        // data: Uint8Array | Int8Array\n        return this._uint8(data, offset);\n    }\n    _uint8(data, offset) {\n        const { _byte, _word } = this;\n        const length = data.length;\n        offset = offset | 0;\n        while (offset < length) {\n            const start = this._size % 64 /* N.inputBytes */;\n            let index = start;\n            while (offset < length && index < 64 /* N.inputBytes */) {\n                _byte[index++] = data[offset++];\n            }\n            if (index >= 64 /* N.inputBytes */) {\n                this._int32(_word);\n            }\n            this._size += index - start;\n        }\n        return this;\n    }\n    _utf8(text) {\n        const { _byte, _word } = this;\n        const length = text.length;\n        let surrogate = this._sp;\n        for (let offset = 0; offset < length;) {\n            const start = this._size % 64 /* N.inputBytes */;\n            let index = start;\n            while (offset < length && index < 64 /* N.inputBytes */) {\n                let code = text.charCodeAt(offset++) | 0;\n                if (code < 0x80) {\n                    // ASCII characters\n                    _byte[index++] = code;\n                }\n                else if (code < 0x800) {\n                    // 2 bytes\n                    _byte[index++] = 0xC0 | (code >>> 6);\n                    _byte[index++] = 0x80 | (code & 0x3F);\n                }\n                else if (code < 0xD800 || code > 0xDFFF) {\n                    // 3 bytes\n                    _byte[index++] = 0xE0 | (code >>> 12);\n                    _byte[index++] = 0x80 | ((code >>> 6) & 0x3F);\n                    _byte[index++] = 0x80 | (code & 0x3F);\n                }\n                else if (surrogate) {\n                    // 4 bytes - surrogate pair\n                    code = ((surrogate & 0x3FF) << 10) + (code & 0x3FF) + 0x10000;\n                    _byte[index++] = 0xF0 | (code >>> 18);\n                    _byte[index++] = 0x80 | ((code >>> 12) & 0x3F);\n                    _byte[index++] = 0x80 | ((code >>> 6) & 0x3F);\n                    _byte[index++] = 0x80 | (code & 0x3F);\n                    surrogate = 0;\n                }\n                else {\n                    surrogate = code;\n                }\n            }\n            if (index >= 64 /* N.inputBytes */) {\n                this._int32(_word);\n                _word[0] = _word[16 /* N.inputWords */];\n            }\n            this._size += index - start;\n        }\n        this._sp = surrogate;\n        return this;\n    }\n    _int32(data, offset) {\n        let { A, B, C, D, E, F, G, H } = this;\n        let i = 0;\n        offset = offset | 0;\n        while (i < 16 /* N.inputWords */) {\n            W[i++] = swap32(data[offset++]);\n        }\n        for (i = 16 /* N.inputWords */; i < 64 /* N.workWords */; i++) {\n            W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0;\n        }\n        for (i = 0; i < 64 /* N.workWords */; i++) {\n            const T1 = (H + sigma1(E) + ch(E, F, G) + K[i] + W[i]) | 0;\n            const T2 = (sigma0(A) + maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        this.A = (A + this.A) | 0;\n        this.B = (B + this.B) | 0;\n        this.C = (C + this.C) | 0;\n        this.D = (D + this.D) | 0;\n        this.E = (E + this.E) | 0;\n        this.F = (F + this.F) | 0;\n        this.G = (G + this.G) | 0;\n        this.H = (H + this.H) | 0;\n    }\n    digest(encoding) {\n        const { _byte, _word } = this;\n        let i = (this._size % 64 /* N.inputBytes */) | 0;\n        _byte[i++] = 0x80;\n        // pad 0 for current word\n        while (i & 3) {\n            _byte[i++] = 0;\n        }\n        i >>= 2;\n        if (i > 14 /* N.highIndex */) {\n            while (i < 16 /* N.inputWords */) {\n                _word[i++] = 0;\n            }\n            i = 0;\n            this._int32(_word);\n        }\n        // pad 0 for rest words\n        while (i < 16 /* N.inputWords */) {\n            _word[i++] = 0;\n        }\n        // input size\n        const bits64 = this._size * 8;\n        const low32 = (bits64 & 0xffffffff) >>> 0;\n        const high32 = (bits64 - low32) / 0x100000000;\n        if (high32)\n            _word[14 /* N.highIndex */] = swap32(high32);\n        if (low32)\n            _word[15 /* N.lowIndex */] = swap32(low32);\n        this._int32(_word);\n        return (encoding === \"hex\") ? this._hex() : this._bin();\n    }\n    _hex() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return hex32(A) + hex32(B) + hex32(C) + hex32(D) + hex32(E) + hex32(F) + hex32(G) + hex32(H);\n    }\n    _bin() {\n        const { A, B, C, D, E, F, G, H, _byte, _word } = this;\n        _word[0] = swap32(A);\n        _word[1] = swap32(B);\n        _word[2] = swap32(C);\n        _word[3] = swap32(D);\n        _word[4] = swap32(E);\n        _word[5] = swap32(F);\n        _word[6] = swap32(G);\n        _word[7] = swap32(H);\n        return _byte.slice(0, 32);\n    }\n}\nconst W = new Int32Array(64 /* N.workWords */);\nlet sharedBuffer;\nlet sharedOffset = 0;\nconst hex32 = num => (num + 0x100000000).toString(16).substr(-8);\nconst swapLE = (c => (((c << 24) & 0xff000000) | ((c << 8) & 0xff0000) | ((c >> 8) & 0xff00) | ((c >> 24) & 0xff)));\nconst swapBE = (c => c);\nconst swap32 = isBE() ? swapBE : swapLE;\nconst ch = (x, y, z) => (z ^ (x & (y ^ z)));\nconst maj = (x, y, z) => ((x & y) | (z & (x | y)));\nconst sigma0 = x => ((x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10));\nconst sigma1 = x => ((x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7));\nconst gamma0 = x => ((x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3));\nconst gamma1 = x => ((x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10));\nfunction isBE() {\n    const buf = new Uint8Array(new Uint16Array([0xFEFF]).buffer); // BOM\n    return (buf[0] === 0xFE);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2hhMjU2LXVpbnQ4YXJyYXkvZGlzdC9zaGEyNTYtdWludDhhcnJheS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywwQkFBMEI7QUFDbEU7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmlzcC1jbGVhbmluZy8uL25vZGVfbW9kdWxlcy9zaGEyNTYtdWludDhhcnJheS9kaXN0L3NoYTI1Ni11aW50OGFycmF5Lm1qcz9hOTMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogc2hhMjU2LXVpbnQ4YXJyYXkudHNcbiAqL1xuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMVxuY29uc3QgSyA9IFtcbiAgICAweDQyOGEyZjk4IHwgMCwgMHg3MTM3NDQ5MSB8IDAsIDB4YjVjMGZiY2YgfCAwLCAweGU5YjVkYmE1IHwgMCxcbiAgICAweDM5NTZjMjViIHwgMCwgMHg1OWYxMTFmMSB8IDAsIDB4OTIzZjgyYTQgfCAwLCAweGFiMWM1ZWQ1IHwgMCxcbiAgICAweGQ4MDdhYTk4IHwgMCwgMHgxMjgzNWIwMSB8IDAsIDB4MjQzMTg1YmUgfCAwLCAweDU1MGM3ZGMzIHwgMCxcbiAgICAweDcyYmU1ZDc0IHwgMCwgMHg4MGRlYjFmZSB8IDAsIDB4OWJkYzA2YTcgfCAwLCAweGMxOWJmMTc0IHwgMCxcbiAgICAweGU0OWI2OWMxIHwgMCwgMHhlZmJlNDc4NiB8IDAsIDB4MGZjMTlkYzYgfCAwLCAweDI0MGNhMWNjIHwgMCxcbiAgICAweDJkZTkyYzZmIHwgMCwgMHg0YTc0ODRhYSB8IDAsIDB4NWNiMGE5ZGMgfCAwLCAweDc2Zjk4OGRhIHwgMCxcbiAgICAweDk4M2U1MTUyIHwgMCwgMHhhODMxYzY2ZCB8IDAsIDB4YjAwMzI3YzggfCAwLCAweGJmNTk3ZmM3IHwgMCxcbiAgICAweGM2ZTAwYmYzIHwgMCwgMHhkNWE3OTE0NyB8IDAsIDB4MDZjYTYzNTEgfCAwLCAweDE0MjkyOTY3IHwgMCxcbiAgICAweDI3YjcwYTg1IHwgMCwgMHgyZTFiMjEzOCB8IDAsIDB4NGQyYzZkZmMgfCAwLCAweDUzMzgwZDEzIHwgMCxcbiAgICAweDY1MGE3MzU0IHwgMCwgMHg3NjZhMGFiYiB8IDAsIDB4ODFjMmM5MmUgfCAwLCAweDkyNzIyYzg1IHwgMCxcbiAgICAweGEyYmZlOGExIHwgMCwgMHhhODFhNjY0YiB8IDAsIDB4YzI0YjhiNzAgfCAwLCAweGM3NmM1MWEzIHwgMCxcbiAgICAweGQxOTJlODE5IHwgMCwgMHhkNjk5MDYyNCB8IDAsIDB4ZjQwZTM1ODUgfCAwLCAweDEwNmFhMDcwIHwgMCxcbiAgICAweDE5YTRjMTE2IHwgMCwgMHgxZTM3NmMwOCB8IDAsIDB4Mjc0ODc3NGMgfCAwLCAweDM0YjBiY2I1IHwgMCxcbiAgICAweDM5MWMwY2IzIHwgMCwgMHg0ZWQ4YWE0YSB8IDAsIDB4NWI5Y2NhNGYgfCAwLCAweDY4MmU2ZmYzIHwgMCxcbiAgICAweDc0OGY4MmVlIHwgMCwgMHg3OGE1NjM2ZiB8IDAsIDB4ODRjODc4MTQgfCAwLCAweDhjYzcwMjA4IHwgMCxcbiAgICAweDkwYmVmZmZhIHwgMCwgMHhhNDUwNmNlYiB8IDAsIDB4YmVmOWEzZjcgfCAwLCAweGM2NzE3OGYyIHwgMCxcbl07XG5jb25zdCBhbGdvcml0aG1zID0ge1xuICAgIHNoYTI1NjogMSxcbn07XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaChhbGdvcml0aG0pIHtcbiAgICBpZiAoYWxnb3JpdGhtICYmICFhbGdvcml0aG1zW2FsZ29yaXRobV0gJiYgIWFsZ29yaXRobXNbYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpZ2VzdCBtZXRob2Qgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBIYXNoKCk7XG59XG5leHBvcnQgY2xhc3MgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTlcbiAgICAgICAgdGhpcy5BID0gMHg2YTA5ZTY2NyB8IDA7XG4gICAgICAgIHRoaXMuQiA9IDB4YmI2N2FlODUgfCAwO1xuICAgICAgICB0aGlzLkMgPSAweDNjNmVmMzcyIHwgMDtcbiAgICAgICAgdGhpcy5EID0gMHhhNTRmZjUzYSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IDB4NTEwZTUyN2YgfCAwO1xuICAgICAgICB0aGlzLkYgPSAweDliMDU2ODhjIHwgMDtcbiAgICAgICAgdGhpcy5HID0gMHgxZjgzZDlhYiB8IDA7XG4gICAgICAgIHRoaXMuSCA9IDB4NWJlMGNkMTkgfCAwO1xuICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgdGhpcy5fc3AgPSAwOyAvLyBzdXJyb2dhdGUgcGFpclxuICAgICAgICBpZiAoIXNoYXJlZEJ1ZmZlciB8fCBzaGFyZWRPZmZzZXQgPj0gODAwMCAvKiBOLmFsbG9jVG90YWwgKi8pIHtcbiAgICAgICAgICAgIHNoYXJlZEJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig4MDAwIC8qIE4uYWxsb2NUb3RhbCAqLyk7XG4gICAgICAgICAgICBzaGFyZWRPZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2J5dGUgPSBuZXcgVWludDhBcnJheShzaGFyZWRCdWZmZXIsIHNoYXJlZE9mZnNldCwgODAgLyogTi5hbGxvY0J5dGVzICovKTtcbiAgICAgICAgdGhpcy5fd29yZCA9IG5ldyBJbnQzMkFycmF5KHNoYXJlZEJ1ZmZlciwgc2hhcmVkT2Zmc2V0LCAyMCAvKiBOLmFsbG9jV29yZHMgKi8pO1xuICAgICAgICBzaGFyZWRPZmZzZXQgKz0gODAgLyogTi5hbGxvY0J5dGVzICovO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICAvLyBkYXRhOiBzdHJpbmdcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXRmOChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkYXRhOiB1bmRlZmluZWRcbiAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdHlwZTogXCIgKyB0eXBlb2YgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IGRhdGEuYnl0ZU9mZnNldDtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICBsZXQgYmxvY2tzID0gKGxlbmd0aCAvIDY0IC8qIE4uaW5wdXRCeXRlcyAqLykgfCAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgLy8gbG9uZ2VyIHRoYW4gMSBibG9ja1xuICAgICAgICBpZiAoYmxvY2tzICYmICEoYnl0ZU9mZnNldCAmIDMpICYmICEodGhpcy5fc2l6ZSAlIDY0IC8qIE4uaW5wdXRCeXRlcyAqLykpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gbmV3IEludDMyQXJyYXkoZGF0YS5idWZmZXIsIGJ5dGVPZmZzZXQsIGJsb2NrcyAqIDE2IC8qIE4uaW5wdXRXb3JkcyAqLyk7XG4gICAgICAgICAgICB3aGlsZSAoYmxvY2tzLS0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnQzMihibG9jaywgb2Zmc2V0ID4+IDIpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA2NCAvKiBOLmlucHV0Qnl0ZXMgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zaXplICs9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBkYXRhOiBUeXBlZEFycmF5IHwgRGF0YVZpZXdcbiAgICAgICAgY29uc3QgQllURVNfUEVSX0VMRU1FTlQgPSBkYXRhLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgICBpZiAoQllURVNfUEVSX0VMRU1FTlQgIT09IDEgJiYgZGF0YS5idWZmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3QgPSBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgYnl0ZU9mZnNldCArIG9mZnNldCwgbGVuZ3RoIC0gb2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91aW50OChyZXN0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBubyBtb3JlIGJ5dGVzXG4gICAgICAgIGlmIChvZmZzZXQgPT09IGxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAvLyBkYXRhOiBVaW50OEFycmF5IHwgSW50OEFycmF5XG4gICAgICAgIHJldHVybiB0aGlzLl91aW50OChkYXRhLCBvZmZzZXQpO1xuICAgIH1cbiAgICBfdWludDgoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHsgX2J5dGUsIF93b3JkIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9zaXplICUgNjQgLyogTi5pbnB1dEJ5dGVzICovO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gc3RhcnQ7XG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoICYmIGluZGV4IDwgNjQgLyogTi5pbnB1dEJ5dGVzICovKSB7XG4gICAgICAgICAgICAgICAgX2J5dGVbaW5kZXgrK10gPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCA+PSA2NCAvKiBOLmlucHV0Qnl0ZXMgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnQzMihfd29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zaXplICs9IGluZGV4IC0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIF91dGY4KHRleHQpIHtcbiAgICAgICAgY29uc3QgeyBfYnl0ZSwgX3dvcmQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgICAgICBsZXQgc3Vycm9nYXRlID0gdGhpcy5fc3A7XG4gICAgICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fc2l6ZSAlIDY0IC8qIE4uaW5wdXRCeXRlcyAqLztcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHN0YXJ0O1xuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCAmJiBpbmRleCA8IDY0IC8qIE4uaW5wdXRCeXRlcyAqLykge1xuICAgICAgICAgICAgICAgIGxldCBjb2RlID0gdGV4dC5jaGFyQ29kZUF0KG9mZnNldCsrKSB8IDA7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFTQ0lJIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgICAgX2J5dGVbaW5kZXgrK10gPSBjb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMiBieXRlc1xuICAgICAgICAgICAgICAgICAgICBfYnl0ZVtpbmRleCsrXSA9IDB4QzAgfCAoY29kZSA+Pj4gNik7XG4gICAgICAgICAgICAgICAgICAgIF9ieXRlW2luZGV4KytdID0gMHg4MCB8IChjb2RlICYgMHgzRik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPCAweEQ4MDAgfHwgY29kZSA+IDB4REZGRikge1xuICAgICAgICAgICAgICAgICAgICAvLyAzIGJ5dGVzXG4gICAgICAgICAgICAgICAgICAgIF9ieXRlW2luZGV4KytdID0gMHhFMCB8IChjb2RlID4+PiAxMik7XG4gICAgICAgICAgICAgICAgICAgIF9ieXRlW2luZGV4KytdID0gMHg4MCB8ICgoY29kZSA+Pj4gNikgJiAweDNGKTtcbiAgICAgICAgICAgICAgICAgICAgX2J5dGVbaW5kZXgrK10gPSAweDgwIHwgKGNvZGUgJiAweDNGKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3Vycm9nYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDQgYnl0ZXMgLSBzdXJyb2dhdGUgcGFpclxuICAgICAgICAgICAgICAgICAgICBjb2RlID0gKChzdXJyb2dhdGUgJiAweDNGRikgPDwgMTApICsgKGNvZGUgJiAweDNGRikgKyAweDEwMDAwO1xuICAgICAgICAgICAgICAgICAgICBfYnl0ZVtpbmRleCsrXSA9IDB4RjAgfCAoY29kZSA+Pj4gMTgpO1xuICAgICAgICAgICAgICAgICAgICBfYnl0ZVtpbmRleCsrXSA9IDB4ODAgfCAoKGNvZGUgPj4+IDEyKSAmIDB4M0YpO1xuICAgICAgICAgICAgICAgICAgICBfYnl0ZVtpbmRleCsrXSA9IDB4ODAgfCAoKGNvZGUgPj4+IDYpICYgMHgzRik7XG4gICAgICAgICAgICAgICAgICAgIF9ieXRlW2luZGV4KytdID0gMHg4MCB8IChjb2RlICYgMHgzRik7XG4gICAgICAgICAgICAgICAgICAgIHN1cnJvZ2F0ZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdXJyb2dhdGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCA+PSA2NCAvKiBOLmlucHV0Qnl0ZXMgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnQzMihfd29yZCk7XG4gICAgICAgICAgICAgICAgX3dvcmRbMF0gPSBfd29yZFsxNiAvKiBOLmlucHV0V29yZHMgKi9dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2l6ZSArPSBpbmRleCAtIHN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NwID0gc3Vycm9nYXRlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgX2ludDMyKGRhdGEsIG9mZnNldCkge1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgICAgIHdoaWxlIChpIDwgMTYgLyogTi5pbnB1dFdvcmRzICovKSB7XG4gICAgICAgICAgICBXW2krK10gPSBzd2FwMzIoZGF0YVtvZmZzZXQrK10pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDE2IC8qIE4uaW5wdXRXb3JkcyAqLzsgaSA8IDY0IC8qIE4ud29ya1dvcmRzICovOyBpKyspIHtcbiAgICAgICAgICAgIFdbaV0gPSAoZ2FtbWExKFdbaSAtIDJdKSArIFdbaSAtIDddICsgZ2FtbWEwKFdbaSAtIDE1XSkgKyBXW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjQgLyogTi53b3JrV29yZHMgKi87IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMShFKSArIGNoKEUsIEYsIEcpICsgS1tpXSArIFdbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMChBKSArIG1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgfVxuICAgIGRpZ2VzdChlbmNvZGluZykge1xuICAgICAgICBjb25zdCB7IF9ieXRlLCBfd29yZCB9ID0gdGhpcztcbiAgICAgICAgbGV0IGkgPSAodGhpcy5fc2l6ZSAlIDY0IC8qIE4uaW5wdXRCeXRlcyAqLykgfCAwO1xuICAgICAgICBfYnl0ZVtpKytdID0gMHg4MDtcbiAgICAgICAgLy8gcGFkIDAgZm9yIGN1cnJlbnQgd29yZFxuICAgICAgICB3aGlsZSAoaSAmIDMpIHtcbiAgICAgICAgICAgIF9ieXRlW2krK10gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGkgPj49IDI7XG4gICAgICAgIGlmIChpID4gMTQgLyogTi5oaWdoSW5kZXggKi8pIHtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgMTYgLyogTi5pbnB1dFdvcmRzICovKSB7XG4gICAgICAgICAgICAgICAgX3dvcmRbaSsrXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2ludDMyKF93b3JkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWQgMCBmb3IgcmVzdCB3b3Jkc1xuICAgICAgICB3aGlsZSAoaSA8IDE2IC8qIE4uaW5wdXRXb3JkcyAqLykge1xuICAgICAgICAgICAgX3dvcmRbaSsrXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5wdXQgc2l6ZVxuICAgICAgICBjb25zdCBiaXRzNjQgPSB0aGlzLl9zaXplICogODtcbiAgICAgICAgY29uc3QgbG93MzIgPSAoYml0czY0ICYgMHhmZmZmZmZmZikgPj4+IDA7XG4gICAgICAgIGNvbnN0IGhpZ2gzMiA9IChiaXRzNjQgLSBsb3czMikgLyAweDEwMDAwMDAwMDtcbiAgICAgICAgaWYgKGhpZ2gzMilcbiAgICAgICAgICAgIF93b3JkWzE0IC8qIE4uaGlnaEluZGV4ICovXSA9IHN3YXAzMihoaWdoMzIpO1xuICAgICAgICBpZiAobG93MzIpXG4gICAgICAgICAgICBfd29yZFsxNSAvKiBOLmxvd0luZGV4ICovXSA9IHN3YXAzMihsb3czMik7XG4gICAgICAgIHRoaXMuX2ludDMyKF93b3JkKTtcbiAgICAgICAgcmV0dXJuIChlbmNvZGluZyA9PT0gXCJoZXhcIikgPyB0aGlzLl9oZXgoKSA6IHRoaXMuX2JpbigpO1xuICAgIH1cbiAgICBfaGV4KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBoZXgzMihBKSArIGhleDMyKEIpICsgaGV4MzIoQykgKyBoZXgzMihEKSArIGhleDMyKEUpICsgaGV4MzIoRikgKyBoZXgzMihHKSArIGhleDMyKEgpO1xuICAgIH1cbiAgICBfYmluKCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIF9ieXRlLCBfd29yZCB9ID0gdGhpcztcbiAgICAgICAgX3dvcmRbMF0gPSBzd2FwMzIoQSk7XG4gICAgICAgIF93b3JkWzFdID0gc3dhcDMyKEIpO1xuICAgICAgICBfd29yZFsyXSA9IHN3YXAzMihDKTtcbiAgICAgICAgX3dvcmRbM10gPSBzd2FwMzIoRCk7XG4gICAgICAgIF93b3JkWzRdID0gc3dhcDMyKEUpO1xuICAgICAgICBfd29yZFs1XSA9IHN3YXAzMihGKTtcbiAgICAgICAgX3dvcmRbNl0gPSBzd2FwMzIoRyk7XG4gICAgICAgIF93b3JkWzddID0gc3dhcDMyKEgpO1xuICAgICAgICByZXR1cm4gX2J5dGUuc2xpY2UoMCwgMzIpO1xuICAgIH1cbn1cbmNvbnN0IFcgPSBuZXcgSW50MzJBcnJheSg2NCAvKiBOLndvcmtXb3JkcyAqLyk7XG5sZXQgc2hhcmVkQnVmZmVyO1xubGV0IHNoYXJlZE9mZnNldCA9IDA7XG5jb25zdCBoZXgzMiA9IG51bSA9PiAobnVtICsgMHgxMDAwMDAwMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoLTgpO1xuY29uc3Qgc3dhcExFID0gKGMgPT4gKCgoYyA8PCAyNCkgJiAweGZmMDAwMDAwKSB8ICgoYyA8PCA4KSAmIDB4ZmYwMDAwKSB8ICgoYyA+PiA4KSAmIDB4ZmYwMCkgfCAoKGMgPj4gMjQpICYgMHhmZikpKTtcbmNvbnN0IHN3YXBCRSA9IChjID0+IGMpO1xuY29uc3Qgc3dhcDMyID0gaXNCRSgpID8gc3dhcEJFIDogc3dhcExFO1xuY29uc3QgY2ggPSAoeCwgeSwgeikgPT4gKHogXiAoeCAmICh5IF4geikpKTtcbmNvbnN0IG1haiA9ICh4LCB5LCB6KSA9PiAoKHggJiB5KSB8ICh6ICYgKHggfCB5KSkpO1xuY29uc3Qgc2lnbWEwID0geCA9PiAoKHggPj4+IDIgfCB4IDw8IDMwKSBeICh4ID4+PiAxMyB8IHggPDwgMTkpIF4gKHggPj4+IDIyIHwgeCA8PCAxMCkpO1xuY29uc3Qgc2lnbWExID0geCA9PiAoKHggPj4+IDYgfCB4IDw8IDI2KSBeICh4ID4+PiAxMSB8IHggPDwgMjEpIF4gKHggPj4+IDI1IHwgeCA8PCA3KSk7XG5jb25zdCBnYW1tYTAgPSB4ID0+ICgoeCA+Pj4gNyB8IHggPDwgMjUpIF4gKHggPj4+IDE4IHwgeCA8PCAxNCkgXiAoeCA+Pj4gMykpO1xuY29uc3QgZ2FtbWExID0geCA9PiAoKHggPj4+IDE3IHwgeCA8PCAxNSkgXiAoeCA+Pj4gMTkgfCB4IDw8IDEzKSBeICh4ID4+PiAxMCkpO1xuZnVuY3Rpb24gaXNCRSgpIHtcbiAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShuZXcgVWludDE2QXJyYXkoWzB4RkVGRl0pLmJ1ZmZlcik7IC8vIEJPTVxuICAgIHJldHVybiAoYnVmWzBdID09PSAweEZFKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sha256-uint8array/dist/sha256-uint8array.mjs\n");

/***/ })

};
;